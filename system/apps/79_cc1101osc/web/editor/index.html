<!--
TODO: Assertion
multi signal / multi histo
signal drag
 signal zoom
histo columns?
signal view align + sync

histogram delete element -> hide window
signal view - refresh scroll left
nexus: bit range assert
hide histo
div 10 attr

text select disable, code demo
zero based indices, missing attr/default attr in demo
-->
<!--
<script src="https://cdn.jsdelivr.net/npm/rete@1.5.2/build/rete.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/vue/2.6.14/vue.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/rete-vue-render-plugin@0.5.1/build/vue-render-plugin.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/rete-connection-plugin@0.9.0/build/connection-plugin.min.js"></script>

<script src="https://cdn.jsdelivr.net/npm/rete-lifecycle-plugin@1.0.0-beta.1/build/lifecycle-plugin.min.js"></script>

<script src="https://cdn.jsdelivr.net/npm/alight@0.14.1/alight.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/lodash.js/4.17.11/lodash.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/rete-area-plugin@0.2.1/build/area-plugin.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/rete-context-menu-plugin@0.6.0/build/context-menu-plugin.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/rete-comment-plugin@0.3.0/build/comment-plugin.min.js"></script>           	
<script src="https://cdn.jsdelivr.net/npm/rete-history-plugin@0.1.0/build/history-plugin.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/rete-connection-mastery-plugin@0.1.0/build/connection-mastery-plugin.min.js"></script>

<script src="https://code.highcharts.com/highcharts.js"></script>
<script src="https://code.highcharts.com/modules/histogram-bellcurve.js"></script>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">
-->

<script src="offline/rete.min.js"></script>
<script src="offline/vue.min.js"></script>
<script src="offline/vue-render-plugin.min.js"></script>
<script src="offline/connection-plugin.min.js"></script>
<script src="offline/lifecycle-plugin.min.js"></script>
<script src="offline/alight.min.js"></script>
<script src="offline/lodash.min.js"></script>
<script src="offline/area-plugin.min.js"></script>
<script src="offline/context-menu-plugin.min.js"></script>
<script src="offline/comment-plugin.min.js"></script>           	
<script src="offline/history-plugin.min.js"></script>
<script src="offline/connection-mastery-plugin.min.js"></script>
<script src="offline/highcharts.js"></script>
<script src="offline/histogram-bellcurve.js"></script>
<link rel="stylesheet" href="offline/font-awesome.min.css">

<script src="signal.js"></script>
<script src="signalcanvas.js"></script>
<script src="signalhistogram.js"></script>
<script src="vuecontrols.js"></script>
<script src="retecontrols.js"></script>
<script src="retecomponents.js"></script>
<script src="demo.js"></script>

<style>
html, body {
  height: 100%;
  width: 100%;
  margin: 0;
  overflow: hidden;
}

@media (prefers-color-scheme: dark) {
body {
  background: black;
}
}

.node .control input, .node .input-control input {
  width: 140px;
}
select, input {
  width: 100%;
  border-radius: 30px;
  background-color: white;
  padding: 2px 6px;
  border: 1px solid #999;
  font-size: 110%;
  width: 170px;
}

.note {
  position: absolute;
  top: 0;
  left: 0;
  background: #7ca2ba;
  color: white;
  width: 100%;
  text-align: center;
  padding: 0.5em;
  font-family: sans-serif;
  z-index: 1;
  a {
    color: #eee;
  }
}

#chart {
  width: 800px;
  height: 400px;
  position: absolute;
  left: 800px;
  top: 200px;
  border:3px #04b solid;
  border-radius:10px;
  display: none;
}

input:disabled { background: #ddd; color: #888}

#panel {width:150px; background:#b0b0b040; position:fixed; left:0px; top:0px;
  color:#ffffff; padding:10px;}
#panel button {margin-top:5px; margin-left:5px;}
</style>


<div id="rete"></div>
<div id="chart"></div>
<div id="panel"></div>

<script>

var numSocket = new Rete.Socket('Number value');
var arrSocket = new Rete.Socket('Array value');
var attrSocket = new Rete.Socket('Attributes');

var html = "Samples:<br>";
for (var i in demo)
  html += `<button onClick="openDemo('${i}')">${i}</button>`;
document.querySelector("#panel").innerHTML = html;
function openDemo(i)
{
  var d = demo[i];
  if (i.split("_")[0] == "do")
    d();
  else if (i.split("_")[0] == "decode" || i.split("_")[0] == "encode")
    onNewModel(d);
  else
    onNewData(d);
}

var onNewData;

(async () => {
    var container = document.querySelector('#rete');
    var components = [new InputSignal(), new SubArray(), new Quantize(),
      new Histogram(), new Filter(), new Split(), new Pairs(), new LookupTable(), new Print(), new ToInteger(), new If(),
      new Attributes(), new DisplaySignal(), new Assert(), new Count(),
      new Denoise(), new Select(), new Code(), new RevAttributes(), new Sequence()];

    var getComponent = name => components.find(c=>c.constructor.name == name)
    var editor = new Rete.NodeEditor('demo@0.1.0', container);
    editor.use(ConnectionPlugin.default);
    editor.use(VueRenderPlugin.default);    
    editor.use(ContextMenuPlugin.default);
    editor.use(AreaPlugin);
    editor.use(CommentPlugin.default);
    editor.use(HistoryPlugin);
    editor.use(ConnectionMasteryPlugin.default);
    editor.use(LifecyclePlugin.default);

    var engine = new Rete.Engine('demo@0.1.0');
    
    components.map(c => {
      editor.register(c);
      engine.register(c);
    });

    editor.on('process nodecreated noderemoved connectioncreated connectionremoved', async () => {
      console.log('process');
        await engine.abort();
        await engine.process(editor.toJSON());
        //console.log(generateCode(editor.toJSON()));
    });

    editor.on('zoom', (e) => {
        if (e.source === 'dblclick' && editor.selected?.list[0]?.name == "Input signal")
        {
          var node = editor.selected?.list[0];
          var _node = editor.nodes.find(n => n.id == node.id)
          var newsignal = prompt("Enter new signal", JSON.stringify(node.data.out.data));
          if (newsignal)
          {
            node.data.out = new Signal(JSON.parse(newsignal))
            editor.trigger('process');
          }
          return false;
        }
        return e.source !== 'dblclick';
    });

    onNewData = (data) => {
      for (var i in editor.nodes)
      {
        if (editor.nodes[i].name == "Input signal")
        {
          editor.nodes[i].data.out = new Signal(data)
          editor.trigger('process');
        }
      }
    }

    onNewModel = async (model) => {
      var index = 0;
      var current = {};
      editor.clear();
      for (var i in model.components)
      {
        var component = await getComponent(model.components[i].id).createNode() 
        for (var j in model.components[i])
          if (j != "id")
          {
            if (j == "datatype")
              component.data[j].value = model.components[i][j]
            else
              component.data[j] = model.components[i][j]
          }
        component.position = [260 + (index%4)*250, 200 + Math.floor(index/4)*300]
        editor.addNode(component);
        current[i] = component;
        index++;
        if (model.components[i].id == "Code")
          index++; 
      }
      for (var c of model.connections)
      {
        var connOut = c[0].split(".");
        var connIn = c[1].split(".");

        var out = current[connOut[0]].outputs.get(connOut[1]);
        var inp = current[connIn[0]].inputs.get(connIn[1]);
        editor.connect(out, inp);      
      }
    }
    reteJson = () => editor.toJSON();
//    onNewModel(demo.decode_nexus);
    onNewModel(demo.decode_came001unip);
    editor.view.resize();
    //AreaPlugin.zoomAt(editor);
    editor.view.area.zoom(0.75, 0, -120);
    editor.trigger('process');
})();

window.document.addEventListener('SignalChanged', (e) => { 
  console.log("Got data", e.detail.data);
  onNewData(e.detail.data);
}, false);


function codeFlow(json)
{
  var flow = [];
  var getNode = (name) => {
    var nodes = Object.values(json.nodes).filter(n => n.name == name);
    if (nodes.length != 1)
      throw "Sigle node not found"
    return nodes[0];
  }
  var getChildren = (node) => {
    var ids = Object.values(node.outputs).map(o => o.connections).flat(1).map(x => x.node)
    return ids.map(i => json.nodes[i])
  }
  var findChild = (nodes, name) => {
    var nodes = nodes.filter(n => n.name == name);
    if (nodes.length != 1)
      return false;
    return nodes[0];
  }
  var hasLink = (children, link1, link2) =>
  {
    return true; // TODO: lazy
  }

  var curNode = getNode("Input signal");
  while (1)
  {
    var curChildren = getChildren(curNode);
    if (findChild(curChildren, "Assertion"))
    {
      flow.push(["Assert", findChild(curChildren, "Assertion").data.condition, flow[flow.length-1][0]])
      curChildren = curChildren.filter(n => n.name != "Assertion");
    }
    if (findChild(curChildren, "Print") || findChild(curChildren, "Histogram") || 
       findChild(curChildren, "Display signal"))
      curChildren = curChildren.filter(n => n.name != "Print" && n.name != "Histogram" && 
        n.name != "Display signal");
    if (curChildren.length == 1 && curChildren[0].name == "Quantize")
    {
      flow.push(["Quantize", curChildren[0].data.len])
      curNode = curChildren[0];
      continue;
    }
    if (curChildren.length == 2 && 
        findChild(curChildren, "Count elements") && 
        findChild(curChildren, "SubArray") &&
        hasLink(curChildren, "Count elements.out", "SubArray._begin"))
    {
      flow.push(["Skip while", findChild(curChildren, "Count elements").data.condition])
      curNode = findChild(curChildren, "SubArray");
      continue;
    }
    if (curChildren.length == 1 && 
        curChildren[0].name == "SubArray" && 
        curChildren[0].data.tillEnd && 
        curChildren[0].inputs._begin.connections.length == 0 &&
        curChildren[0].inputs._len.connections.length == 0)
    {
      flow.push(["Skip first", curChildren[0].data.begin])
      curNode = curChildren[0];
      continue;
    }
    if (curChildren.length == 1 && curChildren[0].name == "Lookup table" && 
        getChildren(curChildren[0]).length == 1 &&
        getChildren(curChildren[0])[0].name == "Lookup table")
    {
      // Manchester coding?
      var lut1 = curChildren[0];
      var lut2 = getChildren(lut1)[0];
      if ([lut1.data.assign1, lut1.data.assign2, lut1.data.assign3, lut1.data.assign4].flat(1).join(";") ==
          "500L;L;500H;H;1000L;L, L;1000H;H, H" &&
          [lut2.data.assign1, lut2.data.assign2, lut2.data.assign3, lut2.data.assign4].flat(1).join(";") ==
          "H, L;0;L, H;1;H;0;;")
      {
        flow.push(["Manchester", parseInt(lut1.data.assign1[0])])
        curNode = lut2;
        continue;
      }
    }

    if (curChildren.length == 1 && curChildren[0].name == "Lookup table" )
    {
      var lut = curChildren[0];
      if (lut.data.assign1[0].split(",").length == 2 && lut.data.assign2[0].split(",").length == 2 &&
          lut.data.assign3[0] == "" && lut.data.assign3[0] == "")
      {
        flow.push(["Pair LUT", lut.data.assign1[0].split(",").map(x=>x.trim()),
          lut.data.assign1[1], lut.data.assign2[0].split(",").map(x=>x.trim()),
          lut.data.assign2[1]])
        curNode = curChildren[0]; // keep integer conversion as next element
        continue;
      }
    }

    if (curChildren.length == 1 && curChildren[0].name == "Bits to integer")
    {
      flow.push(["Bits to integer", curChildren[0].data.datatype.value, curChildren[0].data.firstbit.value])
      curNode = curChildren[0];
      continue;
    }
    if (curChildren.length == 1 && curChildren[0].name == "Attributes")
    {
      flow.push(["Attributes", curChildren[0].data.attribute1, curChildren[0].data.attribute2,
        curChildren[0].data.attribute3, curChildren[0].data.attribute4])
      curNode = curChildren[0];
      continue;
    }
    if (curChildren.length == 2 && 
        findChild(curChildren, "If signal...") && 
        findChild(curChildren, "SubArray") &&
        hasLink(curChildren, "If signal....out", "SubArray._begin") &&
        findChild(curChildren, "SubArray").data.tillEnd)
    {
      flow.push(["Conditional skip first", 
        findChild(curChildren, "If signal...").data.condition, 
        ...findChild(curChildren, "If signal...").data.retValues])
      curNode = findChild(curChildren, "SubArray");
      continue;
    }
    if (curChildren.length == 1 && curChildren[0].name == "Split" && curChildren[0].data.break)
    {
      flow.push(["Split", curChildren[0].data.condition])
      curNode = curChildren[0];
      continue;
    }
    if (curChildren.length == 0)
      break;
    flow.push(["Error", curChildren]);
//    console.log("Dont know how to process", curChildren);
    break;
  }
  return flow;
}

function codeSynth(json)
{
  var flow = codeFlow(json)
  var fullcode = [];
  var trailing = [];
  for (var fi=0; fi<flow.length; fi++)
  {
    var inject = false;
    var c = flow[fi];
    var code = [`// ${c}`];
    var inject = [];
    switch (c[0])
    {
      case "Quantize":
        var q = c[1];
        var half = q >> 1;
        code.push(`assert(len > 0 && arr[0] > ${half});`);
        code.push(`for (int i=1, j=1; i<len-1; i++, j++)`);
        code.push(`  if (arr[i] <= ${half})`)
        code.push(`  {`);
        code.push(`    arr[j-1] += arr[i] + arr[i+1];`);
        code.push(`    i += 2;`);
        code.push(`    len -= 2;`);
        code.push(`  }`);
        code.push(`for (int i=0; i<len; i++)`);
        code.push(`  arr[i] = (arr[i] + ${half}) / ${q} * ${q};`);
      break;
      case "Skip while":
        var cond = c[1].split("x").join("arr[0]");
        code.push(`while (len && ${cond})`);
        code.push(`{`);
        code.push(`  arr++;`);
        code.push(`  len--;`);
        code.push(`}`);
      break;
      case "Skip first":
        code.push(`assert(len >= ${c[1]});`);
        code.push(`arr += ${c[1]};`);
        code.push(`len -= ${c[1]};`);
      break;
      case "Assert":
        var cond = c[1];
        if (c[2] == "Pair LUT")
          cond = c[1].split("arr.length").join("datalen");
        else
          cond = c[1].split("arr.length").join("len");
        code.push(`if (!(${cond}))`);
        code.push(`  return false;`);
      break;
      case "Manchester":
        code.push("// TODO");
      break;
      case "Conditional skip first":
        code.push(`if (${c[1]})`);
        code.push(`{`);
        code.push(`  arr += ${c[2]};`);
        code.push(`  len -= ${c[2]};`);
        code.push(`} else`);
        code.push(`{`);
        code.push(`  arr += ${c[3]};`);
        code.push(`  len -= ${c[3]};`);
        code.push(`}`);
      break;
      case "Split":
        code.push("auto decoder = [](uint16_t* arr, int len)");
        code.push("{");
        var cond = c[1].split("x").join("arr[i]");
        trailing.push(`};`);

        trailing.push(`int lastSplit = 0;`);
        trailing.push(`for (int i=0; i<len; i++)`);
        trailing.push(`  if (${cond})`);
        trailing.push(`  {`);
        trailing.push(`    if (decoder(arr+lastSplit, i-lastSplit))`);
        trailing.push(`      return true;`);
        trailing.push(`    lastSplit = ++i;`);
        trailing.push(`  }`); // TODO: add last part
        trailing.push(`if (decoder(arr+lastSplit, len-lastSplit))`);
        trailing.push(`  return true;`);
      break;
      case "Pair LUT":
        code.push(`uint8_t databits[32] = {0};`);
        code.push(`int datalen{0};`);
        code.push(``);
        code.push(`auto pushBit = [&databits, &datalen](bool b)`);
        code.push(`{`);
        code.push(`  if (b)`);
        code.push(`    databits[datalen/8] |= 1 << (7-(datalen & 7));`);
        code.push(`  datalen++;`);
        code.push(`};`);
        code.push(``);

        code.push(`auto pushSymbol = [pushBit](char c)`);
        code.push(`{`);
        code.push(`  assert(c=='0' || c=='1');`);
        code.push(`  pushBit(c=='1');`);
        code.push(`};`);
        code.push(`assert(len%2 == 0);`);
        code.push(`for (int i=0; i<len; i+=2)`);
        code.push(`{`);
        for (var i=1; i<c.length; i+=2)
        {
          code.push(`  ${i>1 ? "else " : ""}if (arr[i] == ${c[i][0]} && arr[i+1] == ${c[i][1]})`);
          code.push(`    pushSymbol('${c[i+1]}');`);
        }
        code.push(`  else`);
        code.push(`    return false;`);
        code.push(`}`);
      break;
      case "Bits to integer":
        inject.push(`// Bits to integer`);
        inject.push(`uint8_t bitsData[32] = {0};`);
        inject.push(`int bitsLen = 0;`);
        inject.push(`auto pushBit = [&bitsData, &bitsLen](bool b)`);
        inject.push(`{`);
        inject.push(`  if (b && bitsLen/8 < sizeof(code))`);
        inject.push(`    code[bits/8] |= 1 << (7-(bits & 7));`);
        inject.push(`  bits++;`);
        inject.push(`};`);
        code.push("len = bits;");
        code.push("arr = nullptr;");
      break;
      case "Attributes":
        code.push(`auto extractBits = [&](int first, int last)`);
        code.push(`{`);
        code.push(`  uint32_t v=0;`);
        code.push(`  int len = last-first+1; // max min`); // TODO!
        code.push(`  if (last>=first)`);
        code.push(`    for (int i=first; i<=last; i++)`);
        code.push(`    {`);
        code.push(`      v >>= 1;`);
        code.push(`      if (databits[i/8] & (1<<(7-(i&7))))`);
        code.push(`        v |= 1 << (len-1);`);
        code.push(`    }`);
        code.push(`  return v;`);
        code.push(`};`);

        for (var i=1; i<c.length; i++)
        {
          var key = c[i][0];
          var val = c[i][1];
          if (!key || key == "")
            continue;
          if (val[0] == "\"")
            code.push(`printf("%s: '%s'\\n", "${key}", ${val});`);
          else if (val == "arr")
          {
            code.push(`assert(datalen <= 32);`);
            code.push(`printf("%s: 0x%x\\n", "${key}", extractBits(0, datalen));`);
          }
          else
            code.push(`printf("%s: %x\\n", "${key}", ${val});`);
        }
        code.push(`return true;`);
      break;
      case "Error":
        code.push("// Dont know how to process ${c[1]}")
      break;
    }
    if (inject.length)
      fullcode.splice(fullcode.length-2, 0, inject);
    if (code.length)
    {
      if (flow[fi][0] == "Bits to integer" && flow[fi-1][0] == "Assert") 
        fullcode.splice(fullcode.length-1, 0, code);
      else
        fullcode.push(code);
    }
  }

  fullcode.push(trailing);
  fullcode.push([`return false;`]);
  // TODO: arr.length -> len
  //console.log("\n\n\nCode:")
  return fullcode.map(c=>c.join("\n")).join("\n");
//  fullcode.forEach(c=>console.log(c.join("\n")))
  //console.log(fullcode.map(x=>x.join("\n")).join("\n"));
}

function generateCode(json)
{
  var getNode = (name) => {
    var nodes = Object.values(json.nodes).filter(n => n.name == name);
    if (nodes.length != 1)
      throw "Sigle node not found"
    return nodes[0];
  }
  var inputNodeData = getNode("Input signal")?.data?.out?.data;
  var fullcode = `
#include <stdio.h>
#include <assert.h>
#include <stdint.h>

uint16_t data[] = {${inputNodeData.join(", ")}};
bool test(uint16_t* arr, int len)
{
  ${codeSynth(json)}
}

int main(void)
{
  printf("res=%d\\n", test(data, sizeof(data)));
  return 0;
}
`
  return fullcode;
}

</script>