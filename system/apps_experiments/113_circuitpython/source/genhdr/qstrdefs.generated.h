// # words 60
// words [' must be ', ' argument', 'supported', ' should b', ' outside ', 'Init Erro', 'Invalid ', 'function', ' require', ' out of ', 'xpected ', ' ndarray', ' specifi', 'ttribute', 'haracter', 'multiple', 'argument', ' length', ' object', ' format', 'keyword', 'integer', 'defined', 'oo many', 'annot ', 'buffer', ' value', "can't ", 'string', ' error', 'equenc', ' with ', 'length', 'number', ' must ', 'xxxxxx', 'Buffer', ' not ', ' for ', 'array', ' type', " '%q'", ' and ', 'input', ' byte', 'range', ' time', ' the ', 'Could', ' size', 'tion', ' to ', ' is ', ' of ', 'able', ' or ', 'not ', ' in ', ' pin', ' int']
// 32   1116 0000 0
// 97 a 729 0001 1
// 101 e 1125 0010 2
// 105 i 612 0011 3
// 110 n 640 0100 4
// 111 o 630 0101 5
// 114 r 590 0110 6
// 115 s 652 0111 7
// 116 t 736 1000 8
// 99 c 334 10010 18
// 100 d 452 10011 19
// 108 l 423 10100 20
// 102 f 157 101010 42
// 103 g 161 101011 43
// 109 m 239 101100 44
// 112 p 268 101101 45
// 117 u 279 101110 46
// 121 y 162 101111 47
// 128  must be  91 1100000 96
// 37 % 84 1100001 97
// 39 \' 79 1100010 98
// 46 . 81 1100011 99
// 98 b 119 1100100 100
// 104 h 147 1100101 101
// 118 v 103 1100110 102
// 119 w 89 1100111 103
// 120 x 111 1101000 104
// 129  argument 41 11010010 210
// 166  for  39 11010011 211
// 180  is  59 11010100 212
// 165  not  66 11010101 213
// 179  to  40 11010110 214
// 44 , 40 11010111 215
// 45 - 49 11011000 216
// 48 0 42 11011001 217
// 67 C 69 11011010 218
// 68 D 38 11011011 219
// 73 I 43 11011100 220
// 80 P 48 11011101 221
// 84 T 41 11011110 222
// 95 _ 41 11011111 223
// 107 k 40 11100000 224
// 113 q 48 11100001 225
// 178 tion 42 11100010 226
// 10 \n 31 111000110 454
// 13 \r 31 111000111 455
// 169  \'%q\' 19 111001000 456
// 170  and  19 111001001 457
// 185  in  24 111001010 458
// 187  int 24 111001011 459
// 145  length 28 111001100 460
// 146  object 19 111001101 461
// 181  of  37 111001110 462
// 183  or  27 111001111 463
// 186  pin 20 111010000 464
// 168  type 20 111010001 465
// 40 ( 36 111010010 466
// 41 ) 36 111010011 467
// 47 / 24 111010100 468
// 49 1 28 111010101 469
// 50 2 24 111010110 470
// 58 : 22 111010111 471
// 65 A 32 111011000 472
// 66 B 21 111011001 473
// 69 E 22 111011010 474
// 134 Invalid  26 111011011 475
// 77 M 34 111011100 476
// 78 N 30 111011101 477
// 79 O 23 111011110 478
// 82 R 34 111011111 479
// 83 S 36 111100000 480
// 85 U 36 111100001 481
// 182 able 27 111100010 482
// 152 annot  19 111100011 483
// 167 array 27 111100100 484
// 135 function 20 111100101 485
// 184 not  25 111100110 486
// 130 supported 23 111100111 487
// 172  byte 14 1111010000 976
// 157  error 14 1111010001 977
// 147  format 14 1111010010 978
// 162  must  11 1111010011 979
// 139  ndarray 10 1111010100 980
// 137  out of  13 1111010101 981
// 136  require 16 1111010110 982
// 131  should b 10 1111010111 983
// 177  size 12 1111011000 984
// 140  specifi 10 1111011001 985
// 175  the  12 1111011010 986
// 174  time 14 1111011011 987
// 154  value 18 1111011100 988
// 159  with  12 1111011101 989
// 51 3 11 1111011110 990
// 53 5 17 1111011111 991
// 54 6 14 1111100000 992
// 61 = 11 1111100001 993
// 62 > 9 1111100010 994
// 176 Could 13 1111100011 995
// 70 F 15 1111100100 996
// 72 H 14 1111100101 997
// 76 L 13 1111100110 998
// 87 W 15 1111100111 999
// 153 buffer 18 1111101000 1000
// 155 can\'t  16 1111101001 1001
// 150 defined 11 1111101010 1002
// 158 equenc 12 1111101011 1003
// 142 haracter 10 1111101100 1004
// 171 input 18 1111101101 1005
// 106 j 15 1111101110 1006
// 148 keyword 12 1111101111 1007
// 160 length 12 1111110000 1008
// 161 number 11 1111110001 1009
// 173 range 14 1111110010 1010
// 156 string 15 1111110011 1011
// 141 ttribute 10 1111110100 1012
// 138 xpected  15 1111110101 1013
// 122 z 17 1111110110 1014
// 132  outside  7 11111101110 2030
// 42 * 8 11111101111 2031
// 52 4 5 11111110000 2032
// 164 Buffer 9 11111110001 2033
// 71 G 9 11111110010 2034
// 133 Init Erro 7 11111110011 2035
// 86 V 7 11111110100 2036
// 88 X 5 11111110101 2037
// 144 argument 9 11111110110 2038
// 149 integer 6 11111110111 2039
// 143 multiple 9 11111111000 2040
// 151 oo many 8 11111111001 2041
// 33 ! 4 111111110100 4084
// 34 \" 4 111111110101 4085
// 56 8 3 111111110110 4086
// 57 9 4 111111110111 4087
// 60 < 3 111111111000 4088
// 89 Y 4 111111111001 4089
// 96 ` 4 111111111010 4090
// 163 xxxxxx 3 111111111011 4091
// 35 # 1 1111111111000 8184
// 43 + 2 1111111111001 8185
// 55 7 1 1111111111010 8186
// 59 ; 2 1111111111011 8187
// 125 } 1 1111111111100 8188
// 126 ~ 1 1111111111101 8189
// 74 J 1 11111111111100 16380
// 91 [ 1 11111111111101 16381
// 93 ] 1 11111111111110 16382
// 123 { 1 11111111111111 16383
// length count {4: 9, 5: 3, 6: 6, 7: 9, 8: 17, 9: 34, 10: 39, 11: 12, 12: 8, 13: 6, 14: 4}
// values [' ', 'a', 'e', 'i', 'n', 'o', 'r', 's', 't', 'c', 'd', 'l', 'f', 'g', 'm', 'p', 'u', 'y', ' must be ', '%', "'", '.', 'b', 'h', 'v', 'w', 'x', ' argument', ' for ', ' is ', ' not ', ' to ', ',', '-', '0', 'C', 'D', 'I', 'P', 'T', '_', 'k', 'q', 'tion', '\n', '\r', " '%q'", ' and ', ' in ', ' int', ' length', ' object', ' of ', ' or ', ' pin', ' type', '(', ')', '/', '1', '2', ':', 'A', 'B', 'E', 'Invalid ', 'M', 'N', 'O', 'R', 'S', 'U', 'able', 'annot ', 'array', 'function', 'not ', 'supported', ' byte', ' error', ' format', ' must ', ' ndarray', ' out of ', ' require', ' should b', ' size', ' specifi', ' the ', ' time', ' value', ' with ', '3', '5', '6', '=', '>', 'Could', 'F', 'H', 'L', 'W', 'buffer', "can't ", 'defined', 'equenc', 'haracter', 'input', 'j', 'keyword', 'length', 'number', 'range', 'string', 'ttribute', 'xpected ', 'z', ' outside ', '*', '4', 'Buffer', 'G', 'Init Erro', 'V', 'X', 'argument', 'integer', 'multiple', 'oo many', '!', '"', '8', '9', '<', 'Y', '`', 'xxxxxx', '#', '+', '7', ';', '}', '~', 'J', '[', ']', '{'] lengths 15 bytearray(b'\x00\x00\x00\t\x03\x06\t\x11"\'\x0c\x08\x06\x04\x00')
// [' ', 'a', 'e', 'i', 'n', 'o', 'r', 's', 't', 'c', 'd', 'l', 'f', 'g', 'm', 'p', 'u', 'y', ' must be ', '%', "'", '.', 'b', 'h', 'v', 'w', 'x', ' argument', ' for ', ' is ', ' not ', ' to ', ',', '-', '0', 'C', 'D', 'I', 'P', 'T', '_', 'k', 'q', 'tion', '\n', '\r', " '%q'", ' and ', ' in ', ' int', ' length', ' object', ' of ', ' or ', ' pin', ' type', '(', ')', '/', '1', '2', ':', 'A', 'B', 'E', 'Invalid ', 'M', 'N', 'O', 'R', 'S', 'U', 'able', 'annot ', 'array', 'function', 'not ', 'supported', ' byte', ' error', ' format', ' must ', ' ndarray', ' out of ', ' require', ' should b', ' size', ' specifi', ' the ', ' time', ' value', ' with ', '3', '5', '6', '=', '>', 'Could', 'F', 'H', 'L', 'W', 'buffer', "can't ", 'defined', 'equenc', 'haracter', 'input', 'j', 'keyword', 'length', 'number', 'range', 'string', 'ttribute', 'xpected ', 'z', ' outside ', '*', '4', 'Buffer', 'G', 'Init Erro', 'V', 'X', 'argument', 'integer', 'multiple', 'oo many', '!', '"', '8', '9', '<', 'Y', '`', 'xxxxxx', '#', '+', '7', ';', '}', '~', 'J', '[', ']', '{'] bytearray(b'\x00\x00\x00\t\x03\x06\t\x11"\'\x0c\x08\x06\x04\x00')
// [' ', 'a', 'e', 'i', 'n', 'o', 'r', 's', 't', 'c', 'd', 'l', 'f', 'g', 'm', 'p', 'u', 'y', '\x80', '%', "'", '.', 'b', 'h', 'v', 'w', 'x', '\x81', '¦', '´', '¥', '³', ',', '-', '0', 'C', 'D', 'I', 'P', 'T', '_', 'k', 'q', '²', '\n', '\r', '©', 'ª', '¹', '»', '\x91', '\x92', 'µ', '·', 'º', '¨', '(', ')', '/', '1', '2', ':', 'A', 'B', 'E', '\x86', 'M', 'N', 'O', 'R', 'S', 'U', '¶', '\x98', '§', '\x87', '¸', '\x82', '¬', '\x9d', '\x93', '¢', '\x8b', '\x89', '\x88', '\x83', '±', '\x8c', '¯', '®', '\x9a', '\x9f', '3', '5', '6', '=', '>', '°', 'F', 'H', 'L', 'W', '\x99', '\x9b', '\x96', '\x9e', '\x8e', '«', 'j', '\x94', '\xa0', '¡', '\xad', '\x9c', '\x8d', '\x8a', 'z', '\x84', '*', '4', '¤', 'G', '\x85', 'V', 'X', '\x90', '\x95', '\x8f', '\x97', '!', '"', '8', '9', '<', 'Y', '`', '£', '#', '+', '7', ';', '}', '~', 'J', '[', ']', '{'] bytearray(b'\x00\x00\x00\t\x03\x06\t\x11"\'\x0c\x08\x06\x04\x00')
// This file was automatically generated by makeqstrdata.py

QDEF(MP_QSTR_NULL, (const byte*)"\x00\x00" "")
QDEF(MP_QSTR_, (const byte*)"\x05\x00" "")
QDEF(MP_QSTR___dir__, (const byte*)"\x7a\x07" "__dir__")
QDEF(MP_QSTR___abs__, (const byte*)"\x95\x07" "__abs__")
QDEF(MP_QSTR___add__, (const byte*)"\xc4\x07" "__add__")
QDEF(MP_QSTR___aenter__, (const byte*)"\x4c\x0a" "__aenter__")
QDEF(MP_QSTR___aexit__, (const byte*)"\xc4\x09" "__aexit__")
QDEF(MP_QSTR___aiter__, (const byte*)"\x4e\x09" "__aiter__")
QDEF(MP_QSTR___and__, (const byte*)"\x0e\x07" "__and__")
QDEF(MP_QSTR___anext__, (const byte*)"\x83\x09" "__anext__")
QDEF(MP_QSTR___await__, (const byte*)"\x4f\x09" "__await__")
QDEF(MP_QSTR___bool__, (const byte*)"\x2b\x08" "__bool__")
QDEF(MP_QSTR___build_class__, (const byte*)"\x42\x0f" "__build_class__")
QDEF(MP_QSTR___bytes__, (const byte*)"\xdc\x09" "__bytes__")
QDEF(MP_QSTR___call__, (const byte*)"\xa7\x08" "__call__")
QDEF(MP_QSTR___class__, (const byte*)"\x2b\x09" "__class__")
QDEF(MP_QSTR___contains__, (const byte*)"\xc6\x0c" "__contains__")
QDEF(MP_QSTR___del__, (const byte*)"\x68\x07" "__del__")
QDEF(MP_QSTR___delete__, (const byte*)"\xdc\x0a" "__delete__")
QDEF(MP_QSTR___delitem__, (const byte*)"\xfd\x0b" "__delitem__")
QDEF(MP_QSTR___dict__, (const byte*)"\x7f\x08" "__dict__")
QDEF(MP_QSTR___divmod__, (const byte*)"\x78\x0a" "__divmod__")
QDEF(MP_QSTR___enter__, (const byte*)"\x6d\x09" "__enter__")
QDEF(MP_QSTR___eq__, (const byte*)"\x71\x06" "__eq__")
QDEF(MP_QSTR___exit__, (const byte*)"\x45\x08" "__exit__")
QDEF(MP_QSTR___file__, (const byte*)"\x03\x08" "__file__")
QDEF(MP_QSTR___floordiv__, (const byte*)"\x46\x0c" "__floordiv__")
QDEF(MP_QSTR___func__, (const byte*)"\x5b\x08" "__func__")
QDEF(MP_QSTR___ge__, (const byte*)"\xa7\x06" "__ge__")
QDEF(MP_QSTR___get__, (const byte*)"\xb3\x07" "__get__")
QDEF(MP_QSTR___getattr__, (const byte*)"\x40\x0b" "__getattr__")
QDEF(MP_QSTR___getitem__, (const byte*)"\x26\x0b" "__getitem__")
QDEF(MP_QSTR___gt__, (const byte*)"\xb6\x06" "__gt__")
QDEF(MP_QSTR___hash__, (const byte*)"\xf7\x08" "__hash__")
QDEF(MP_QSTR___iadd__, (const byte*)"\x6d\x08" "__iadd__")
QDEF(MP_QSTR___import__, (const byte*)"\x38\x0a" "__import__")
QDEF(MP_QSTR___init__, (const byte*)"\x5f\x08" "__init__")
QDEF(MP_QSTR___invert__, (const byte*)"\xf7\x0a" "__invert__")
QDEF(MP_QSTR___isub__, (const byte*)"\x08\x08" "__isub__")
QDEF(MP_QSTR___iter__, (const byte*)"\xcf\x08" "__iter__")
QDEF(MP_QSTR___le__, (const byte*)"\xcc\x06" "__le__")
QDEF(MP_QSTR___len__, (const byte*)"\xe2\x07" "__len__")
QDEF(MP_QSTR___lshift__, (const byte*)"\x09\x0a" "__lshift__")
QDEF(MP_QSTR___lt__, (const byte*)"\x5d\x06" "__lt__")
QDEF(MP_QSTR___main__, (const byte*)"\x8e\x08" "__main__")
QDEF(MP_QSTR___mod__, (const byte*)"\x63\x07" "__mod__")
QDEF(MP_QSTR___module__, (const byte*)"\xff\x0a" "__module__")
QDEF(MP_QSTR___mul__, (const byte*)"\x31\x07" "__mul__")
QDEF(MP_QSTR___name__, (const byte*)"\xe2\x08" "__name__")
QDEF(MP_QSTR___neg__, (const byte*)"\x69\x07" "__neg__")
QDEF(MP_QSTR___new__, (const byte*)"\x79\x07" "__new__")
QDEF(MP_QSTR___next__, (const byte*)"\x02\x08" "__next__")
QDEF(MP_QSTR___or__, (const byte*)"\x38\x06" "__or__")
QDEF(MP_QSTR___path__, (const byte*)"\xc8\x08" "__path__")
QDEF(MP_QSTR___pos__, (const byte*)"\x29\x07" "__pos__")
QDEF(MP_QSTR___pow__, (const byte*)"\x2d\x07" "__pow__")
QDEF(MP_QSTR___qualname__, (const byte*)"\x6b\x0c" "__qualname__")
QDEF(MP_QSTR___radd__, (const byte*)"\x16\x08" "__radd__")
QDEF(MP_QSTR___rand__, (const byte*)"\xdc\x08" "__rand__")
QDEF(MP_QSTR___repl_print__, (const byte*)"\x01\x0e" "__repl_print__")
QDEF(MP_QSTR___repr__, (const byte*)"\x10\x08" "__repr__")
QDEF(MP_QSTR___reversed__, (const byte*)"\x61\x0c" "__reversed__")
QDEF(MP_QSTR___rfloordiv__, (const byte*)"\x54\x0d" "__rfloordiv__")
QDEF(MP_QSTR___rlshift__, (const byte*)"\x1b\x0b" "__rlshift__")
QDEF(MP_QSTR___rmod__, (const byte*)"\x31\x08" "__rmod__")
QDEF(MP_QSTR___rmul__, (const byte*)"\x63\x08" "__rmul__")
QDEF(MP_QSTR___ror__, (const byte*)"\x2a\x07" "__ror__")
QDEF(MP_QSTR___rpow__, (const byte*)"\xff\x08" "__rpow__")
QDEF(MP_QSTR___rrshift__, (const byte*)"\xc5\x0b" "__rrshift__")
QDEF(MP_QSTR___rshift__, (const byte*)"\x57\x0a" "__rshift__")
QDEF(MP_QSTR___rsub__, (const byte*)"\x73\x08" "__rsub__")
QDEF(MP_QSTR___rtruediv__, (const byte*)"\x5a\x0c" "__rtruediv__")
QDEF(MP_QSTR___rxor__, (const byte*)"\xf2\x08" "__rxor__")
QDEF(MP_QSTR___set__, (const byte*)"\xa7\x07" "__set__")
QDEF(MP_QSTR___setitem__, (const byte*)"\x32\x0b" "__setitem__")
QDEF(MP_QSTR___str__, (const byte*)"\xd0\x07" "__str__")
QDEF(MP_QSTR___sub__, (const byte*)"\x21\x07" "__sub__")
QDEF(MP_QSTR___traceback__, (const byte*)"\x4f\x0d" "__traceback__")
QDEF(MP_QSTR___truediv__, (const byte*)"\x88\x0b" "__truediv__")
QDEF(MP_QSTR___version__, (const byte*)"\x3f\x0b" "__version__")
QDEF(MP_QSTR___xor__, (const byte*)"\x20\x07" "__xor__")
QDEF(MP_QSTR__star_, (const byte*)"\x8f\x01" "*")
QDEF(MP_QSTR__, (const byte*)"\xfa\x01" "_")
QDEF(MP_QSTR__slash_, (const byte*)"\x8a\x01" "/")
QDEF(MP_QSTR__percent__hash_o, (const byte*)"\x6c\x03" "%#o")
QDEF(MP_QSTR__percent__hash_x, (const byte*)"\x7b\x03" "%#x")
QDEF(MP_QSTR__brace_open__colon__hash_b_brace_close_, (const byte*)"\x58\x05" "{:#b}")
QDEF(MP_QSTR__space_, (const byte*)"\x85\x01" " ")
QDEF(MP_QSTR__0x0a_, (const byte*)"\xaf\x01" "\x0a")
QDEF(MP_QSTR_maximum_space_recursion_space_depth_space_exceeded, (const byte*)"\x73\x20" "maximum recursion depth exceeded")
QDEF(MP_QSTR__lt_module_gt_, (const byte*)"\xbd\x08" "<module>")
QDEF(MP_QSTR__lt_lambda_gt_, (const byte*)"\x80\x08" "<lambda>")
QDEF(MP_QSTR__lt_listcomp_gt_, (const byte*)"\xd4\x0a" "<listcomp>")
QDEF(MP_QSTR__lt_dictcomp_gt_, (const byte*)"\xcc\x0a" "<dictcomp>")
QDEF(MP_QSTR__lt_setcomp_gt_, (const byte*)"\x54\x09" "<setcomp>")
QDEF(MP_QSTR__lt_genexpr_gt_, (const byte*)"\x34\x09" "<genexpr>")
QDEF(MP_QSTR__lt_string_gt_, (const byte*)"\x52\x08" "<string>")
QDEF(MP_QSTR__lt_stdin_gt_, (const byte*)"\xe3\x07" "<stdin>")
QDEF(MP_QSTR_utf_hyphen_8, (const byte*)"\xb7\x05" "utf-8")
QDEF(MP_QSTR_pystack_space_exhausted, (const byte*)"\x25\x11" "pystack exhausted")
QDEF(MP_QSTR__dot_frozen, (const byte*)"\x81\x07" ".frozen")
QDEF(MP_QSTR__slash_lib, (const byte*)"\x8d\x04" "/lib")
QDEF(MP_QSTR_A0, (const byte*)"\x54\x02" "A0")
QDEF(MP_QSTR_A1, (const byte*)"\x55\x02" "A1")
QDEF(MP_QSTR_A2, (const byte*)"\x56\x02" "A2")
QDEF(MP_QSTR_A3, (const byte*)"\x57\x02" "A3")
QDEF(MP_QSTR_A4, (const byte*)"\x50\x02" "A4")
QDEF(MP_QSTR_A5, (const byte*)"\x51\x02" "A5")
QDEF(MP_QSTR_AUTO_RELOAD, (const byte*)"\x04\x0b" "AUTO_RELOAD")
QDEF(MP_QSTR_Adapter, (const byte*)"\x12\x07" "Adapter")
QDEF(MP_QSTR_Address, (const byte*)"\x93\x07" "Address")
QDEF(MP_QSTR_AnalogIn, (const byte*)"\xc8\x08" "AnalogIn")
QDEF(MP_QSTR_AnalogOut, (const byte*)"\x41\x09" "AnalogOut")
QDEF(MP_QSTR_ArithmeticError, (const byte*)"\x2d\x0f" "ArithmeticError")
QDEF(MP_QSTR_AssertionError, (const byte*)"\x97\x0e" "AssertionError")
QDEF(MP_QSTR_Attribute, (const byte*)"\xf9\x09" "Attribute")
QDEF(MP_QSTR_AttributeError, (const byte*)"\x21\x0e" "AttributeError")
QDEF(MP_QSTR_BGR, (const byte*)"\xd2\x03" "BGR")
QDEF(MP_QSTR_BOOTLOADER, (const byte*)"\xe2\x0a" "BOOTLOADER")
QDEF(MP_QSTR_BROADCAST, (const byte*)"\x5a\x09" "BROADCAST")
QDEF(MP_QSTR_BROWNOUT, (const byte*)"\x8d\x08" "BROWNOUT")
QDEF(MP_QSTR_BaseException, (const byte*)"\x07\x0d" "BaseException")
QDEF(MP_QSTR_Bitmap, (const byte*)"\x46\x06" "Bitmap")
QDEF(MP_QSTR_BluetoothError, (const byte*)"\xab\x0e" "BluetoothError")
QDEF(MP_QSTR_BrokenPipeError, (const byte*)"\x2e\x0f" "BrokenPipeError")
QDEF(MP_QSTR_BuiltinFont, (const byte*)"\x97\x0b" "BuiltinFont")
QDEF(MP_QSTR_BytesIO, (const byte*)"\x1a\x07" "BytesIO")
QDEF(MP_QSTR_C, (const byte*)"\xe6\x01" "C")
QDEF(MP_QSTR_Characteristic, (const byte*)"\x58\x0e" "Characteristic")
QDEF(MP_QSTR_CharacteristicBuffer, (const byte*)"\x98\x14" "CharacteristicBuffer")
QDEF(MP_QSTR_Circle, (const byte*)"\x97\x06" "Circle")
QDEF(MP_QSTR_ColorConverter, (const byte*)"\xb8\x0e" "ColorConverter")
QDEF(MP_QSTR_Connection, (const byte*)"\xd3\x0a" "Connection")
QDEF(MP_QSTR_ConnectionError, (const byte*)"\x4b\x0f" "ConnectionError")
QDEF(MP_QSTR_DEBUG, (const byte*)"\x34\x05" "DEBUG")
QDEF(MP_QSTR_DEEP_SLEEP_ALARM, (const byte*)"\x0d\x10" "DEEP_SLEEP_ALARM")
QDEF(MP_QSTR_DOWN, (const byte*)"\x37\x04" "DOWN")
QDEF(MP_QSTR_Descriptor, (const byte*)"\xb6\x0a" "Descriptor")
QDEF(MP_QSTR_DigitalInOut, (const byte*)"\xf6\x0c" "DigitalInOut")
QDEF(MP_QSTR_Direction, (const byte*)"\x40\x09" "Direction")
QDEF(MP_QSTR_Display, (const byte*)"\x3f\x07" "Display")
QDEF(MP_QSTR_DriveMode, (const byte*)"\xaa\x09" "DriveMode")
QDEF(MP_QSTR_EACCES, (const byte*)"\x37\x06" "EACCES")
QDEF(MP_QSTR_EADDRINUSE, (const byte*)"\x17\x0a" "EADDRINUSE")
QDEF(MP_QSTR_EAGAIN, (const byte*)"\x20\x06" "EAGAIN")
QDEF(MP_QSTR_EALREADY, (const byte*)"\x46\x08" "EALREADY")
QDEF(MP_QSTR_EBADF, (const byte*)"\x61\x05" "EBADF")
QDEF(MP_QSTR_ECONNABORTED, (const byte*)"\x27\x0c" "ECONNABORTED")
QDEF(MP_QSTR_ECONNREFUSED, (const byte*)"\x3a\x0c" "ECONNREFUSED")
QDEF(MP_QSTR_ECONNRESET, (const byte*)"\x19\x0a" "ECONNRESET")
QDEF(MP_QSTR_EEXIST, (const byte*)"\x53\x06" "EEXIST")
QDEF(MP_QSTR_EHOSTUNREACH, (const byte*)"\x86\x0c" "EHOSTUNREACH")
QDEF(MP_QSTR_EINPROGRESS, (const byte*)"\x9a\x0b" "EINPROGRESS")
QDEF(MP_QSTR_EINVAL, (const byte*)"\x5c\x06" "EINVAL")
QDEF(MP_QSTR_EIO, (const byte*)"\x86\x03" "EIO")
QDEF(MP_QSTR_EISDIR, (const byte*)"\xa5\x06" "EISDIR")
QDEF(MP_QSTR_ENCRYPT_NO_MITM, (const byte*)"\x5e\x0f" "ENCRYPT_NO_MITM")
QDEF(MP_QSTR_ENCRYPT_WITH_MITM, (const byte*)"\x9d\x11" "ENCRYPT_WITH_MITM")
QDEF(MP_QSTR_ENOBUFS, (const byte*)"\xe3\x07" "ENOBUFS")
QDEF(MP_QSTR_ENODEV, (const byte*)"\xb6\x06" "ENODEV")
QDEF(MP_QSTR_ENOENT, (const byte*)"\x5e\x06" "ENOENT")
QDEF(MP_QSTR_ENOMEM, (const byte*)"\xa4\x06" "ENOMEM")
QDEF(MP_QSTR_ENOTCONN, (const byte*)"\x79\x08" "ENOTCONN")
QDEF(MP_QSTR_EOFError, (const byte*)"\x91\x08" "EOFError")
QDEF(MP_QSTR_EOPNOTSUPP, (const byte*)"\xac\x0a" "EOPNOTSUPP")
QDEF(MP_QSTR_EPERM, (const byte*)"\xea\x05" "EPERM")
QDEF(MP_QSTR_EPaperDisplay, (const byte*)"\x6c\x0d" "EPaperDisplay")
QDEF(MP_QSTR_ETIMEDOUT, (const byte*)"\xff\x09" "ETIMEDOUT")
QDEF(MP_QSTR_EVEN, (const byte*)"\xdd\x04" "EVEN")
QDEF(MP_QSTR_Ellipsis, (const byte*)"\xf0\x08" "Ellipsis")
QDEF(MP_QSTR_Exception, (const byte*)"\xf2\x09" "Exception")
QDEF(MP_QSTR_ExtType, (const byte*)"\x54\x07" "ExtType")
QDEF(MP_QSTR_FONT, (const byte*)"\x56\x04" "FONT")
QDEF(MP_QSTR_FileIO, (const byte*)"\xc5\x06" "FileIO")
QDEF(MP_QSTR_Flash, (const byte*)"\x95\x05" "Flash")
QDEF(MP_QSTR_FourWire, (const byte*)"\x02\x08" "FourWire")
QDEF(MP_QSTR_FramebufferDisplay, (const byte*)"\xa2\x12" "FramebufferDisplay")
QDEF(MP_QSTR_GamePad, (const byte*)"\x3e\x07" "GamePad")
QDEF(MP_QSTR_GeneratorExit, (const byte*)"\x16\x0d" "GeneratorExit")
QDEF(MP_QSTR_Glyph, (const byte*)"\x6f\x05" "Glyph")
QDEF(MP_QSTR_Group, (const byte*)"\xda\x05" "Group")
QDEF(MP_QSTR_I2C, (const byte*)"\x5d\x03" "I2C")
QDEF(MP_QSTR_I2CDevice, (const byte*)"\x45\x09" "I2CDevice")
QDEF(MP_QSTR_I2CDisplay, (const byte*)"\xe7\x0a" "I2CDisplay")
QDEF(MP_QSTR_INDICATE, (const byte*)"\x5c\x08" "INDICATE")
QDEF(MP_QSTR_INPUT, (const byte*)"\x53\x05" "INPUT")
QDEF(MP_QSTR_ImportError, (const byte*)"\x20\x0b" "ImportError")
QDEF(MP_QSTR_IndentationError, (const byte*)"\x5c\x10" "IndentationError")
QDEF(MP_QSTR_IndexError, (const byte*)"\x83\x0a" "IndexError")
QDEF(MP_QSTR_KeyError, (const byte*)"\xea\x08" "KeyError")
QDEF(MP_QSTR_KeyboardInterrupt, (const byte*)"\xaf\x11" "KeyboardInterrupt")
QDEF(MP_QSTR_LD3, (const byte*)"\xde\x03" "LD3")
QDEF(MP_QSTR_LD4, (const byte*)"\xd9\x03" "LD4")
QDEF(MP_QSTR_LD5, (const byte*)"\xd8\x03" "LD5")
QDEF(MP_QSTR_LD6, (const byte*)"\xdb\x03" "LD6")
QDEF(MP_QSTR_LED1, (const byte*)"\xb9\x04" "LED1")
QDEF(MP_QSTR_LED2, (const byte*)"\xba\x04" "LED2")
QDEF(MP_QSTR_LED3, (const byte*)"\xbb\x04" "LED3")
QDEF(MP_QSTR_LED4, (const byte*)"\xbc\x04" "LED4")
QDEF(MP_QSTR_LED_BLUE, (const byte*)"\x69\x08" "LED_BLUE")
QDEF(MP_QSTR_LED_GREEN, (const byte*)"\x4c\x09" "LED_GREEN")
QDEF(MP_QSTR_LED_ORANGE, (const byte*)"\xa7\x0a" "LED_ORANGE")
QDEF(MP_QSTR_LED_RED, (const byte*)"\x84\x07" "LED_RED")
QDEF(MP_QSTR_LESC_ENCRYPT_WITH_MITM, (const byte*)"\xbb\x16" "LESC_ENCRYPT_WITH_MITM")
QDEF(MP_QSTR_LookupError, (const byte*)"\xff\x0b" "LookupError")
QDEF(MP_QSTR_M, (const byte*)"\xe8\x01" "M")
QDEF(MP_QSTR_MISO, (const byte*)"\x9d\x04" "MISO")
QDEF(MP_QSTR_MOSI, (const byte*)"\x1d\x04" "MOSI")
QDEF(MP_QSTR_MemoryError, (const byte*)"\xdc\x0b" "MemoryError")
QDEF(MP_QSTR_MpyError, (const byte*)"\x39\x08" "MpyError")
QDEF(MP_QSTR_NORMAL, (const byte*)"\xf6\x06" "NORMAL")
QDEF(MP_QSTR_NOTIFY, (const byte*)"\x86\x06" "NOTIFY")
QDEF(MP_QSTR_NO_ACCESS, (const byte*)"\x3f\x09" "NO_ACCESS")
QDEF(MP_QSTR_NaN, (const byte*)"\x24\x03" "NaN")
QDEF(MP_QSTR_NameError, (const byte*)"\xba\x09" "NameError")
QDEF(MP_QSTR_NoneType, (const byte*)"\x17\x08" "NoneType")
QDEF(MP_QSTR_NotImplementedError, (const byte*)"\xc6\x13" "NotImplementedError")
QDEF(MP_QSTR_ODD, (const byte*)"\x6a\x03" "ODD")
QDEF(MP_QSTR_OPEN, (const byte*)"\x91\x04" "OPEN")
QDEF(MP_QSTR_OPEN_DRAIN, (const byte*)"\x5e\x0a" "OPEN_DRAIN")
QDEF(MP_QSTR_OSError, (const byte*)"\xa1\x07" "OSError")
QDEF(MP_QSTR_OUTPUT, (const byte*)"\xda\x06" "OUTPUT")
QDEF(MP_QSTR_OnDiskBitmap, (const byte*)"\x12\x0c" "OnDiskBitmap")
QDEF(MP_QSTR_OneWire, (const byte*)"\x68\x07" "OneWire")
QDEF(MP_QSTR_OrderedDict, (const byte*)"\xf0\x0b" "OrderedDict")
QDEF(MP_QSTR_OverflowError, (const byte*)"\x81\x0d" "OverflowError")
QDEF(MP_QSTR_PA00, (const byte*)"\xd4\x04" "PA00")
QDEF(MP_QSTR_PA01, (const byte*)"\xd5\x04" "PA01")
QDEF(MP_QSTR_PA02, (const byte*)"\xd6\x04" "PA02")
QDEF(MP_QSTR_PA03, (const byte*)"\xd7\x04" "PA03")
QDEF(MP_QSTR_PA04, (const byte*)"\xd0\x04" "PA04")
QDEF(MP_QSTR_PA05, (const byte*)"\xd1\x04" "PA05")
QDEF(MP_QSTR_PA06, (const byte*)"\xd2\x04" "PA06")
QDEF(MP_QSTR_PA07, (const byte*)"\xd3\x04" "PA07")
QDEF(MP_QSTR_PA08, (const byte*)"\xdc\x04" "PA08")
QDEF(MP_QSTR_PA09, (const byte*)"\xdd\x04" "PA09")
QDEF(MP_QSTR_PA10, (const byte*)"\x35\x04" "PA10")
QDEF(MP_QSTR_PA11, (const byte*)"\x34\x04" "PA11")
QDEF(MP_QSTR_PA12, (const byte*)"\x37\x04" "PA12")
QDEF(MP_QSTR_PA13, (const byte*)"\x36\x04" "PA13")
QDEF(MP_QSTR_PA14, (const byte*)"\x31\x04" "PA14")
QDEF(MP_QSTR_PA15, (const byte*)"\x30\x04" "PA15")
QDEF(MP_QSTR_PB00, (const byte*)"\x57\x04" "PB00")
QDEF(MP_QSTR_PB01, (const byte*)"\x56\x04" "PB01")
QDEF(MP_QSTR_PB02, (const byte*)"\x55\x04" "PB02")
QDEF(MP_QSTR_PB03, (const byte*)"\x54\x04" "PB03")
QDEF(MP_QSTR_PB04, (const byte*)"\x53\x04" "PB04")
QDEF(MP_QSTR_PB05, (const byte*)"\x52\x04" "PB05")
QDEF(MP_QSTR_PB06, (const byte*)"\x51\x04" "PB06")
QDEF(MP_QSTR_PB07, (const byte*)"\x50\x04" "PB07")
QDEF(MP_QSTR_PB08, (const byte*)"\x5f\x04" "PB08")
QDEF(MP_QSTR_PB09, (const byte*)"\x5e\x04" "PB09")
QDEF(MP_QSTR_PB10, (const byte*)"\x76\x04" "PB10")
QDEF(MP_QSTR_PB11, (const byte*)"\x77\x04" "PB11")
QDEF(MP_QSTR_PB12, (const byte*)"\x74\x04" "PB12")
QDEF(MP_QSTR_PB13, (const byte*)"\x75\x04" "PB13")
QDEF(MP_QSTR_PB14, (const byte*)"\x72\x04" "PB14")
QDEF(MP_QSTR_PB15, (const byte*)"\x73\x04" "PB15")
QDEF(MP_QSTR_PC00, (const byte*)"\x56\x04" "PC00")
QDEF(MP_QSTR_PC01, (const byte*)"\x57\x04" "PC01")
QDEF(MP_QSTR_PC02, (const byte*)"\x54\x04" "PC02")
QDEF(MP_QSTR_PC03, (const byte*)"\x55\x04" "PC03")
QDEF(MP_QSTR_PC04, (const byte*)"\x52\x04" "PC04")
QDEF(MP_QSTR_PC05, (const byte*)"\x53\x04" "PC05")
QDEF(MP_QSTR_PC06, (const byte*)"\x50\x04" "PC06")
QDEF(MP_QSTR_PC07, (const byte*)"\x51\x04" "PC07")
QDEF(MP_QSTR_PC08, (const byte*)"\x5e\x04" "PC08")
QDEF(MP_QSTR_PC09, (const byte*)"\x5f\x04" "PC09")
QDEF(MP_QSTR_PC10, (const byte*)"\xb7\x04" "PC10")
QDEF(MP_QSTR_PC11, (const byte*)"\xb6\x04" "PC11")
QDEF(MP_QSTR_PC12, (const byte*)"\xb5\x04" "PC12")
QDEF(MP_QSTR_PC13, (const byte*)"\xb4\x04" "PC13")
QDEF(MP_QSTR_PC14, (const byte*)"\xb3\x04" "PC14")
QDEF(MP_QSTR_PC15, (const byte*)"\xb2\x04" "PC15")
QDEF(MP_QSTR_PD00, (const byte*)"\xd1\x04" "PD00")
QDEF(MP_QSTR_PD01, (const byte*)"\xd0\x04" "PD01")
QDEF(MP_QSTR_PD02, (const byte*)"\xd3\x04" "PD02")
QDEF(MP_QSTR_PD03, (const byte*)"\xd2\x04" "PD03")
QDEF(MP_QSTR_PD04, (const byte*)"\xd5\x04" "PD04")
QDEF(MP_QSTR_PD05, (const byte*)"\xd4\x04" "PD05")
QDEF(MP_QSTR_PD06, (const byte*)"\xd7\x04" "PD06")
QDEF(MP_QSTR_PD07, (const byte*)"\xd6\x04" "PD07")
QDEF(MP_QSTR_PD08, (const byte*)"\xd9\x04" "PD08")
QDEF(MP_QSTR_PD09, (const byte*)"\xd8\x04" "PD09")
QDEF(MP_QSTR_PD10, (const byte*)"\xf0\x04" "PD10")
QDEF(MP_QSTR_PD11, (const byte*)"\xf1\x04" "PD11")
QDEF(MP_QSTR_PD12, (const byte*)"\xf2\x04" "PD12")
QDEF(MP_QSTR_PD13, (const byte*)"\xf3\x04" "PD13")
QDEF(MP_QSTR_PD14, (const byte*)"\xf4\x04" "PD14")
QDEF(MP_QSTR_PD15, (const byte*)"\xf5\x04" "PD15")
QDEF(MP_QSTR_PE00, (const byte*)"\xd0\x04" "PE00")
QDEF(MP_QSTR_PE01, (const byte*)"\xd1\x04" "PE01")
QDEF(MP_QSTR_PE02, (const byte*)"\xd2\x04" "PE02")
QDEF(MP_QSTR_PE03, (const byte*)"\xd3\x04" "PE03")
QDEF(MP_QSTR_PE04, (const byte*)"\xd4\x04" "PE04")
QDEF(MP_QSTR_PE05, (const byte*)"\xd5\x04" "PE05")
QDEF(MP_QSTR_PE06, (const byte*)"\xd6\x04" "PE06")
QDEF(MP_QSTR_PE07, (const byte*)"\xd7\x04" "PE07")
QDEF(MP_QSTR_PE08, (const byte*)"\xd8\x04" "PE08")
QDEF(MP_QSTR_PE09, (const byte*)"\xd9\x04" "PE09")
QDEF(MP_QSTR_PE10, (const byte*)"\x31\x04" "PE10")
QDEF(MP_QSTR_PE11, (const byte*)"\x30\x04" "PE11")
QDEF(MP_QSTR_PE12, (const byte*)"\x33\x04" "PE12")
QDEF(MP_QSTR_PE13, (const byte*)"\x32\x04" "PE13")
QDEF(MP_QSTR_PE14, (const byte*)"\x35\x04" "PE14")
QDEF(MP_QSTR_PE15, (const byte*)"\x34\x04" "PE15")
QDEF(MP_QSTR_POWER_ON, (const byte*)"\xc4\x08" "POWER_ON")
QDEF(MP_QSTR_PUBLIC, (const byte*)"\xa4\x06" "PUBLIC")
QDEF(MP_QSTR_PUSH_PULL, (const byte*)"\x81\x09" "PUSH_PULL")
QDEF(MP_QSTR_PWMOut, (const byte*)"\xc1\x06" "PWMOut")
QDEF(MP_QSTR_PacketBuffer, (const byte*)"\xed\x0c" "PacketBuffer")
QDEF(MP_QSTR_Palette, (const byte*)"\xf8\x07" "Palette")
QDEF(MP_QSTR_ParallelBus, (const byte*)"\x2a\x0b" "ParallelBus")
QDEF(MP_QSTR_Parity, (const byte*)"\x22\x06" "Parity")
QDEF(MP_QSTR_Pin, (const byte*)"\x12\x03" "Pin")
QDEF(MP_QSTR_PixelBuf, (const byte*)"\xfc\x08" "PixelBuf")
QDEF(MP_QSTR_Polygon, (const byte*)"\x49\x07" "Polygon")
QDEF(MP_QSTR_Processor, (const byte*)"\x13\x09" "Processor")
QDEF(MP_QSTR_Pull, (const byte*)"\x60\x04" "Pull")
QDEF(MP_QSTR_PulseIn, (const byte*)"\xfd\x07" "PulseIn")
QDEF(MP_QSTR_PulseOut, (const byte*)"\xd4\x08" "PulseOut")
QDEF(MP_QSTR_RANDOM_PRIVATE_NON_RESOLVABLE, (const byte*)"\xd8\x1d" "RANDOM_PRIVATE_NON_RESOLVABLE")
QDEF(MP_QSTR_RANDOM_PRIVATE_RESOLVABLE, (const byte*)"\x88\x19" "RANDOM_PRIVATE_RESOLVABLE")
QDEF(MP_QSTR_RANDOM_STATIC, (const byte*)"\x59\x0d" "RANDOM_STATIC")
QDEF(MP_QSTR_READ, (const byte*)"\xb7\x04" "READ")
QDEF(MP_QSTR_REPL_RELOAD, (const byte*)"\x20\x0b" "REPL_RELOAD")
QDEF(MP_QSTR_RESET_PIN, (const byte*)"\x38\x09" "RESET_PIN")
QDEF(MP_QSTR_Rectangle, (const byte*)"\xc4\x09" "Rectangle")
QDEF(MP_QSTR_ReloadException, (const byte*)"\x03\x0f" "ReloadException")
QDEF(MP_QSTR_ResetReason, (const byte*)"\x54\x0b" "ResetReason")
QDEF(MP_QSTR_RoleError, (const byte*)"\xe9\x09" "RoleError")
QDEF(MP_QSTR_RunMode, (const byte*)"\x8f\x07" "RunMode")
QDEF(MP_QSTR_RunReason, (const byte*)"\xe8\x09" "RunReason")
QDEF(MP_QSTR_Runtime, (const byte*)"\xb9\x07" "Runtime")
QDEF(MP_QSTR_RuntimeError, (const byte*)"\x61\x0c" "RuntimeError")
QDEF(MP_QSTR_SAFE_MODE, (const byte*)"\x08\x09" "SAFE_MODE")
QDEF(MP_QSTR_SDCard, (const byte*)"\xa6\x06" "SDCard")
QDEF(MP_QSTR_SH1107_addressing, (const byte*)"\x50\x11" "SH1107_addressing")
QDEF(MP_QSTR_SIGNED_NO_MITM, (const byte*)"\xcb\x0e" "SIGNED_NO_MITM")
QDEF(MP_QSTR_SIGNED_WITH_MITM, (const byte*)"\x48\x10" "SIGNED_WITH_MITM")
QDEF(MP_QSTR_SOFTWARE, (const byte*)"\xca\x08" "SOFTWARE")
QDEF(MP_QSTR_SPI, (const byte*)"\xef\x03" "SPI")
QDEF(MP_QSTR_SPIDevice, (const byte*)"\x37\x09" "SPIDevice")
QDEF(MP_QSTR_STARTUP, (const byte*)"\x80\x07" "STARTUP")
QDEF(MP_QSTR_SUPERVISOR_RELOAD, (const byte*)"\xfb\x11" "SUPERVISOR_RELOAD")
QDEF(MP_QSTR_ScanEntry, (const byte*)"\xee\x09" "ScanEntry")
QDEF(MP_QSTR_ScanResults, (const byte*)"\xa0\x0b" "ScanResults")
QDEF(MP_QSTR_SecurityError, (const byte*)"\x6b\x0d" "SecurityError")
QDEF(MP_QSTR_Service, (const byte*)"\xb8\x07" "Service")
QDEF(MP_QSTR_Shape, (const byte*)"\xea\x05" "Shape")
QDEF(MP_QSTR_SharpMemoryFramebuffer, (const byte*)"\xc1\x16" "SharpMemoryFramebuffer")
QDEF(MP_QSTR_StopAsyncIteration, (const byte*)"\xec\x12" "StopAsyncIteration")
QDEF(MP_QSTR_StopIteration, (const byte*)"\xea\x0d" "StopIteration")
QDEF(MP_QSTR_StringIO, (const byte*)"\x76\x08" "StringIO")
QDEF(MP_QSTR_SyntaxError, (const byte*)"\x94\x0b" "SyntaxError")
QDEF(MP_QSTR_SystemExit, (const byte*)"\x20\x0a" "SystemExit")
QDEF(MP_QSTR_Terminal, (const byte*)"\x21\x08" "Terminal")
QDEF(MP_QSTR_TextIOWrapper, (const byte*)"\xad\x0d" "TextIOWrapper")
QDEF(MP_QSTR_TileGrid, (const byte*)"\x49\x08" "TileGrid")
QDEF(MP_QSTR_TimeoutError, (const byte*)"\x66\x0c" "TimeoutError")
QDEF(MP_QSTR_TouchIn, (const byte*)"\x67\x07" "TouchIn")
QDEF(MP_QSTR_TypeError, (const byte*)"\x25\x09" "TypeError")
QDEF(MP_QSTR_UART, (const byte*)"\xb7\x04" "UART")
QDEF(MP_QSTR_ULAB, (const byte*)"\x5f\x04" "ULAB")
QDEF(MP_QSTR_UNKNOWN, (const byte*)"\x8d\x07" "UNKNOWN")
QDEF(MP_QSTR_UP, (const byte*)"\xa0\x02" "UP")
QDEF(MP_QSTR_UUID, (const byte*)"\xc8\x04" "UUID")
QDEF(MP_QSTR_UnicodeError, (const byte*)"\x22\x0c" "UnicodeError")
QDEF(MP_QSTR_ValueError, (const byte*)"\x96\x0a" "ValueError")
QDEF(MP_QSTR_VectorShape, (const byte*)"\x73\x0b" "VectorShape")
QDEF(MP_QSTR_VfsFat, (const byte*)"\x15\x06" "VfsFat")
QDEF(MP_QSTR_WATCHDOG, (const byte*)"\x01\x08" "WATCHDOG")
QDEF(MP_QSTR_WRITE, (const byte*)"\xf8\x05" "WRITE")
QDEF(MP_QSTR_WRITE_NO_RESPONSE, (const byte*)"\xda\x11" "WRITE_NO_RESPONSE")
QDEF(MP_QSTR_ZeroDivisionError, (const byte*)"\xb6\x11" "ZeroDivisionError")
QDEF(MP_QSTR__bleio, (const byte*)"\xf7\x06" "_bleio")
QDEF(MP_QSTR__os, (const byte*)"\x86\x03" "_os")
QDEF(MP_QSTR__pixelbuf, (const byte*)"\xc3\x09" "_pixelbuf")
QDEF(MP_QSTR__time, (const byte*)"\x0f\x05" "_time")
QDEF(MP_QSTR__transmit, (const byte*)"\xd0\x09" "_transmit")
QDEF(MP_QSTR_a, (const byte*)"\xc4\x01" "a")
QDEF(MP_QSTR_a2b_base64, (const byte*)"\x3c\x0a" "a2b_base64")
QDEF(MP_QSTR_abs, (const byte*)"\x95\x03" "abs")
QDEF(MP_QSTR_acos, (const byte*)"\x1b\x04" "acos")
QDEF(MP_QSTR_acosh, (const byte*)"\x13\x05" "acosh")
QDEF(MP_QSTR_active, (const byte*)"\x69\x06" "active")
QDEF(MP_QSTR_adafruit_bus_device, (const byte*)"\xa1\x13" "adafruit_bus_device")
QDEF(MP_QSTR_adapter, (const byte*)"\xf2\x07" "adapter")
QDEF(MP_QSTR_add, (const byte*)"\x44\x03" "add")
QDEF(MP_QSTR_add_to_characteristic, (const byte*)"\x22\x15" "add_to_characteristic")
QDEF(MP_QSTR_add_to_service, (const byte*)"\x02\x0e" "add_to_service")
QDEF(MP_QSTR_address, (const byte*)"\x73\x07" "address")
QDEF(MP_QSTR_address_bytes, (const byte*)"\xf5\x0d" "address_bytes")
QDEF(MP_QSTR_address_type, (const byte*)"\x14\x0c" "address_type")
QDEF(MP_QSTR_advertisement_bytes, (const byte*)"\x7e\x13" "advertisement_bytes")
QDEF(MP_QSTR_advertising, (const byte*)"\x8f\x0b" "advertising")
QDEF(MP_QSTR_all, (const byte*)"\x44\x03" "all")
QDEF(MP_QSTR_always_toggle_chip_select, (const byte*)"\xe3\x19" "always_toggle_chip_select")
QDEF(MP_QSTR_analogio, (const byte*)"\x09\x08" "analogio")
QDEF(MP_QSTR_angle, (const byte*)"\x84\x05" "angle")
QDEF(MP_QSTR_anonymous, (const byte*)"\x16\x09" "anonymous")
QDEF(MP_QSTR_any, (const byte*)"\x13\x03" "any")
QDEF(MP_QSTR_append, (const byte*)"\x6b\x06" "append")
QDEF(MP_QSTR_approx, (const byte*)"\xc1\x06" "approx")
QDEF(MP_QSTR_arange, (const byte*)"\x7b\x06" "arange")
QDEF(MP_QSTR_arctan2, (const byte*)"\x1c\x07" "arctan2")
QDEF(MP_QSTR_argmax, (const byte*)"\xa5\x06" "argmax")
QDEF(MP_QSTR_argmin, (const byte*)"\xbb\x06" "argmin")
QDEF(MP_QSTR_args, (const byte*)"\xc2\x04" "args")
QDEF(MP_QSTR_argsort, (const byte*)"\x2b\x07" "argsort")
QDEF(MP_QSTR_argv, (const byte*)"\xc7\x04" "argv")
QDEF(MP_QSTR_around, (const byte*)"\x06\x06" "around")
QDEF(MP_QSTR_array, (const byte*)"\x7c\x05" "array")
QDEF(MP_QSTR_asin, (const byte*)"\x50\x04" "asin")
QDEF(MP_QSTR_asinh, (const byte*)"\x38\x05" "asinh")
QDEF(MP_QSTR_atan, (const byte*)"\x1f\x04" "atan")
QDEF(MP_QSTR_atan2, (const byte*)"\xcd\x05" "atan2")
QDEF(MP_QSTR_atanh, (const byte*)"\x97\x05" "atanh")
QDEF(MP_QSTR_auto_brightness, (const byte*)"\xfc\x0f" "auto_brightness")
QDEF(MP_QSTR_auto_refresh, (const byte*)"\xe8\x0c" "auto_refresh")
QDEF(MP_QSTR_auto_write, (const byte*)"\xe8\x0a" "auto_write")
QDEF(MP_QSTR_axis, (const byte*)"\x06\x04" "axis")
QDEF(MP_QSTR_b2a_base64, (const byte*)"\x3c\x0a" "b2a_base64")
QDEF(MP_QSTR_backlight_on_high, (const byte*)"\xff\x11" "backlight_on_high")
QDEF(MP_QSTR_backlight_pin, (const byte*)"\xd8\x0d" "backlight_pin")
QDEF(MP_QSTR_base, (const byte*)"\xf0\x04" "base")
QDEF(MP_QSTR_baudrate, (const byte*)"\xf5\x08" "baudrate")
QDEF(MP_QSTR_bin, (const byte*)"\xe0\x03" "bin")
QDEF(MP_QSTR_binascii, (const byte*)"\x91\x08" "binascii")
QDEF(MP_QSTR_bisect, (const byte*)"\x8f\x06" "bisect")
QDEF(MP_QSTR_bit_length, (const byte*)"\xb9\x0a" "bit_length")
QDEF(MP_QSTR_bitbangio, (const byte*)"\x56\x09" "bitbangio")
QDEF(MP_QSTR_bitmap, (const byte*)"\x66\x06" "bitmap")
QDEF(MP_QSTR_bitmaptools, (const byte*)"\x6d\x0b" "bitmaptools")
QDEF(MP_QSTR_bits, (const byte*)"\x49\x04" "bits")
QDEF(MP_QSTR_black_bits_inverted, (const byte*)"\xdd\x13" "black_bits_inverted")
QDEF(MP_QSTR_blit, (const byte*)"\xf6\x04" "blit")
QDEF(MP_QSTR_board, (const byte*)"\x7f\x05" "board")
QDEF(MP_QSTR_bond, (const byte*)"\x02\x04" "bond")
QDEF(MP_QSTR_bool, (const byte*)"\xeb\x04" "bool")
QDEF(MP_QSTR_bound_method, (const byte*)"\x97\x0c" "bound_method")
QDEF(MP_QSTR_bpp, (const byte*)"\xc7\x03" "bpp")
QDEF(MP_QSTR_brightness, (const byte*)"\x4c\x0a" "brightness")
QDEF(MP_QSTR_brightness_command, (const byte*)"\xd4\x12" "brightness_command")
QDEF(MP_QSTR_buffer, (const byte*)"\xe5\x06" "buffer")
QDEF(MP_QSTR_buffer_in, (const byte*)"\xbd\x09" "buffer_in")
QDEF(MP_QSTR_buffer_out, (const byte*)"\x14\x0a" "buffer_out")
QDEF(MP_QSTR_buffer_size, (const byte*)"\xbf\x0b" "buffer_size")
QDEF(MP_QSTR_buffering, (const byte*)"\x25\x09" "buffering")
QDEF(MP_QSTR_builtins, (const byte*)"\xf7\x08" "builtins")
QDEF(MP_QSTR_bus, (const byte*)"\x61\x03" "bus")
QDEF(MP_QSTR_busio, (const byte*)"\x87\x05" "busio")
QDEF(MP_QSTR_busy, (const byte*)"\xf8\x04" "busy")
QDEF(MP_QSTR_busy_pin, (const byte*)"\x10\x08" "busy_pin")
QDEF(MP_QSTR_busy_state, (const byte*)"\xf0\x0a" "busy_state")
QDEF(MP_QSTR_bytearray, (const byte*)"\x76\x09" "bytearray")
QDEF(MP_QSTR_bytecode, (const byte*)"\x22\x08" "bytecode")
QDEF(MP_QSTR_byteorder, (const byte*)"\x61\x09" "byteorder")
QDEF(MP_QSTR_bytes, (const byte*)"\x5c\x05" "bytes")
QDEF(MP_QSTR_bytes_per_cell, (const byte*)"\xdd\x0e" "bytes_per_cell")
QDEF(MP_QSTR_calcsize, (const byte*)"\x4d\x08" "calcsize")
QDEF(MP_QSTR_callable, (const byte*)"\x0d\x08" "callable")
QDEF(MP_QSTR_cast, (const byte*)"\x40\x04" "cast")
QDEF(MP_QSTR_ceil, (const byte*)"\x06\x04" "ceil")
QDEF(MP_QSTR_center, (const byte*)"\x4e\x06" "center")
QDEF(MP_QSTR_characteristic, (const byte*)"\x78\x0e" "characteristic")
QDEF(MP_QSTR_characteristics, (const byte*)"\x0b\x0f" "characteristics")
QDEF(MP_QSTR_chdir, (const byte*)"\xb1\x05" "chdir")
QDEF(MP_QSTR_chip_select, (const byte*)"\x60\x0b" "chip_select")
QDEF(MP_QSTR_choice, (const byte*)"\x2e\x06" "choice")
QDEF(MP_QSTR_cholesky, (const byte*)"\x89\x08" "cholesky")
QDEF(MP_QSTR_chr, (const byte*)"\xdc\x03" "chr")
QDEF(MP_QSTR_circuitpython, (const byte*)"\x02\x0d" "circuitpython")
QDEF(MP_QSTR_classmethod, (const byte*)"\xb4\x0b" "classmethod")
QDEF(MP_QSTR_clear, (const byte*)"\x7c\x05" "clear")
QDEF(MP_QSTR_clip, (const byte*)"\xd3\x04" "clip")
QDEF(MP_QSTR_clock, (const byte*)"\x2d\x05" "clock")
QDEF(MP_QSTR_close, (const byte*)"\x33\x05" "close")
QDEF(MP_QSTR_closure, (const byte*)"\x74\x07" "closure")
QDEF(MP_QSTR_code, (const byte*)"\x68\x04" "code")
QDEF(MP_QSTR_codepoint, (const byte*)"\xe4\x09" "codepoint")
QDEF(MP_QSTR_collect, (const byte*)"\x9b\x07" "collect")
QDEF(MP_QSTR_collections, (const byte*)"\xe0\x0b" "collections")
QDEF(MP_QSTR_color_bits_inverted, (const byte*)"\xa7\x13" "color_bits_inverted")
QDEF(MP_QSTR_color_count, (const byte*)"\xe4\x0b" "color_count")
QDEF(MP_QSTR_color_depth, (const byte*)"\x2a\x0b" "color_depth")
QDEF(MP_QSTR_colorwheel, (const byte*)"\x0b\x0a" "colorwheel")
QDEF(MP_QSTR_colstart, (const byte*)"\x25\x08" "colstart")
QDEF(MP_QSTR_command, (const byte*)"\x02\x07" "command")
QDEF(MP_QSTR_compare, (const byte*)"\x22\x07" "compare")
QDEF(MP_QSTR_compile, (const byte*)"\xf4\x07" "compile")
QDEF(MP_QSTR_complex, (const byte*)"\xc5\x07" "complex")
QDEF(MP_QSTR_concatenate, (const byte*)"\x0a\x0b" "concatenate")
QDEF(MP_QSTR_configure, (const byte*)"\x8d\x09" "configure")
QDEF(MP_QSTR_connect, (const byte*)"\xdb\x07" "connect")
QDEF(MP_QSTR_connectable, (const byte*)"\x71\x0b" "connectable")
QDEF(MP_QSTR_connected, (const byte*)"\x7a\x09" "connected")
QDEF(MP_QSTR_connection_interval, (const byte*)"\x93\x13" "connection_interval")
QDEF(MP_QSTR_connections, (const byte*)"\x20\x0b" "connections")
QDEF(MP_QSTR_const, (const byte*)"\xc0\x05" "const")
QDEF(MP_QSTR_convert, (const byte*)"\xf2\x07" "convert")
QDEF(MP_QSTR_convolve, (const byte*)"\x41\x08" "convolve")
QDEF(MP_QSTR_copy, (const byte*)"\xe0\x04" "copy")
QDEF(MP_QSTR_copysign, (const byte*)"\x33\x08" "copysign")
QDEF(MP_QSTR_cos, (const byte*)"\x7a\x03" "cos")
QDEF(MP_QSTR_cosh, (const byte*)"\xd2\x04" "cosh")
QDEF(MP_QSTR_count, (const byte*)"\xa6\x05" "count")
QDEF(MP_QSTR_cpu, (const byte*)"\xc3\x03" "cpu")
QDEF(MP_QSTR_cross, (const byte*)"\x7b\x05" "cross")
QDEF(MP_QSTR_cs, (const byte*)"\xf5\x02" "cs")
QDEF(MP_QSTR_cts, (const byte*)"\x41\x03" "cts")
QDEF(MP_QSTR_data, (const byte*)"\x15\x04" "data")
QDEF(MP_QSTR_data0, (const byte*)"\x85\x05" "data0")
QDEF(MP_QSTR_data_as_commands, (const byte*)"\x33\x10" "data_as_commands")
QDEF(MP_QSTR_ddof, (const byte*)"\xec\x04" "ddof")
QDEF(MP_QSTR_decimals, (const byte*)"\x1d\x08" "decimals")
QDEF(MP_QSTR_decode, (const byte*)"\xa9\x06" "decode")
QDEF(MP_QSTR_default, (const byte*)"\xce\x07" "default")
QDEF(MP_QSTR_default_tile, (const byte*)"\xc5\x0c" "default_tile")
QDEF(MP_QSTR_degrees, (const byte*)"\x02\x07" "degrees")
QDEF(MP_QSTR_deinit, (const byte*)"\x9e\x06" "deinit")
QDEF(MP_QSTR_delattr, (const byte*)"\xdb\x07" "delattr")
QDEF(MP_QSTR_delay_us, (const byte*)"\xa9\x08" "delay_us")
QDEF(MP_QSTR_deleter, (const byte*)"\x6e\x07" "deleter")
QDEF(MP_QSTR_dest_bitmap, (const byte*)"\xff\x0b" "dest_bitmap")
QDEF(MP_QSTR_dest_clip0, (const byte*)"\xfa\x0a" "dest_clip0")
QDEF(MP_QSTR_dest_clip1, (const byte*)"\xfb\x0a" "dest_clip1")
QDEF(MP_QSTR_det, (const byte*)"\x70\x03" "det")
QDEF(MP_QSTR_device_address, (const byte*)"\x14\x0e" "device_address")
QDEF(MP_QSTR_diag, (const byte*)"\x6e\x04" "diag")
QDEF(MP_QSTR_dict, (const byte*)"\x3f\x04" "dict")
QDEF(MP_QSTR_dict_view, (const byte*)"\x2d\x09" "dict_view")
QDEF(MP_QSTR_diff, (const byte*)"\xc8\x04" "diff")
QDEF(MP_QSTR_difference, (const byte*)"\x72\x0a" "difference")
QDEF(MP_QSTR_difference_update, (const byte*)"\x9c\x11" "difference_update")
QDEF(MP_QSTR_digitalio, (const byte*)"\x19\x09" "digitalio")
QDEF(MP_QSTR_dir, (const byte*)"\xfa\x03" "dir")
QDEF(MP_QSTR_direction, (const byte*)"\x20\x09" "direction")
QDEF(MP_QSTR_disable, (const byte*)"\x91\x07" "disable")
QDEF(MP_QSTR_disable_autoreload, (const byte*)"\xb0\x12" "disable_autoreload")
QDEF(MP_QSTR_disable_concurrent_write_protection, (const byte*)"\x3b\x23" "disable_concurrent_write_protection")
QDEF(MP_QSTR_disable_interrupts, (const byte*)"\xfa\x12" "disable_interrupts")
QDEF(MP_QSTR_discard, (const byte*)"\x0f\x07" "discard")
QDEF(MP_QSTR_disconnect, (const byte*)"\xa5\x0a" "disconnect")
QDEF(MP_QSTR_discover_remote_services, (const byte*)"\x9c\x18" "discover_remote_services")
QDEF(MP_QSTR_display_bus, (const byte*)"\x24\x0b" "display_bus")
QDEF(MP_QSTR_displayio, (const byte*)"\x39\x09" "displayio")
QDEF(MP_QSTR_dither, (const byte*)"\x63\x06" "dither")
QDEF(MP_QSTR_divmod, (const byte*)"\xb8\x06" "divmod")
QDEF(MP_QSTR_doc, (const byte*)"\x2d\x03" "doc")
QDEF(MP_QSTR_dot, (const byte*)"\x3a\x03" "dot")
QDEF(MP_QSTR_drive_mode, (const byte*)"\x15\x0a" "drive_mode")
QDEF(MP_QSTR_dtype, (const byte*)"\x59\x05" "dtype")
QDEF(MP_QSTR_dump, (const byte*)"\xe9\x04" "dump")
QDEF(MP_QSTR_dumps, (const byte*)"\x7a\x05" "dumps")
QDEF(MP_QSTR_duty_cycle, (const byte*)"\xf6\x0a" "duty_cycle")
QDEF(MP_QSTR_dx, (const byte*)"\x99\x02" "dx")
QDEF(MP_QSTR_dy, (const byte*)"\x98\x02" "dy")
QDEF(MP_QSTR_e, (const byte*)"\xc0\x01" "e")
QDEF(MP_QSTR_edgeitems, (const byte*)"\xc0\x09" "edgeitems")
QDEF(MP_QSTR_eig, (const byte*)"\xae\x03" "eig")
QDEF(MP_QSTR_enable, (const byte*)"\x04\x06" "enable")
QDEF(MP_QSTR_enable_autoreload, (const byte*)"\x85\x11" "enable_autoreload")
QDEF(MP_QSTR_enable_interrupts, (const byte*)"\x4f\x11" "enable_interrupts")
QDEF(MP_QSTR_enabled, (const byte*)"\xe0\x07" "enabled")
QDEF(MP_QSTR_encode, (const byte*)"\x43\x06" "encode")
QDEF(MP_QSTR_encoding, (const byte*)"\x06\x08" "encoding")
QDEF(MP_QSTR_end, (const byte*)"\x0a\x03" "end")
QDEF(MP_QSTR_endpoint, (const byte*)"\x06\x08" "endpoint")
QDEF(MP_QSTR_endswith, (const byte*)"\x1b\x08" "endswith")
QDEF(MP_QSTR_enumerate, (const byte*)"\x71\x09" "enumerate")
QDEF(MP_QSTR_equal, (const byte*)"\x89\x05" "equal")
QDEF(MP_QSTR_erase_bonding, (const byte*)"\x5d\x0d" "erase_bonding")
QDEF(MP_QSTR_erase_filesystem, (const byte*)"\x79\x10" "erase_filesystem")
QDEF(MP_QSTR_erf, (const byte*)"\x94\x03" "erf")
QDEF(MP_QSTR_erfc, (const byte*)"\x77\x04" "erfc")
QDEF(MP_QSTR_errno, (const byte*)"\xc1\x05" "errno")
QDEF(MP_QSTR_errorcode, (const byte*)"\x10\x09" "errorcode")
QDEF(MP_QSTR_eval, (const byte*)"\x9b\x04" "eval")
QDEF(MP_QSTR_exec, (const byte*)"\x1e\x04" "exec")
QDEF(MP_QSTR_exit, (const byte*)"\x85\x04" "exit")
QDEF(MP_QSTR_exp, (const byte*)"\xc8\x03" "exp")
QDEF(MP_QSTR_expm1, (const byte*)"\x74\x05" "expm1")
QDEF(MP_QSTR_ext_hook, (const byte*)"\x30\x08" "ext_hook")
QDEF(MP_QSTR_extend, (const byte*)"\x63\x06" "extend")
QDEF(MP_QSTR_extended, (const byte*)"\x02\x08" "extended")
QDEF(MP_QSTR_extra_clocks, (const byte*)"\x1b\x0c" "extra_clocks")
QDEF(MP_QSTR_eye, (const byte*)"\xbc\x03" "eye")
QDEF(MP_QSTR_fabs, (const byte*)"\x93\x04" "fabs")
QDEF(MP_QSTR_fatol, (const byte*)"\x95\x05" "fatol")
QDEF(MP_QSTR_fft, (const byte*)"\x91\x03" "fft")
QDEF(MP_QSTR_file, (const byte*)"\xc3\x04" "file")
QDEF(MP_QSTR_filename, (const byte*)"\xe4\x08" "filename")
QDEF(MP_QSTR_filename2, (const byte*)"\x56\x09" "filename2")
QDEF(MP_QSTR_fill, (const byte*)"\xca\x04" "fill")
QDEF(MP_QSTR_fill_row, (const byte*)"\x7f\x08" "fill_row")
QDEF(MP_QSTR_filter, (const byte*)"\x25\x06" "filter")
QDEF(MP_QSTR_find, (const byte*)"\x01\x04" "find")
QDEF(MP_QSTR_fixed_length, (const byte*)"\x30\x0c" "fixed_length")
QDEF(MP_QSTR_flatten, (const byte*)"\x25\x07" "flatten")
QDEF(MP_QSTR_flip, (const byte*)"\x76\x04" "flip")
QDEF(MP_QSTR_flip_x, (const byte*)"\xf1\x06" "flip_x")
QDEF(MP_QSTR_flip_y, (const byte*)"\xf0\x06" "flip_y")
QDEF(MP_QSTR_float, (const byte*)"\x35\x05" "float")
QDEF(MP_QSTR_floor, (const byte*)"\x7d\x05" "floor")
QDEF(MP_QSTR_flush, (const byte*)"\x61\x05" "flush")
QDEF(MP_QSTR_fmin, (const byte*)"\x29\x04" "fmin")
QDEF(MP_QSTR_fmod, (const byte*)"\xe5\x04" "fmod")
QDEF(MP_QSTR_font, (const byte*)"\x96\x04" "font")
QDEF(MP_QSTR_fontio, (const byte*)"\x70\x06" "fontio")
QDEF(MP_QSTR_format, (const byte*)"\x26\x06" "format")
QDEF(MP_QSTR_framebuffer, (const byte*)"\x98\x0b" "framebuffer")
QDEF(MP_QSTR_framebufferio, (const byte*)"\x7e\x0d" "framebufferio")
QDEF(MP_QSTR_frequency, (const byte*)"\xa1\x09" "frequency")
QDEF(MP_QSTR_frexp, (const byte*)"\x1c\x05" "frexp")
QDEF(MP_QSTR_from_bytes, (const byte*)"\x35\x0a" "from_bytes")
QDEF(MP_QSTR_frombuffer, (const byte*)"\x93\x0a" "frombuffer")
QDEF(MP_QSTR_fromkeys, (const byte*)"\x37\x08" "fromkeys")
QDEF(MP_QSTR_frozenset, (const byte*)"\xed\x09" "frozenset")
QDEF(MP_QSTR_full, (const byte*)"\xd6\x04" "full")
QDEF(MP_QSTR_function, (const byte*)"\x27\x08" "function")
QDEF(MP_QSTR_gamepad, (const byte*)"\x3e\x07" "gamepad")
QDEF(MP_QSTR_gamma, (const byte*)"\x02\x05" "gamma")
QDEF(MP_QSTR_gc, (const byte*)"\x61\x02" "gc")
QDEF(MP_QSTR_generator, (const byte*)"\x96\x09" "generator")
QDEF(MP_QSTR_get, (const byte*)"\x33\x03" "get")
QDEF(MP_QSTR_get_bounding_box, (const byte*)"\xd4\x10" "get_bounding_box")
QDEF(MP_QSTR_get_glyph, (const byte*)"\xa6\x09" "get_glyph")
QDEF(MP_QSTR_get_pressed, (const byte*)"\xea\x0b" "get_pressed")
QDEF(MP_QSTR_get_printoptions, (const byte*)"\x4d\x10" "get_printoptions")
QDEF(MP_QSTR_getattr, (const byte*)"\xc0\x07" "getattr")
QDEF(MP_QSTR_getcwd, (const byte*)"\x03\x06" "getcwd")
QDEF(MP_QSTR_getmount, (const byte*)"\xde\x08" "getmount")
QDEF(MP_QSTR_getrandbits, (const byte*)"\x66\x0b" "getrandbits")
QDEF(MP_QSTR_getter, (const byte*)"\x90\x06" "getter")
QDEF(MP_QSTR_getvalue, (const byte*)"\x78\x08" "getvalue")
QDEF(MP_QSTR_globals, (const byte*)"\x9d\x07" "globals")
QDEF(MP_QSTR_grayscale, (const byte*)"\x10\x09" "grayscale")
QDEF(MP_QSTR_group, (const byte*)"\xba\x05" "group")
QDEF(MP_QSTR_groups, (const byte*)"\x89\x06" "groups")
QDEF(MP_QSTR_hasattr, (const byte*)"\x8c\x07" "hasattr")
QDEF(MP_QSTR_hash, (const byte*)"\xb7\x04" "hash")
QDEF(MP_QSTR_header, (const byte*)"\x9a\x06" "header")
QDEF(MP_QSTR_heap_lock, (const byte*)"\xad\x09" "heap_lock")
QDEF(MP_QSTR_heap_unlock, (const byte*)"\x56\x0b" "heap_unlock")
QDEF(MP_QSTR_height, (const byte*)"\xfa\x06" "height")
QDEF(MP_QSTR_help, (const byte*)"\x94\x04" "help")
QDEF(MP_QSTR_hex, (const byte*)"\x70\x03" "hex")
QDEF(MP_QSTR_hexlify, (const byte*)"\x2a\x07" "hexlify")
QDEF(MP_QSTR_hidden, (const byte*)"\xef\x06" "hidden")
QDEF(MP_QSTR_highlight_color, (const byte*)"\x57\x0f" "highlight_color")
QDEF(MP_QSTR_i, (const byte*)"\xcc\x01" "i")
QDEF(MP_QSTR_i2c, (const byte*)"\x5d\x03" "i2c")
QDEF(MP_QSTR_i2c_bus, (const byte*)"\xe6\x07" "i2c_bus")
QDEF(MP_QSTR_i2c_device, (const byte*)"\x9a\x0a" "i2c_device")
QDEF(MP_QSTR_id, (const byte*)"\x28\x02" "id")
QDEF(MP_QSTR_idle_state, (const byte*)"\x29\x0a" "idle_state")
QDEF(MP_QSTR_ifft, (const byte*)"\xf8\x04" "ifft")
QDEF(MP_QSTR_ilistdir, (const byte*)"\x71\x08" "ilistdir")
QDEF(MP_QSTR_imag, (const byte*)"\x47\x04" "imag")
QDEF(MP_QSTR_implementation, (const byte*)"\x17\x0e" "implementation")
QDEF(MP_QSTR_in_buffer, (const byte*)"\x1d\x09" "in_buffer")
QDEF(MP_QSTR_in_end, (const byte*)"\xf2\x06" "in_end")
QDEF(MP_QSTR_in_start, (const byte*)"\x7d\x08" "in_start")
QDEF(MP_QSTR_in_waiting, (const byte*)"\xd6\x0a" "in_waiting")
QDEF(MP_QSTR_incoming_packet_length, (const byte*)"\x97\x16" "incoming_packet_length")
QDEF(MP_QSTR_index, (const byte*)"\x7b\x05" "index")
QDEF(MP_QSTR_indicate, (const byte*)"\x9c\x08" "indicate")
QDEF(MP_QSTR_indices, (const byte*)"\x5a\x07" "indices")
QDEF(MP_QSTR_inf, (const byte*)"\x04\x03" "inf")
QDEF(MP_QSTR_init_sequence, (const byte*)"\x7f\x0d" "init_sequence")
QDEF(MP_QSTR_initial_value, (const byte*)"\xef\x0d" "initial_value")
QDEF(MP_QSTR_input, (const byte*)"\x73\x05" "input")
QDEF(MP_QSTR_insert, (const byte*)"\x12\x06" "insert")
QDEF(MP_QSTR_int, (const byte*)"\x16\x03" "int")
QDEF(MP_QSTR_int16, (const byte*)"\xf1\x05" "int16")
QDEF(MP_QSTR_int8, (const byte*)"\xee\x04" "int8")
QDEF(MP_QSTR_interp, (const byte*)"\xf1\x06" "interp")
QDEF(MP_QSTR_intersection, (const byte*)"\x28\x0c" "intersection")
QDEF(MP_QSTR_intersection_update, (const byte*)"\x06\x13" "intersection_update")
QDEF(MP_QSTR_interval, (const byte*)"\x1a\x08" "interval")
QDEF(MP_QSTR_inv, (const byte*)"\x14\x03" "inv")
QDEF(MP_QSTR_io, (const byte*)"\x23\x02" "io")
QDEF(MP_QSTR_ioctl, (const byte*)"\x78\x05" "ioctl")
QDEF(MP_QSTR_isalpha, (const byte*)"\xeb\x07" "isalpha")
QDEF(MP_QSTR_isdigit, (const byte*)"\xa8\x07" "isdigit")
QDEF(MP_QSTR_isdisjoint, (const byte*)"\xf7\x0a" "isdisjoint")
QDEF(MP_QSTR_isenabled, (const byte*)"\x9a\x09" "isenabled")
QDEF(MP_QSTR_isfinite, (const byte*)"\xa6\x08" "isfinite")
QDEF(MP_QSTR_isinf, (const byte*)"\x3e\x05" "isinf")
QDEF(MP_QSTR_isinstance, (const byte*)"\xb6\x0a" "isinstance")
QDEF(MP_QSTR_islower, (const byte*)"\xfc\x07" "islower")
QDEF(MP_QSTR_isnan, (const byte*)"\x9e\x05" "isnan")
QDEF(MP_QSTR_isspace, (const byte*)"\x5b\x07" "isspace")
QDEF(MP_QSTR_issubclass, (const byte*)"\xb5\x0a" "issubclass")
QDEF(MP_QSTR_issubset, (const byte*)"\xb9\x08" "issubset")
QDEF(MP_QSTR_issuperset, (const byte*)"\xfc\x0a" "issuperset")
QDEF(MP_QSTR_isupper, (const byte*)"\xdd\x07" "isupper")
QDEF(MP_QSTR_items, (const byte*)"\xe3\x05" "items")
QDEF(MP_QSTR_itemsize, (const byte*)"\x75\x08" "itemsize")
QDEF(MP_QSTR_iter, (const byte*)"\x8f\x04" "iter")
QDEF(MP_QSTR_iterable, (const byte*)"\x25\x08" "iterable")
QDEF(MP_QSTR_iterator, (const byte*)"\x47\x08" "iterator")
QDEF(MP_QSTR_join, (const byte*)"\xa7\x04" "join")
QDEF(MP_QSTR_json, (const byte*)"\xfd\x04" "json")
QDEF(MP_QSTR_k, (const byte*)"\xce\x01" "k")
QDEF(MP_QSTR_kbd_intr, (const byte*)"\xf6\x08" "kbd_intr")
QDEF(MP_QSTR_keepends, (const byte*)"\x62\x08" "keepends")
QDEF(MP_QSTR_key, (const byte*)"\x32\x03" "key")
QDEF(MP_QSTR_keys, (const byte*)"\x01\x04" "keys")
QDEF(MP_QSTR_label, (const byte*)"\x43\x05" "label")
QDEF(MP_QSTR_ldexp, (const byte*)"\x40\x05" "ldexp")
QDEF(MP_QSTR_left, (const byte*)"\xde\x04" "left")
QDEF(MP_QSTR_len, (const byte*)"\x62\x03" "len")
QDEF(MP_QSTR_length, (const byte*)"\x59\x06" "length")
QDEF(MP_QSTR_lgamma, (const byte*)"\xce\x06" "lgamma")
QDEF(MP_QSTR_linalg, (const byte*)"\x44\x06" "linalg")
QDEF(MP_QSTR_linspace, (const byte*)"\x6a\x08" "linspace")
QDEF(MP_QSTR_list, (const byte*)"\x27\x04" "list")
QDEF(MP_QSTR_listdir, (const byte*)"\x98\x07" "listdir")
QDEF(MP_QSTR_little, (const byte*)"\x89\x06" "little")
QDEF(MP_QSTR_load, (const byte*)"\x63\x04" "load")
QDEF(MP_QSTR_loads, (const byte*)"\xb0\x05" "loads")
QDEF(MP_QSTR_locals, (const byte*)"\x3b\x06" "locals")
QDEF(MP_QSTR_localtime, (const byte*)"\x7d\x09" "localtime")
QDEF(MP_QSTR_log, (const byte*)"\x21\x03" "log")
QDEF(MP_QSTR_log10, (const byte*)"\x40\x05" "log10")
QDEF(MP_QSTR_log2, (const byte*)"\x73\x04" "log2")
QDEF(MP_QSTR_logspace, (const byte*)"\x85\x08" "logspace")
QDEF(MP_QSTR_lower, (const byte*)"\xc6\x05" "lower")
QDEF(MP_QSTR_lstrip, (const byte*)"\xe5\x06" "lstrip")
QDEF(MP_QSTR_machine, (const byte*)"\x60\x07" "machine")
QDEF(MP_QSTR_make_opaque, (const byte*)"\x07\x0b" "make_opaque")
QDEF(MP_QSTR_make_transparent, (const byte*)"\x5e\x10" "make_transparent")
QDEF(MP_QSTR_map, (const byte*)"\xb9\x03" "map")
QDEF(MP_QSTR_match, (const byte*)"\x96\x05" "match")
QDEF(MP_QSTR_matches, (const byte*)"\xe0\x07" "matches")
QDEF(MP_QSTR_math, (const byte*)"\x35\x04" "math")
QDEF(MP_QSTR_max, (const byte*)"\xb1\x03" "max")
QDEF(MP_QSTR_max_length, (const byte*)"\x52\x0a" "max_length")
QDEF(MP_QSTR_max_packet_length, (const byte*)"\x45\x11" "max_packet_length")
QDEF(MP_QSTR_max_size, (const byte*)"\x6b\x08" "max_size")
QDEF(MP_QSTR_maximum, (const byte*)"\x6d\x07" "maximum")
QDEF(MP_QSTR_maxiter, (const byte*)"\x3b\x07" "maxiter")
QDEF(MP_QSTR_maxlen, (const byte*)"\x56\x06" "maxlen")
QDEF(MP_QSTR_maxsize, (const byte*)"\xd4\x07" "maxsize")
QDEF(MP_QSTR_mean, (const byte*)"\xc2\x04" "mean")
QDEF(MP_QSTR_median, (const byte*)"\x0f\x06" "median")
QDEF(MP_QSTR_mem_alloc, (const byte*)"\x52\x09" "mem_alloc")
QDEF(MP_QSTR_mem_free, (const byte*)"\xcb\x08" "mem_free")
QDEF(MP_QSTR_memoryview, (const byte*)"\x69\x0a" "memoryview")
QDEF(MP_QSTR_microcontroller, (const byte*)"\xa3\x0f" "microcontroller")
QDEF(MP_QSTR_micropython, (const byte*)"\x0b\x0b" "micropython")
QDEF(MP_QSTR_min, (const byte*)"\xaf\x03" "min")
QDEF(MP_QSTR_minimum, (const byte*)"\x73\x07" "minimum")
QDEF(MP_QSTR_minimum_frames_per_second, (const byte*)"\xf5\x19" "minimum_frames_per_second")
QDEF(MP_QSTR_minimum_rssi, (const byte*)"\x37\x0c" "minimum_rssi")
QDEF(MP_QSTR_mirror_x, (const byte*)"\x1b\x08" "mirror_x")
QDEF(MP_QSTR_mirror_y, (const byte*)"\x1a\x08" "mirror_y")
QDEF(MP_QSTR_mkdir, (const byte*)"\x9c\x05" "mkdir")
QDEF(MP_QSTR_mkfs, (const byte*)"\x76\x04" "mkfs")
QDEF(MP_QSTR_mktime, (const byte*)"\x96\x06" "mktime")
QDEF(MP_QSTR_mode, (const byte*)"\x26\x04" "mode")
QDEF(MP_QSTR_modf, (const byte*)"\x25\x04" "modf")
QDEF(MP_QSTR_module, (const byte*)"\xbf\x06" "module")
QDEF(MP_QSTR_modules, (const byte*)"\xec\x07" "modules")
QDEF(MP_QSTR_monotonic, (const byte*)"\x19\x09" "monotonic")
QDEF(MP_QSTR_monotonic_ns, (const byte*)"\x3b\x0c" "monotonic_ns")
QDEF(MP_QSTR_mount, (const byte*)"\xa8\x05" "mount")
QDEF(MP_QSTR_msgpack, (const byte*)"\x45\x07" "msgpack")
QDEF(MP_QSTR_n, (const byte*)"\xcb\x01" "n")
QDEF(MP_QSTR_name, (const byte*)"\xa2\x04" "name")
QDEF(MP_QSTR_namedtuple, (const byte*)"\x1e\x0a" "namedtuple")
QDEF(MP_QSTR_nan, (const byte*)"\xe4\x03" "nan")
QDEF(MP_QSTR_native, (const byte*)"\x84\x06" "native")
QDEF(MP_QSTR_native_frames_per_second, (const byte*)"\x42\x18" "native_frames_per_second")
QDEF(MP_QSTR_ndarray, (const byte*)"\x76\x07" "ndarray")
QDEF(MP_QSTR_ndinfo, (const byte*)"\xa1\x06" "ndinfo")
QDEF(MP_QSTR_neopixel_write, (const byte*)"\x2b\x0e" "neopixel_write")
QDEF(MP_QSTR_newton, (const byte*)"\x4c\x06" "newton")
QDEF(MP_QSTR_next, (const byte*)"\x42\x04" "next")
QDEF(MP_QSTR_nodename, (const byte*)"\x62\x08" "nodename")
QDEF(MP_QSTR_norm, (const byte*)"\x1b\x04" "norm")
QDEF(MP_QSTR_not_equal, (const byte*)"\x63\x09" "not_equal")
QDEF(MP_QSTR_notify, (const byte*)"\x06\x06" "notify")
QDEF(MP_QSTR_num, (const byte*)"\x73\x03" "num")
QDEF(MP_QSTR_numerical, (const byte*)"\xc3\x09" "numerical")
QDEF(MP_QSTR_nvm, (const byte*)"\x90\x03" "nvm")
QDEF(MP_QSTR_obj, (const byte*)"\x02\x03" "obj")
QDEF(MP_QSTR_object, (const byte*)"\x90\x06" "object")
QDEF(MP_QSTR_oct, (const byte*)"\xfd\x03" "oct")
QDEF(MP_QSTR_offset, (const byte*)"\x48\x06" "offset")
QDEF(MP_QSTR_on_next_reset, (const byte*)"\xb6\x0d" "on_next_reset")
QDEF(MP_QSTR_ones, (const byte*)"\xd2\x04" "ones")
QDEF(MP_QSTR_open, (const byte*)"\xd1\x04" "open")
QDEF(MP_QSTR_opt_level, (const byte*)"\x87\x09" "opt_level")
QDEF(MP_QSTR_ord, (const byte*)"\x1c\x03" "ord")
QDEF(MP_QSTR_order, (const byte*)"\x6b\x05" "order")
QDEF(MP_QSTR_os, (const byte*)"\x79\x02" "os")
QDEF(MP_QSTR_otypes, (const byte*)"\xe1\x06" "otypes")
QDEF(MP_QSTR_out_buffer, (const byte*)"\xf4\x0a" "out_buffer")
QDEF(MP_QSTR_out_end, (const byte*)"\x7b\x07" "out_end")
QDEF(MP_QSTR_out_start, (const byte*)"\xf4\x09" "out_start")
QDEF(MP_QSTR_outgoing_packet_length, (const byte*)"\xf7\x16" "outgoing_packet_length")
QDEF(MP_QSTR_ox, (const byte*)"\x72\x02" "ox")
QDEF(MP_QSTR_oy, (const byte*)"\x73\x02" "oy")
QDEF(MP_QSTR_pack, (const byte*)"\xbc\x04" "pack")
QDEF(MP_QSTR_pack_into, (const byte*)"\x1f\x09" "pack_into")
QDEF(MP_QSTR_packet_size, (const byte*)"\xd7\x0b" "packet_size")
QDEF(MP_QSTR_pair, (const byte*)"\xef\x04" "pair")
QDEF(MP_QSTR_paired, (const byte*)"\x8e\x06" "paired")
QDEF(MP_QSTR_parity, (const byte*)"\x42\x06" "parity")
QDEF(MP_QSTR_partition, (const byte*)"\x87\x09" "partition")
QDEF(MP_QSTR_path, (const byte*)"\x88\x04" "path")
QDEF(MP_QSTR_pause, (const byte*)"\xd7\x05" "pause")
QDEF(MP_QSTR_paused, (const byte*)"\xd3\x06" "paused")
QDEF(MP_QSTR_pend_throw, (const byte*)"\xf3\x0a" "pend_throw")
QDEF(MP_QSTR_phase, (const byte*)"\x6a\x05" "phase")
QDEF(MP_QSTR_pi, (const byte*)"\x1c\x02" "pi")
QDEF(MP_QSTR_pin, (const byte*)"\xf2\x03" "pin")
QDEF(MP_QSTR_pixel_shader, (const byte*)"\x5b\x0c" "pixel_shader")
QDEF(MP_QSTR_pixels_in_byte_share_row, (const byte*)"\xd4\x18" "pixels_in_byte_share_row")
QDEF(MP_QSTR_point, (const byte*)"\xe9\x05" "point")
QDEF(MP_QSTR_points, (const byte*)"\x7a\x06" "points")
QDEF(MP_QSTR_polarity, (const byte*)"\x41\x08" "polarity")
QDEF(MP_QSTR_poly, (const byte*)"\x8f\x04" "poly")
QDEF(MP_QSTR_polyfit, (const byte*)"\x34\x07" "polyfit")
QDEF(MP_QSTR_polyval, (const byte*)"\x34\x07" "polyval")
QDEF(MP_QSTR_pop, (const byte*)"\x2a\x03" "pop")
QDEF(MP_QSTR_popitem, (const byte*)"\xbf\x07" "popitem")
QDEF(MP_QSTR_popleft, (const byte*)"\x71\x07" "popleft")
QDEF(MP_QSTR_pow, (const byte*)"\x2d\x03" "pow")
QDEF(MP_QSTR_prefixes, (const byte*)"\x23\x08" "prefixes")
QDEF(MP_QSTR_print, (const byte*)"\x54\x05" "print")
QDEF(MP_QSTR_print_exception, (const byte*)"\x1c\x0f" "print_exception")
QDEF(MP_QSTR_probe, (const byte*)"\x4f\x05" "probe")
QDEF(MP_QSTR_properties, (const byte*)"\x24\x0a" "properties")
QDEF(MP_QSTR_property, (const byte*)"\xc2\x08" "property")
QDEF(MP_QSTR_protocol_framebuffer, (const byte*)"\xf1\x14" "protocol_framebuffer")
QDEF(MP_QSTR_protocol_pin, (const byte*)"\x1b\x0c" "protocol_pin")
QDEF(MP_QSTR_protocol_stream, (const byte*)"\x90\x0f" "protocol_stream")
QDEF(MP_QSTR_protocol_vfs, (const byte*)"\xef\x0c" "protocol_vfs")
QDEF(MP_QSTR_pull, (const byte*)"\x80\x04" "pull")
QDEF(MP_QSTR_pulseio, (const byte*)"\xfc\x07" "pulseio")
QDEF(MP_QSTR_pwmio, (const byte*)"\x49\x05" "pwmio")
QDEF(MP_QSTR_px, (const byte*)"\x0d\x02" "px")
QDEF(MP_QSTR_py, (const byte*)"\x0c\x02" "py")
QDEF(MP_QSTR_pystack_use, (const byte*)"\xfe\x0b" "pystack_use")
QDEF(MP_QSTR_r, (const byte*)"\xd7\x01" "r")
QDEF(MP_QSTR_radians, (const byte*)"\x87\x07" "radians")
QDEF(MP_QSTR_radius, (const byte*)"\xfd\x06" "radius")
QDEF(MP_QSTR_ram_height, (const byte*)"\x3b\x0a" "ram_height")
QDEF(MP_QSTR_ram_width, (const byte*)"\x82\x09" "ram_width")
QDEF(MP_QSTR_randint, (const byte*)"\xaf\x07" "randint")
QDEF(MP_QSTR_random, (const byte*)"\xbe\x06" "random")
QDEF(MP_QSTR_randrange, (const byte*)"\xa3\x09" "randrange")
QDEF(MP_QSTR_range, (const byte*)"\x1a\x05" "range")
QDEF(MP_QSTR_raw_value, (const byte*)"\xf5\x09" "raw_value")
QDEF(MP_QSTR_re, (const byte*)"\xd2\x02" "re")
QDEF(MP_QSTR_read, (const byte*)"\xb7\x04" "read")
QDEF(MP_QSTR_read_bit, (const byte*)"\x97\x08" "read_bit")
QDEF(MP_QSTR_read_perm, (const byte*)"\x82\x09" "read_perm")
QDEF(MP_QSTR_readblocks, (const byte*)"\x2d\x0a" "readblocks")
QDEF(MP_QSTR_readfrom_into, (const byte*)"\x82\x0d" "readfrom_into")
QDEF(MP_QSTR_readinto, (const byte*)"\x4b\x08" "readinto")
QDEF(MP_QSTR_readline, (const byte*)"\xf9\x08" "readline")
QDEF(MP_QSTR_readlines, (const byte*)"\x6a\x09" "readlines")
QDEF(MP_QSTR_readonly, (const byte*)"\x03\x08" "readonly")
QDEF(MP_QSTR_real, (const byte*)"\xbf\x04" "real")
QDEF(MP_QSTR_receiver_buffer_size, (const byte*)"\x99\x14" "receiver_buffer_size")
QDEF(MP_QSTR_reference_voltage, (const byte*)"\x93\x11" "reference_voltage")
QDEF(MP_QSTR_refresh, (const byte*)"\x98\x07" "refresh")
QDEF(MP_QSTR_refresh_display_command, (const byte*)"\x05\x17" "refresh_display_command")
QDEF(MP_QSTR_refresh_time, (const byte*)"\xb2\x0c" "refresh_time")
QDEF(MP_QSTR_release, (const byte*)"\xec\x07" "release")
QDEF(MP_QSTR_release_displays, (const byte*)"\x3a\x10" "release_displays")
QDEF(MP_QSTR_reload, (const byte*)"\x74\x06" "reload")
QDEF(MP_QSTR_remote, (const byte*)"\xa1\x06" "remote")
QDEF(MP_QSTR_remount, (const byte*)"\x9f\x07" "remount")
QDEF(MP_QSTR_remove, (const byte*)"\x63\x06" "remove")
QDEF(MP_QSTR_rename, (const byte*)"\x35\x06" "rename")
QDEF(MP_QSTR_replace, (const byte*)"\x49\x07" "replace")
QDEF(MP_QSTR_repr, (const byte*)"\xd0\x04" "repr")
QDEF(MP_QSTR_reset, (const byte*)"\x10\x05" "reset")
QDEF(MP_QSTR_reset_input_buffer, (const byte*)"\xe6\x12" "reset_input_buffer")
QDEF(MP_QSTR_reset_reason, (const byte*)"\x0b\x0c" "reset_reason")
QDEF(MP_QSTR_reshape, (const byte*)"\x7d\x07" "reshape")
QDEF(MP_QSTR_resume, (const byte*)"\x5c\x06" "resume")
QDEF(MP_QSTR_retstep, (const byte*)"\x34\x07" "retstep")
QDEF(MP_QSTR_reverse, (const byte*)"\x25\x07" "reverse")
QDEF(MP_QSTR_reverse_bytes_in_word, (const byte*)"\x2a\x15" "reverse_bytes_in_word")
QDEF(MP_QSTR_reverse_pixels_in_byte, (const byte*)"\xec\x16" "reverse_pixels_in_byte")
QDEF(MP_QSTR_reversed, (const byte*)"\xa1\x08" "reversed")
QDEF(MP_QSTR_rfind, (const byte*)"\xd2\x05" "rfind")
QDEF(MP_QSTR_right, (const byte*)"\xe5\x05" "right")
QDEF(MP_QSTR_rindex, (const byte*)"\xe9\x06" "rindex")
QDEF(MP_QSTR_rmdir, (const byte*)"\x45\x05" "rmdir")
QDEF(MP_QSTR_roll, (const byte*)"\x58\x04" "roll")
QDEF(MP_QSTR_rotation, (const byte*)"\xf1\x08" "rotation")
QDEF(MP_QSTR_rotozoom, (const byte*)"\x34\x08" "rotozoom")
QDEF(MP_QSTR_round, (const byte*)"\xe7\x05" "round")
QDEF(MP_QSTR_rowstart, (const byte*)"\x2f\x08" "rowstart")
QDEF(MP_QSTR_rpartition, (const byte*)"\x15\x0a" "rpartition")
QDEF(MP_QSTR_rs485_dir, (const byte*)"\xdd\x09" "rs485_dir")
QDEF(MP_QSTR_rs485_invert, (const byte*)"\xb0\x0c" "rs485_invert")
QDEF(MP_QSTR_rsplit, (const byte*)"\xa5\x06" "rsplit")
QDEF(MP_QSTR_rssi, (const byte*)"\x7e\x04" "rssi")
QDEF(MP_QSTR_rstrip, (const byte*)"\x3b\x06" "rstrip")
QDEF(MP_QSTR_rtol, (const byte*)"\xa0\x04" "rtol")
QDEF(MP_QSTR_rts, (const byte*)"\x50\x03" "rts")
QDEF(MP_QSTR_run_reason, (const byte*)"\x77\x0a" "run_reason")
QDEF(MP_QSTR_runtime, (const byte*)"\x99\x07" "runtime")
QDEF(MP_QSTR_rx, (const byte*)"\xcf\x02" "rx")
QDEF(MP_QSTR_scale, (const byte*)"\x7d\x05" "scale")
QDEF(MP_QSTR_scan, (const byte*)"\x1a\x04" "scan")
QDEF(MP_QSTR_scan_response, (const byte*)"\xe6\x0d" "scan_response")
QDEF(MP_QSTR_scl, (const byte*)"\xf9\x03" "scl")
QDEF(MP_QSTR_sda, (const byte*)"\x53\x03" "sda")
QDEF(MP_QSTR_sdcardio, (const byte*)"\xa0\x08" "sdcardio")
QDEF(MP_QSTR_sdio, (const byte*)"\xd4\x04" "sdio")
QDEF(MP_QSTR_search, (const byte*)"\xab\x06" "search")
QDEF(MP_QSTR_secondary, (const byte*)"\x9f\x09" "secondary")
QDEF(MP_QSTR_seconds_per_frame, (const byte*)"\x5c\x11" "seconds_per_frame")
QDEF(MP_QSTR_seed, (const byte*)"\x92\x04" "seed")
QDEF(MP_QSTR_seek, (const byte*)"\x9d\x04" "seek")
QDEF(MP_QSTR_send, (const byte*)"\xb9\x04" "send")
QDEF(MP_QSTR_sep, (const byte*)"\x23\x03" "sep")
QDEF(MP_QSTR_serial_bytes_available, (const byte*)"\x45\x16" "serial_bytes_available")
QDEF(MP_QSTR_serial_connected, (const byte*)"\xa5\x10" "serial_connected")
QDEF(MP_QSTR_service, (const byte*)"\x98\x07" "service")
QDEF(MP_QSTR_service_uuids_whitelist, (const byte*)"\xc3\x17" "service_uuids_whitelist")
QDEF(MP_QSTR_set, (const byte*)"\x27\x03" "set")
QDEF(MP_QSTR_set_adapter, (const byte*)"\x0f\x0b" "set_adapter")
QDEF(MP_QSTR_set_boundary, (const byte*)"\x60\x0c" "set_boundary")
QDEF(MP_QSTR_set_cccd, (const byte*)"\x9f\x08" "set_cccd")
QDEF(MP_QSTR_set_column_command, (const byte*)"\x16\x12" "set_column_command")
QDEF(MP_QSTR_set_column_window_command, (const byte*)"\x05\x19" "set_column_window_command")
QDEF(MP_QSTR_set_current_column_command, (const byte*)"\xa0\x1a" "set_current_column_command")
QDEF(MP_QSTR_set_current_row_command, (const byte*)"\xfc\x17" "set_current_row_command")
QDEF(MP_QSTR_set_next_stack_limit, (const byte*)"\xa4\x14" "set_next_stack_limit")
QDEF(MP_QSTR_set_printoptions, (const byte*)"\xd9\x10" "set_printoptions")
QDEF(MP_QSTR_set_rgb_status_brightness, (const byte*)"\x92\x19" "set_rgb_status_brightness")
QDEF(MP_QSTR_set_row_command, (const byte*)"\xca\x0f" "set_row_command")
QDEF(MP_QSTR_set_row_window_command, (const byte*)"\xd9\x16" "set_row_window_command")
QDEF(MP_QSTR_set_vertical_scroll, (const byte*)"\x38\x13" "set_vertical_scroll")
QDEF(MP_QSTR_setattr, (const byte*)"\xd4\x07" "setattr")
QDEF(MP_QSTR_setdefault, (const byte*)"\x6c\x0a" "setdefault")
QDEF(MP_QSTR_setter, (const byte*)"\x04\x06" "setter")
QDEF(MP_QSTR_shape, (const byte*)"\xca\x05" "shape")
QDEF(MP_QSTR_sharpdisplay, (const byte*)"\x07\x0c" "sharpdisplay")
QDEF(MP_QSTR_shift_x, (const byte*)"\xc2\x07" "shift_x")
QDEF(MP_QSTR_shift_y, (const byte*)"\xc3\x07" "shift_y")
QDEF(MP_QSTR_show, (const byte*)"\x86\x04" "show")
QDEF(MP_QSTR_signed, (const byte*)"\x37\x06" "signed")
QDEF(MP_QSTR_sin, (const byte*)"\xb1\x03" "sin")
QDEF(MP_QSTR_single_byte_bounds, (const byte*)"\x34\x12" "single_byte_bounds")
QDEF(MP_QSTR_sinh, (const byte*)"\xb9\x04" "sinh")
QDEF(MP_QSTR_size, (const byte*)"\x20\x04" "size")
QDEF(MP_QSTR_skip_index, (const byte*)"\x65\x0a" "skip_index")
QDEF(MP_QSTR_sleep, (const byte*)"\xea\x05" "sleep")
QDEF(MP_QSTR_slice, (const byte*)"\xb5\x05" "slice")
QDEF(MP_QSTR_sort, (const byte*)"\xbf\x04" "sort")
QDEF(MP_QSTR_sorted, (const byte*)"\x5e\x06" "sorted")
QDEF(MP_QSTR_sos, (const byte*)"\x6a\x03" "sos")
QDEF(MP_QSTR_sosfilt, (const byte*)"\xbd\x07" "sosfilt")
QDEF(MP_QSTR_source_bitmap, (const byte*)"\xc4\x0d" "source_bitmap")
QDEF(MP_QSTR_source_clip0, (const byte*)"\x61\x0c" "source_clip0")
QDEF(MP_QSTR_source_clip1, (const byte*)"\x60\x0c" "source_clip1")
QDEF(MP_QSTR_span, (const byte*)"\xc9\x04" "span")
QDEF(MP_QSTR_spectrogram, (const byte*)"\x30\x0b" "spectrogram")
QDEF(MP_QSTR_spi, (const byte*)"\xcf\x03" "spi")
QDEF(MP_QSTR_spi_bus, (const byte*)"\xf4\x07" "spi_bus")
QDEF(MP_QSTR_spi_device, (const byte*)"\xc8\x0a" "spi_device")
QDEF(MP_QSTR_split, (const byte*)"\xb7\x05" "split")
QDEF(MP_QSTR_splitlines, (const byte*)"\x6a\x0a" "splitlines")
QDEF(MP_QSTR_sqrt, (const byte*)"\x21\x04" "sqrt")
QDEF(MP_QSTR_start, (const byte*)"\x85\x05" "start")
QDEF(MP_QSTR_start_advertising, (const byte*)"\x10\x11" "start_advertising")
QDEF(MP_QSTR_start_scan, (const byte*)"\x65\x0a" "start_scan")
QDEF(MP_QSTR_start_sequence, (const byte*)"\x25\x0e" "start_sequence")
QDEF(MP_QSTR_startswith, (const byte*)"\x74\x0a" "startswith")
QDEF(MP_QSTR_stat, (const byte*)"\xd7\x04" "stat")
QDEF(MP_QSTR_staticmethod, (const byte*)"\x62\x0c" "staticmethod")
QDEF(MP_QSTR_statvfs, (const byte*)"\x14\x07" "statvfs")
QDEF(MP_QSTR_std, (const byte*)"\x46\x03" "std")
QDEF(MP_QSTR_stderr, (const byte*)"\xa3\x06" "stderr")
QDEF(MP_QSTR_stdin, (const byte*)"\x21\x05" "stdin")
QDEF(MP_QSTR_stdout, (const byte*)"\x08\x06" "stdout")
QDEF(MP_QSTR_step, (const byte*)"\x57\x04" "step")
QDEF(MP_QSTR_stop, (const byte*)"\x9d\x04" "stop")
QDEF(MP_QSTR_stop_advertising, (const byte*)"\x08\x10" "stop_advertising")
QDEF(MP_QSTR_stop_scan, (const byte*)"\x7d\x09" "stop_scan")
QDEF(MP_QSTR_stop_sequence, (const byte*)"\x3d\x0d" "stop_sequence")
QDEF(MP_QSTR_storage, (const byte*)"\xbc\x07" "storage")
QDEF(MP_QSTR_str, (const byte*)"\x50\x03" "str")
QDEF(MP_QSTR_strerror, (const byte*)"\x48\x08" "strerror")
QDEF(MP_QSTR_strides, (const byte*)"\xcb\x07" "strides")
QDEF(MP_QSTR_strip, (const byte*)"\x29\x05" "strip")
QDEF(MP_QSTR_struct, (const byte*)"\x12\x06" "struct")
QDEF(MP_QSTR_struct_time, (const byte*)"\xf8\x0b" "struct_time")
QDEF(MP_QSTR_sub, (const byte*)"\x21\x03" "sub")
QDEF(MP_QSTR_sum, (const byte*)"\x2e\x03" "sum")
QDEF(MP_QSTR_super, (const byte*)"\xc4\x05" "super")
QDEF(MP_QSTR_supervisor, (const byte*)"\x35\x0a" "supervisor")
QDEF(MP_QSTR_switch_to_input, (const byte*)"\xfa\x0f" "switch_to_input")
QDEF(MP_QSTR_switch_to_output, (const byte*)"\xf3\x10" "switch_to_output")
QDEF(MP_QSTR_symmetric_difference, (const byte*)"\xce\x14" "symmetric_difference")
QDEF(MP_QSTR_symmetric_difference_update, (const byte*)"\x60\x1b" "symmetric_difference_update")
QDEF(MP_QSTR_sync, (const byte*)"\xa2\x04" "sync")
QDEF(MP_QSTR_sys, (const byte*)"\xbc\x03" "sys")
QDEF(MP_QSTR_sysname, (const byte*)"\x9b\x07" "sysname")
QDEF(MP_QSTR_tan, (const byte*)"\xfe\x03" "tan")
QDEF(MP_QSTR_tanh, (const byte*)"\xd6\x04" "tanh")
QDEF(MP_QSTR_target_frames_per_second, (const byte*)"\x72\x18" "target_frames_per_second")
QDEF(MP_QSTR_tell, (const byte*)"\x14\x04" "tell")
QDEF(MP_QSTR_temperature, (const byte*)"\xe9\x0b" "temperature")
QDEF(MP_QSTR_terminalio, (const byte*)"\x67\x0a" "terminalio")
QDEF(MP_QSTR_threshold, (const byte*)"\xf2\x09" "threshold")
QDEF(MP_QSTR_throw, (const byte*)"\xb3\x05" "throw")
QDEF(MP_QSTR_tile_height, (const byte*)"\x91\x0b" "tile_height")
QDEF(MP_QSTR_tile_index, (const byte*)"\xb0\x0a" "tile_index")
QDEF(MP_QSTR_tile_width, (const byte*)"\xe8\x0a" "tile_width")
QDEF(MP_QSTR_tilegrid, (const byte*)"\x49\x08" "tilegrid")
QDEF(MP_QSTR_time, (const byte*)"\xf0\x04" "time")
QDEF(MP_QSTR_time_to_refresh, (const byte*)"\xf6\x0f" "time_to_refresh")
QDEF(MP_QSTR_timeout, (const byte*)"\x3e\x07" "timeout")
QDEF(MP_QSTR_tm_hour, (const byte*)"\xa3\x07" "tm_hour")
QDEF(MP_QSTR_tm_isdst, (const byte*)"\xda\x08" "tm_isdst")
QDEF(MP_QSTR_tm_mday, (const byte*)"\xd2\x07" "tm_mday")
QDEF(MP_QSTR_tm_min, (const byte*)"\xa9\x06" "tm_min")
QDEF(MP_QSTR_tm_mon, (const byte*)"\x6f\x06" "tm_mon")
QDEF(MP_QSTR_tm_sec, (const byte*)"\x36\x06" "tm_sec")
QDEF(MP_QSTR_tm_wday, (const byte*)"\x08\x07" "tm_wday")
QDEF(MP_QSTR_tm_yday, (const byte*)"\x46\x07" "tm_yday")
QDEF(MP_QSTR_tm_year, (const byte*)"\x8c\x07" "tm_year")
QDEF(MP_QSTR_to_bytes, (const byte*)"\xd8\x08" "to_bytes")
QDEF(MP_QSTR_tobytes, (const byte*)"\xa7\x07" "tobytes")
QDEF(MP_QSTR_toggle_every_byte, (const byte*)"\x40\x11" "toggle_every_byte")
QDEF(MP_QSTR_tol, (const byte*)"\x32\x03" "tol")
QDEF(MP_QSTR_touchio, (const byte*)"\x66\x07" "touchio")
QDEF(MP_QSTR_trace, (const byte*)"\xa4\x05" "trace")
QDEF(MP_QSTR_trailer, (const byte*)"\x10\x07" "trailer")
QDEF(MP_QSTR_transpose, (const byte*)"\xf6\x09" "transpose")
QDEF(MP_QSTR_transpose_xy, (const byte*)"\xe8\x0c" "transpose_xy")
QDEF(MP_QSTR_trapz, (const byte*)"\x88\x05" "trapz")
QDEF(MP_QSTR_trigger_duration, (const byte*)"\x1c\x10" "trigger_duration")
QDEF(MP_QSTR_trunc, (const byte*)"\x5b\x05" "trunc")
QDEF(MP_QSTR_try_lock, (const byte*)"\x2e\x08" "try_lock")
QDEF(MP_QSTR_tuple, (const byte*)"\xfd\x05" "tuple")
QDEF(MP_QSTR_tx, (const byte*)"\x89\x02" "tx")
QDEF(MP_QSTR_type, (const byte*)"\x9d\x04" "type")
QDEF(MP_QSTR_uart, (const byte*)"\x77\x04" "uart")
QDEF(MP_QSTR_uid, (const byte*)"\xbd\x03" "uid")
QDEF(MP_QSTR_uint16, (const byte*)"\x84\x06" "uint16")
QDEF(MP_QSTR_uint8, (const byte*)"\x7b\x05" "uint8")
QDEF(MP_QSTR_uio, (const byte*)"\xb6\x03" "uio")
QDEF(MP_QSTR_ulab, (const byte*)"\x9f\x04" "ulab")
QDEF(MP_QSTR_umount, (const byte*)"\xdd\x06" "umount")
QDEF(MP_QSTR_uname, (const byte*)"\xb7\x05" "uname")
QDEF(MP_QSTR_unhexlify, (const byte*)"\xb1\x09" "unhexlify")
QDEF(MP_QSTR_uniform, (const byte*)"\x01\x07" "uniform")
QDEF(MP_QSTR_union, (const byte*)"\xf6\x05" "union")
QDEF(MP_QSTR_unlink, (const byte*)"\xfe\x06" "unlink")
QDEF(MP_QSTR_unlock, (const byte*)"\x15\x06" "unlock")
QDEF(MP_QSTR_unpack, (const byte*)"\x07\x06" "unpack")
QDEF(MP_QSTR_unpack_from, (const byte*)"\x0e\x0b" "unpack_from")
QDEF(MP_QSTR_update, (const byte*)"\xb4\x06" "update")
QDEF(MP_QSTR_upper, (const byte*)"\x27\x05" "upper")
QDEF(MP_QSTR_urandom, (const byte*)"\xab\x07" "urandom")
QDEF(MP_QSTR_use_list, (const byte*)"\x9b\x08" "use_list")
QDEF(MP_QSTR_uuid, (const byte*)"\xc8\x04" "uuid")
QDEF(MP_QSTR_uuid128, (const byte*)"\xb3\x07" "uuid128")
QDEF(MP_QSTR_uuid16, (const byte*)"\x2f\x06" "uuid16")
QDEF(MP_QSTR_v, (const byte*)"\xd3\x01" "v")
QDEF(MP_QSTR_value, (const byte*)"\x4e\x05" "value")
QDEF(MP_QSTR_values, (const byte*)"\x7d\x06" "values")
QDEF(MP_QSTR_variable_frequency, (const byte*)"\x58\x12" "variable_frequency")
QDEF(MP_QSTR_vector, (const byte*)"\xdc\x06" "vector")
QDEF(MP_QSTR_vectorio, (const byte*)"\xba\x08" "vectorio")
QDEF(MP_QSTR_vectorize, (const byte*)"\xea\x09" "vectorize")
QDEF(MP_QSTR_version, (const byte*)"\xbf\x07" "version")
QDEF(MP_QSTR_version_info, (const byte*)"\x6e\x0c" "version_info")
QDEF(MP_QSTR_voltage, (const byte*)"\x87\x07" "voltage")
QDEF(MP_QSTR_watchdog, (const byte*)"\x01\x08" "watchdog")
QDEF(MP_QSTR_wheel, (const byte*)"\x76\x05" "wheel")
QDEF(MP_QSTR_width, (const byte*)"\x23\x05" "width")
QDEF(MP_QSTR_window, (const byte*)"\x89\x06" "window")
QDEF(MP_QSTR_write, (const byte*)"\x98\x05" "write")
QDEF(MP_QSTR_write_bit, (const byte*)"\xf8\x09" "write_bit")
QDEF(MP_QSTR_write_black_ram_command, (const byte*)"\x19\x17" "write_black_ram_command")
QDEF(MP_QSTR_write_color_ram_command, (const byte*)"\x63\x17" "write_color_ram_command")
QDEF(MP_QSTR_write_perm, (const byte*)"\x0d\x0a" "write_perm")
QDEF(MP_QSTR_write_ram_command, (const byte*)"\x21\x11" "write_ram_command")
QDEF(MP_QSTR_write_readinto, (const byte*)"\x89\x0e" "write_readinto")
QDEF(MP_QSTR_write_then_readinto, (const byte*)"\x61\x13" "write_then_readinto")
QDEF(MP_QSTR_write_value, (const byte*)"\x4c\x0b" "write_value")
QDEF(MP_QSTR_writeblocks, (const byte*)"\x02\x0b" "writeblocks")
QDEF(MP_QSTR_writeto, (const byte*)"\x03\x07" "writeto")
QDEF(MP_QSTR_writeto_then_readfrom, (const byte*)"\x70\x15" "writeto_then_readfrom")
QDEF(MP_QSTR_x, (const byte*)"\xdd\x01" "x")
QDEF(MP_QSTR_x1, (const byte*)"\x4c\x02" "x1")
QDEF(MP_QSTR_x2, (const byte*)"\x4f\x02" "x2")
QDEF(MP_QSTR_xatol, (const byte*)"\x0b\x05" "xatol")
QDEF(MP_QSTR_xtol, (const byte*)"\x6a\x04" "xtol")
QDEF(MP_QSTR_y, (const byte*)"\xdc\x01" "y")
QDEF(MP_QSTR_y1, (const byte*)"\x6d\x02" "y1")
QDEF(MP_QSTR_y2, (const byte*)"\x6e\x02" "y2")
QDEF(MP_QSTR_zeros, (const byte*)"\x94\x05" "zeros")
QDEF(MP_QSTR_zi, (const byte*)"\xd6\x02" "zi")
QDEF(MP_QSTR_zip, (const byte*)"\xe6\x03" "zip")
TRANSLATION("  File \"%q\", line %d", 20, 0, 249, 14, 132, 31, 235, 135, 135, 253, 117, 194, 134, 132, 24, 102) //   File \"%q\", line %d
TRANSLATION(" is of type %q\n", 16, 212, 90, 186, 33, 135, 135, 143, 198) //  is of type %q\r\n
TRANSLATION(" output:\n", 10, 5, 186, 45, 186, 58, 252, 126, 48) //  output:\r\n
TRANSLATION("%%c requires int or char", 24, 195, 134, 94, 179, 242, 249, 242, 202, 44) // %%c requires int or char
TRANSLATION("%q in use", 9, 195, 195, 202, 185, 200) // %q in use
TRANSLATION("%q index out of range", 21, 195, 194, 6, 147, 45, 30, 175, 228) // %q index out of range
TRANSLATION("%q indices must be integers, not %q", 35, 195, 194, 6, 147, 57, 19, 224, 254, 239, 175, 171, 135, 132) // %q indices must be integers, not %q
TRANSLATION("%q list must be a list", 22, 195, 194, 20, 55, 140, 2, 20, 55, 128) // %q list must be a list
TRANSLATION("%q must be >= 1", 15, 195, 195, 131, 226, 248, 67, 170) // %q must be >= 1
TRANSLATION("%q must be a tuple of length 2", 30, 195, 195, 128, 66, 46, 182, 133, 206, 252, 3, 172) // %q must be a tuple of length 2
TRANSLATION("%q should be an int", 19, 195, 195, 235, 144, 10, 114, 192) // %q should be an int
TRANSLATION("'%q' argument required", 22, 197, 135, 135, 22, 151, 173, 48) // \'%q\' argument required
TRANSLATION("'%q' object cannot assign attribute '%q'", 40, 197, 135, 135, 23, 52, 37, 227, 23, 115, 173, 0, 127, 78, 64) // \'%q\' object cannot assign attribute \'%q\'
TRANSLATION("'%q' object does not support '%q'", 33, 197, 135, 135, 23, 52, 38, 164, 250, 175, 117, 182, 171, 71, 32) // \'%q\' object does not support \'%q\'
TRANSLATION("'%q' object does not support item assignment", 44, 197, 135, 135, 23, 52, 38, 164, 250, 175, 117, 182, 171, 64, 28, 21, 128, 46, 231, 90, 88, 73, 0) // \'%q\' object does not support item assignment
TRANSLATION("'%q' object does not support item deletion", 42, 197, 135, 135, 23, 52, 38, 164, 250, 175, 117, 182, 171, 64, 28, 21, 129, 50, 161, 113, 0) // \'%q\' object does not support item deletion
TRANSLATION("'%q' object has no attribute '%q'", 33, 197, 135, 135, 23, 52, 50, 139, 130, 40, 15, 233, 200) // \'%q\' object has no attribute \'%q\'
TRANSLATION("'%q' object is not an iterator", 30, 197, 135, 135, 23, 55, 83, 204, 40, 7, 4, 195, 10, 192) // \'%q\' object is not an iterator
TRANSLATION("'%q' object is not callable", 27, 197, 135, 135, 23, 55, 83, 205, 33, 165, 60, 64) // \'%q\' object is not callable
TRANSLATION("'%q' object is not iterable", 27, 197, 135, 135, 23, 55, 83, 204, 112, 77, 226) // \'%q\' object is not iterable
TRANSLATION("'%q' object is not subscriptable", 32, 197, 135, 135, 23, 55, 83, 204, 247, 100, 121, 49, 219, 30, 32) // \'%q\' object is not subscriptable
TRANSLATION("'=' alignment not allowed in string format specifier", 52, 197, 240, 226, 1, 161, 214, 150, 18, 70, 168, 210, 139, 156, 167, 202, 252, 253, 47, 100, 152) // \'=\' alignment not allowed in string format specifier
TRANSLATION("'await' outside function", 24, 196, 57, 196, 227, 23, 238, 242, 128) // \'await\' outside function
TRANSLATION("'await', 'async for' or 'async with' outside async function", 59, 196, 57, 196, 227, 22, 184, 98, 23, 189, 36, 21, 43, 98, 231, 226, 23, 189, 36, 25, 206, 50, 226, 253, 194, 247, 164, 131, 202) // \'await\', \'async for\' or \'async with\' outside async function
TRANSLATION("'break' outside loop", 20, 197, 145, 136, 120, 49, 126, 234, 42, 218) // \'break\' outside loop
TRANSLATION("'continue' outside loop", 23, 197, 37, 72, 52, 184, 177, 126, 234, 42, 218) // \'continue\' outside loop
TRANSLATION("'coroutine' object is not an iterator", 37, 197, 37, 101, 186, 13, 11, 23, 55, 83, 204, 40, 7, 4, 195, 10, 192) // \'coroutine\' object is not an iterator
TRANSLATION("'return' outside function", 25, 196, 197, 23, 50, 98, 253, 222, 80) // \'return\' outside function
TRANSLATION("'yield from' inside async function", 34, 197, 121, 149, 38, 21, 50, 217, 136, 13, 28, 230, 64, 47, 122, 72, 60, 160) // \'yield from\' inside async function
TRANSLATION("'yield' outside function", 24, 197, 121, 149, 39, 139, 247, 121, 64) // \'yield\' outside function
TRANSLATION("*x must be assignment target", 28, 253, 250, 48, 11, 185, 214, 150, 18, 64, 64, 181, 101, 0) // *x must be assignment target
TRANSLATION(", in %q\n", 9, 215, 229, 97, 225, 227, 241, 128) // , in %q\r\n
TRANSLATION("0.0 to a complex power", 22, 217, 199, 179, 172, 33, 37, 178, 218, 22, 128, 181, 115, 147, 0) // 0.0 to a complex power
TRANSLATION("64 bit types", 12, 248, 63, 128, 100, 56, 232, 184) // 64 bit types
TRANSLATION("Adapter not enabled", 19, 236, 76, 109, 130, 109, 82, 79, 20, 192) // Adapter not enabled
TRANSLATION("Address must be %d bytes long", 29, 236, 78, 108, 78, 248, 48, 207, 208, 112, 162, 165, 96) // Address must be %d bytes long
TRANSLATION("Address type out of range", 25, 236, 78, 108, 78, 253, 31, 87, 242) // Address type out of range
TRANSLATION("All timers for this pin are in use", 34, 236, 82, 158, 219, 62, 156, 101, 55, 232, 0, 177, 114, 174, 114) // All timers for this pin are in use
TRANSLATION("All timers in use", 17, 236, 82, 158, 219, 63, 42, 231, 32) // All timers in use
TRANSLATION("Already advertising", 19, 236, 81, 136, 103, 120, 12, 243, 19, 65, 185, 165, 96) // Already advertising
TRANSLATION("AnalogOut is only 16 bits. Value must be less than 65536.", 57, 236, 32, 209, 107, 239, 93, 26, 138, 148, 188, 58, 191, 0, 100, 56, 124, 97, 253, 6, 151, 22, 10, 19, 184, 70, 81, 64, 248, 61, 255, 127, 222, 248, 49, 128) // AnalogOut is only 16 bits. Value must be less than 65536.
TRANSLATION("Array must contain halfwords (type 'H')", 39, 236, 51, 13, 254, 156, 149, 32, 77, 3, 40, 210, 172, 234, 211, 112, 233, 69, 246, 144, 98, 249, 113, 116, 192) // Array must contain halfwords (type \'H\')
TRANSLATION("At most %d %q may be specified (not %d)", 39, 236, 64, 88, 175, 1, 134, 97, 135, 132, 44, 27, 195, 33, 123, 37, 48, 233, 121, 176, 207, 166) // At most %d %q may be specified (not %d)
TRANSLATION("Attempted heap allocation when MicroPython VM not running.", 58, 236, 68, 21, 150, 193, 76, 50, 144, 218, 3, 74, 44, 135, 136, 51, 229, 36, 14, 225, 201, 151, 118, 248, 202, 168, 31, 211, 185, 170, 215, 34, 26, 87, 140) // Attempted heap allocation when MicroPython VM not running.
TRANSLATION("Attribute not found", 19, 236, 126, 154, 181, 45, 201, 48) // Attribute not found
TRANSLATION("Attribute not long", 18, 236, 126, 154, 180, 84, 172) // Attribute not long
TRANSLATION("Auto-reload is off.\n", 21, 236, 93, 11, 176, 197, 69, 25, 234, 45, 85, 99, 227, 241, 128) // Auto-reload is off.\r\n
TRANSLATION("Auto-reload is on. Simply save files over USB to run them or enter REPL to disable.\n", 85, 236, 93, 11, 176, 197, 69, 25, 234, 42, 99, 15, 1, 217, 109, 47, 7, 28, 196, 21, 29, 9, 193, 115, 19, 7, 135, 193, 217, 214, 107, 144, 35, 41, 89, 207, 36, 130, 96, 239, 246, 183, 126, 109, 105, 155, 248, 177, 241, 248, 192) // Auto-reload is on. Simply save files over USB to run them or enter REPL to disable.\r\n
TRANSLATION("Below minimum frame rate", 24, 236, 149, 23, 56, 88, 104, 118, 93, 96, 84, 195, 97, 3, 12, 16) // Below minimum frame rate
TRANSLATION("Brightness must be 0-1.0", 24, 236, 177, 215, 150, 16, 157, 240, 108, 236, 117, 113, 236, 128) // Brightness must be 0-1.0
TRANSLATION("Brightness must be between 0 and 255", 36, 236, 177, 215, 150, 16, 157, 240, 100, 40, 206, 68, 129, 179, 201, 235, 123, 254, 248) // Brightness must be between 0 and 255
TRANSLATION("Brightness not adjustable", 25, 236, 177, 215, 150, 16, 157, 245, 70, 127, 117, 207, 30, 32) // Brightness not adjustable
TRANSLATION("Buffer + offset too small %d %d %d", 34, 254, 33, 255, 144, 90, 170, 114, 128, 133, 80, 123, 6, 148, 12, 51, 12, 51, 12, 51) // Buffer + offset too small %d %d %d
TRANSLATION("Buffer is not a bytearray.", 26, 254, 58, 158, 97, 244, 60, 152, 192) // Buffer is not a bytearray.
TRANSLATION("Buffer is too small", 19, 254, 58, 144, 170, 15, 96, 210, 128) // Buffer is too small
TRANSLATION("Buffer length must be a multiple of 512", 39, 254, 60, 204, 2, 31, 227, 157, 239, 245, 122, 192) // Buffer length must be a multiple of 512
TRANSLATION("Buffer must be at least length 1", 32, 254, 56, 6, 2, 132, 47, 28, 192, 234, 128) // Buffer must be at least length 1
TRANSLATION("Buffer too large and unable to allocate", 39, 254, 33, 10, 161, 65, 106, 203, 147, 114, 120, 181, 134, 148, 89, 12, 16) // Buffer too large and unable to allocate
TRANSLATION("Buffer too short by %d bytes", 28, 254, 33, 10, 160, 249, 85, 160, 50, 94, 24, 103, 232, 56) // Buffer too short by %d bytes
TRANSLATION("Byte buffer must be 16 bytes.", 29, 236, 223, 4, 31, 70, 14, 175, 193, 232, 62, 48) // Byte buffer must be 16 bytes.
TRANSLATION("Call super().__init__() before accessing native object.", 55, 218, 26, 80, 30, 235, 73, 186, 93, 60, 123, 251, 230, 135, 27, 251, 253, 46, 152, 100, 42, 149, 136, 6, 82, 39, 115, 74, 193, 6, 15, 49, 115, 113, 128) // Call super().__init__() before accessing native object.
TRANSLATION("Can't set CCCD on local Characteristic", 38, 218, 20, 197, 0, 229, 1, 181, 181, 181, 182, 10, 129, 69, 144, 208, 54, 190, 195, 120, 57, 0) // Can\'t set CCCD on local Characteristic
TRANSLATION("Cannot delete values", 20, 218, 241, 204, 168, 80, 94, 227, 128) // Cannot delete values
TRANSLATION("Cannot have scan responses for extended, connectable advertisements.", 68, 218, 241, 229, 28, 196, 15, 33, 64, 98, 123, 85, 28, 159, 76, 180, 65, 36, 202, 122, 225, 37, 68, 41, 71, 136, 6, 121, 137, 160, 220, 172, 36, 135, 198) // Cannot have scan responses for extended, connectable advertisements.
TRANSLATION("Cannot read without MISO pin.", 29, 218, 241, 177, 12, 195, 57, 198, 85, 186, 3, 185, 185, 224, 239, 116, 49, 128) // Cannot read without MISO pin.
TRANSLATION("Cannot remount '/' when USB is active.", 38, 218, 241, 177, 88, 183, 36, 6, 46, 166, 32, 207, 148, 144, 60, 62, 14, 206, 160, 202, 15, 49, 99) // Cannot remount \'/\' when USB is active.
TRANSLATION("Cannot set value when direction is input.", 41, 218, 241, 185, 71, 184, 25, 242, 146, 4, 205, 138, 92, 90, 159, 110, 48) // Cannot set value when direction is input.
TRANSLATION("Cannot subclass slice", 21, 218, 241, 189, 217, 37, 65, 119, 7, 161, 200, 128) // Cannot subclass slice
TRANSLATION("Cannot transfer without MOSI and MISO pins.", 43, 218, 241, 195, 10, 61, 68, 193, 156, 227, 42, 221, 1, 220, 239, 120, 55, 57, 61, 205, 207, 7, 123, 160, 248, 192) // Cannot transfer without MOSI and MISO pins.
TRANSLATION("Cannot vary frequency on a timer that is already in use", 55, 218, 241, 230, 22, 188, 42, 111, 174, 240, 84, 1, 246, 216, 35, 40, 198, 160, 209, 136, 103, 127, 42, 231, 32) // Cannot vary frequency on a timer that is already in use
TRANSLATION("Cannot write without MOSI pin.", 30, 218, 241, 231, 99, 130, 12, 231, 25, 86, 232, 14, 231, 123, 193, 185, 208, 198) // Cannot write without MOSI pin.
TRANSLATION("Characteristic can only be added to most recently added service", 63, 218, 251, 13, 224, 228, 18, 20, 5, 74, 94, 25, 8, 6, 115, 41, 235, 88, 175, 0, 197, 34, 72, 165, 224, 51, 153, 76, 28, 155, 49, 200, 128) // Characteristic can only be added to most recently added service
TRANSLATION("Characteristic not writable", 27, 218, 251, 13, 224, 229, 171, 157, 142, 60, 64) // Characteristic not writable
TRANSLATION("CharacteristicBuffer writing not provided", 41, 218, 251, 13, 224, 229, 252, 67, 59, 28, 26, 87, 171, 107, 46, 99, 153, 76) // CharacteristicBuffer writing not provided
TRANSLATION("CircuitPython core code crashed hard. Whoops!\n", 47, 218, 54, 149, 199, 27, 183, 198, 85, 64, 146, 177, 4, 150, 100, 18, 97, 124, 165, 48, 202, 45, 60, 97, 243, 229, 85, 181, 255, 211, 143, 198) // CircuitPython core code crashed hard. Whoops!\r\n
TRANSLATION("CircuitPython is in safe mode because you pressed the reset button during boot. Press again to exit safe mode.\n", 112, 218, 54, 149, 199, 27, 183, 198, 85, 77, 67, 64, 113, 168, 130, 197, 153, 6, 66, 144, 220, 228, 23, 173, 193, 107, 19, 185, 79, 218, 98, 114, 128, 201, 116, 66, 160, 78, 230, 52, 172, 50, 42, 198, 48, 221, 98, 119, 1, 172, 77, 53, 139, 65, 192, 56, 212, 65, 98, 204, 177, 241, 248, 192) // CircuitPython is in safe mode because you pressed the reset button during boot. Press again to exit safe mode.\r\n
TRANSLATION("CircuitPython was unable to allocate the heap.\n", 48, 218, 54, 149, 199, 27, 183, 198, 85, 64, 206, 46, 23, 39, 139, 88, 105, 69, 144, 193, 123, 89, 72, 109, 199, 199, 227, 0) // CircuitPython was unable to allocate the heap.\r\n
TRANSLATION("Clock pin init failed.", 22, 218, 162, 203, 131, 160, 6, 135, 1, 80, 157, 10, 120, 192) // Clock pin init failed.
TRANSLATION("Clock stretch too long", 22, 218, 162, 203, 128, 30, 24, 162, 89, 66, 21, 66, 138, 149, 128) // Clock stretch too long
TRANSLATION("Command must be an int between 0 and 255", 40, 218, 91, 44, 20, 158, 1, 78, 88, 100, 40, 206, 68, 129, 179, 201, 235, 123, 254, 248) // Command must be an int between 0 and 255
TRANSLATION("Connection has been disconnected and can no longer be used. Create a new connection.", 84, 218, 84, 66, 151, 16, 101, 23, 12, 132, 72, 19, 55, 146, 162, 20, 160, 167, 201, 144, 160, 34, 133, 21, 43, 38, 12, 132, 23, 57, 79, 24, 109, 49, 12, 16, 8, 33, 103, 9, 42, 33, 75, 139, 24) // Connection has been disconnected and can no longer be used. Create a new connection.
TRANSLATION("Corrupt .mpy file", 17, 218, 86, 107, 173, 128, 199, 101, 183, 133, 71, 66) // Corrupt .mpy file
TRANSLATION("Corrupt raw code", 16, 218, 86, 107, 173, 128, 97, 206, 18, 89, 144) // Corrupt raw code
TRANSLATION("Could not get max advertising length", 36, 248, 245, 107, 40, 11, 7, 64, 12, 243, 19, 65, 185, 165, 124, 192) // Could not get max advertising length
TRANSLATION("Could not initialize channel", 28, 248, 245, 77, 14, 12, 104, 127, 177, 4, 178, 138, 33, 80) // Could not initialize channel
TRANSLATION("Could not initialize timer", 26, 248, 245, 77, 14, 12, 104, 127, 177, 123, 108) // Could not initialize timer
TRANSLATION("Could not re-init channel", 25, 248, 245, 88, 182, 13, 14, 2, 89, 69, 16, 168) // Could not re-init channel
TRANSLATION("Could not re-init timer", 23, 248, 245, 88, 182, 13, 14, 61, 182) // Could not re-init timer
TRANSLATION("Could not read BLE buffer info", 30, 248, 245, 88, 134, 97, 217, 249, 187, 65, 244, 1, 165, 74) // Could not read BLE buffer info
TRANSLATION("Could not read BLE features", 27, 248, 245, 88, 134, 97, 217, 249, 187, 65, 81, 12, 92, 196, 224) // Could not read BLE features
TRANSLATION("Could not read HCI version", 26, 248, 245, 88, 134, 97, 242, 237, 110, 6, 98, 103, 53, 64) // Could not read HCI version
TRANSLATION("Could not restart PWM", 21, 248, 245, 88, 158, 5, 160, 55, 126, 126, 224) // Could not restart PWM
TRANSLATION("Could not set address", 21, 248, 245, 92, 160, 6, 115, 98, 119) // Could not set address
TRANSLATION("Could not set event mask", 24, 248, 245, 92, 160, 11, 49, 36, 5, 130, 252, 0) // Could not set event mask
TRANSLATION("Could not start PWM", 19, 248, 245, 94, 5, 160, 55, 126, 126, 224) // Could not start PWM
TRANSLATION("Could not start interrupt, RX busy", 34, 248, 245, 94, 5, 163, 150, 76, 215, 91, 26, 225, 223, 254, 161, 146, 231, 188) // Could not start interrupt, RX busy
TRANSLATION("Crash into the HardFault_Handler.", 33, 218, 97, 124, 188, 181, 246, 190, 81, 105, 252, 131, 117, 35, 127, 229, 20, 157, 9, 177, 128) // Crash into the HardFault_Handler.
TRANSLATION("DAC Channel Init Error", 22, 219, 236, 109, 6, 214, 81, 68, 42, 7, 243, 96) // DAC Channel Init Error
TRANSLATION("DAC Device Init Error", 21, 219, 236, 109, 6, 217, 102, 57, 16, 127, 54) // DAC Device Init Error
TRANSLATION("DB out of sync", 14, 219, 236, 250, 175, 122, 72) // DB out of sync
TRANSLATION("Data length needs extended advertising, but this adapter does not support it", 76, 219, 24, 30, 96, 33, 20, 220, 11, 68, 18, 76, 166, 3, 60, 196, 208, 110, 105, 94, 184, 100, 186, 2, 50, 155, 128, 204, 109, 130, 96, 154, 147, 234, 189, 214, 218, 173, 0, 112) // Data length needs extended advertising, but this adapter does not support it
TRANSLATION("Data too large for advertisement packet", 39, 219, 24, 16, 133, 80, 160, 181, 101, 166, 51, 204, 77, 6, 229, 97, 36, 5, 163, 46, 2, 128) // Data too large for advertisement packet
TRANSLATION("Descriptor can only be added to most recently added characteristic", 66, 219, 39, 147, 29, 176, 172, 18, 20, 5, 74, 94, 25, 8, 6, 115, 41, 235, 88, 175, 0, 197, 34, 72, 165, 224, 51, 153, 76, 37, 246, 27, 193, 200) // Descriptor can only be added to most recently added characteristic
TRANSLATION("Display must have a 16 bit colorspace.", 38, 219, 55, 182, 131, 127, 167, 148, 115, 16, 8, 117, 126, 0, 200, 112, 18, 90, 43, 61, 163, 34, 198) // Display must have a 16 bit colorspace.
TRANSLATION("Display rotation must be in 90 degree increments", 48, 219, 55, 182, 131, 120, 50, 192, 241, 96, 52, 15, 247, 217, 9, 149, 108, 68, 6, 146, 98, 176, 146, 28) // Display rotation must be in 90 degree increments
TRANSLATION("Drive mode not used when direction is input.", 44, 219, 99, 204, 65, 98, 204, 181, 110, 114, 152, 103, 202, 72, 19, 54, 41, 113, 106, 125, 184, 192) // Drive mode not used when direction is input.
TRANSLATION("Encryption key size", 19, 237, 36, 154, 251, 120, 131, 128, 175, 246, 0) // Encryption key size
TRANSLATION("Error in ATT protocol code", 26, 237, 51, 43, 114, 187, 27, 219, 193, 107, 44, 44, 150, 129, 37, 153, 0) // Error in ATT protocol code
TRANSLATION("Error in regex", 14, 237, 51, 43, 114, 152, 171, 45, 0) // Error in regex
TRANSLATION("Error reading from HCI adapter", 30, 237, 51, 43, 3, 16, 204, 210, 176, 169, 150, 192, 249, 118, 183, 0, 102, 54, 193, 48) // Error reading from HCI adapter
TRANSLATION("Error writing to HCI adapter", 28, 237, 51, 43, 6, 118, 56, 52, 175, 91, 229, 218, 220, 1, 152, 219, 4, 192) // Error writing to HCI adapter
TRANSLATION("Expected a %q", 13, 237, 126, 162, 24, 120, 64) // Expected a %q
TRANSLATION("Expected a Characteristic", 25, 237, 126, 162, 27, 95, 97, 188, 28, 128) // Expected a Characteristic
TRANSLATION("Expected a DigitalInOut", 23, 237, 126, 162, 27, 103, 89, 192, 211, 113, 59, 215, 64) // Expected a DigitalInOut
TRANSLATION("Expected a Service", 18, 237, 126, 162, 30, 2, 108, 199, 34) // Expected a Service
TRANSLATION("Expected a UART", 15, 237, 126, 162, 30, 30, 199, 127, 120) // Expected a UART
TRANSLATION("Expected a UUID", 15, 237, 126, 162, 30, 31, 14, 230, 216) // Expected a UUID
TRANSLATION("Expected an Address", 19, 237, 126, 162, 129, 216, 156, 216, 157, 192) // Expected an Address
TRANSLATION("Expected tuple of length %d, got %d", 35, 237, 126, 177, 117, 180, 46, 119, 224, 24, 103, 174, 21, 172, 6, 25, 128) // Expected tuple of length %d, got %d
TRANSLATION("Extended advertisements with scan response not supported.", 57, 237, 104, 130, 73, 148, 192, 103, 152, 154, 13, 202, 194, 72, 127, 117, 228, 40, 12, 79, 106, 163, 150, 175, 159, 24) // Extended advertisements with scan response not supported.
TRANSLATION("FFT is defined for ndarrays only", 32, 249, 62, 77, 237, 79, 171, 77, 39, 228, 112, 84, 165, 224) // FFT is defined for ndarrays only
TRANSLATION("FFT is implemented for linear arrays only", 41, 249, 62, 77, 237, 67, 178, 218, 21, 132, 144, 83, 211, 161, 161, 11, 7, 145, 193, 82, 151, 128) // FFT is implemented for linear arrays only
TRANSLATION("Failed to add service", 21, 249, 4, 232, 83, 214, 25, 204, 28, 155, 49, 200, 128) // Failed to add service
TRANSLATION("Failed to allocate RX buffer of %d bytes", 40, 249, 4, 232, 83, 214, 26, 81, 100, 48, 65, 223, 254, 161, 244, 115, 176, 207, 208, 112) // Failed to allocate RX buffer of %d bytes
TRANSLATION("Failed to connect: internal error", 33, 249, 4, 232, 83, 214, 146, 162, 20, 163, 175, 203, 38, 65, 167, 162) // Failed to connect: internal error
TRANSLATION("Failed to write internal flash.", 31, 249, 4, 232, 83, 214, 206, 199, 5, 203, 38, 65, 160, 85, 65, 124, 184, 192) // Failed to write internal flash.
TRANSLATION("File exists", 11, 249, 14, 132, 5, 160, 222, 28) // File exists
TRANSLATION("Framebuffer requires %d bytes", 29, 249, 24, 108, 47, 163, 214, 112, 195, 63, 65, 192) // Framebuffer requires %d bytes
TRANSLATION("Frequency must match existing PWMOut using this timer", 53, 249, 27, 235, 191, 211, 176, 98, 89, 64, 180, 27, 193, 165, 97, 187, 243, 247, 59, 215, 64, 92, 230, 149, 132, 101, 55, 246, 216) // Frequency must match existing PWMOut using this timer
TRANSLATION("Function requires lock", 22, 249, 46, 73, 113, 122, 206, 20, 89, 112, 0) // Function requires lock
TRANSLATION("Group already used", 18, 254, 76, 183, 90, 3, 70, 33, 157, 225, 115, 148, 192) // Group already used
TRANSLATION("HCI packet size mismatch", 24, 249, 118, 183, 2, 209, 151, 1, 71, 176, 22, 27, 216, 49, 44, 160) // HCI packet size mismatch
TRANSLATION("HCI status error: %02x", 22, 249, 118, 183, 1, 224, 98, 231, 244, 122, 225, 135, 103, 173, 160) // HCI status error: %02x
TRANSLATION("Hardware busy, try alternative pins", 35, 249, 69, 167, 156, 88, 131, 37, 207, 126, 184, 67, 94, 3, 72, 38, 65, 131, 204, 93, 7) // Hardware busy, try alternative pins
TRANSLATION("Hardware in use, try alternative pins", 37, 249, 69, 167, 156, 88, 185, 87, 57, 107, 132, 53, 224, 52, 130, 100, 24, 60, 197, 208, 112) // Hardware in use, try alternative pins
TRANSLATION("I/O operation on closed file", 28, 220, 234, 119, 129, 109, 38, 30, 32, 84, 9, 81, 92, 166, 21, 29, 8) // I/O operation on closed file
TRANSLATION("I2C Init Error", 14, 220, 235, 109, 7, 243, 96) // I2C Init Error
TRANSLATION("Incompatible .mpy file. Please update all .mpy files. See http://adafru.it/mpy-update for more info.", 100, 220, 73, 45, 150, 140, 30, 74, 16, 99, 178, 219, 194, 163, 161, 99, 13, 218, 16, 185, 5, 214, 204, 96, 128, 105, 64, 199, 101, 183, 133, 71, 66, 124, 97, 224, 34, 12, 177, 22, 245, 250, 157, 65, 152, 212, 215, 99, 56, 234, 89, 109, 251, 23, 91, 49, 130, 211, 177, 88, 128, 210, 165, 198) // Incompatible .mpy file. Please update all .mpy files. See http://adafru.it/mpy-update for more info.
TRANSLATION("Input/output error", 18, 220, 75, 110, 142, 162, 221, 22, 221, 30, 136) // Input/output error
TRANSLATION("Insufficient authentication", 27, 220, 71, 186, 170, 142, 70, 73, 0, 55, 70, 82, 72, 57, 15, 16) // Insufficient authentication
TRANSLATION("Insufficient encryption", 23, 220, 71, 186, 170, 142, 70, 73, 0, 73, 38, 190, 222, 32) // Insufficient encryption
TRANSLATION("Insufficient resources", 22, 220, 71, 186, 170, 142, 70, 73, 0, 196, 235, 115, 72, 156) // Insufficient resources
TRANSLATION("Internal define error", 21, 220, 72, 38, 65, 160, 76, 170, 52, 47, 68) // Internal define error
TRANSLATION("Invalid %q pin selection", 24, 237, 225, 225, 232, 3, 149, 10, 92, 64) // Invalid %q pin selection
TRANSLATION("Invalid ADC Unit value", 22, 237, 246, 54, 246, 131, 194, 135, 30, 224) // Invalid ADC Unit value
TRANSLATION("Invalid BLE attribute", 21, 237, 246, 126, 110, 208, 15, 232) // Invalid BLE attribute
TRANSLATION("Invalid BMP file", 16, 237, 246, 123, 155, 161, 81, 208, 128) // Invalid BMP file
TRANSLATION("Invalid DAC pin supplied", 24, 237, 237, 246, 54, 186, 0, 247, 91, 109, 12, 166) // Invalid DAC pin supplied
TRANSLATION("Invalid PDU", 11, 237, 238, 237, 248, 64) // Invalid PDU
TRANSLATION("Invalid PWM frequency", 21, 237, 238, 252, 253, 192, 169, 190, 187, 192) // Invalid PWM frequency
TRANSLATION("Invalid argument", 16, 237, 255, 96) // Invalid argument
TRANSLATION("Invalid attribute length", 24, 237, 143, 233, 204) // Invalid attribute length
TRANSLATION("Invalid bits per value", 22, 237, 228, 56, 112, 180, 155, 220) // Invalid bits per value
TRANSLATION("Invalid buffer size", 19, 237, 253, 30, 192) // Invalid buffer size
TRANSLATION("Invalid byteorder string", 24, 237, 228, 190, 9, 90, 100, 193, 249, 128) // Invalid byteorder string
TRANSLATION("Invalid direction.", 18, 237, 204, 216, 165, 197, 140) // Invalid direction.
TRANSLATION("Invalid frequency supplied", 26, 237, 212, 223, 93, 224, 247, 91, 109, 12, 166) // Invalid frequency supplied
TRANSLATION("Invalid handle", 14, 237, 229, 20, 157, 8) // Invalid handle
TRANSLATION("Invalid memory access.", 22, 237, 216, 86, 43, 94, 3, 41, 19, 190, 48) // Invalid memory access.
TRANSLATION("Invalid number of bits", 22, 237, 254, 60, 236, 135, 14) // Invalid number of bits
TRANSLATION("Invalid offset", 14, 237, 173, 85, 57, 64) // Invalid offset
TRANSLATION("Invalid phase", 13, 237, 219, 148, 92, 128) // Invalid phase
TRANSLATION("Invalid pin", 11, 237, 218, 104) // Invalid pin
TRANSLATION("Invalid pins for PWMOut", 23, 237, 218, 104, 250, 123, 191, 63, 115, 189, 116, 0) // Invalid pins for PWMOut
TRANSLATION("Invalid polarity", 16, 237, 218, 180, 22, 56, 188) // Invalid polarity
TRANSLATION("Invalid properties", 18, 237, 218, 203, 105, 52, 25, 56) // Invalid properties
TRANSLATION("Invalid run mode.", 17, 237, 181, 200, 22, 44, 203, 24) // Invalid run mode.
TRANSLATION("Invalid security_mode", 21, 237, 185, 74, 230, 56, 191, 126, 197, 153, 0) // Invalid security_mode
TRANSLATION("Invalid word/bit length", 23, 237, 231, 86, 159, 83, 33, 199, 48) // Invalid word/bit length
TRANSLATION("LHS of keyword arg must be an id", 32, 249, 190, 95, 7, 59, 239, 1, 106, 240, 10, 1, 204) // LHS of keyword arg must be an id
TRANSLATION("Layer already in a group.", 25, 249, 134, 242, 96, 26, 49, 12, 239, 229, 8, 86, 203, 117, 184, 192) // Layer already in a group.
TRANSLATION("Layer must be a Group or TileGrid subclass.", 43, 249, 134, 242, 108, 2, 31, 201, 150, 235, 121, 251, 199, 66, 254, 76, 115, 7, 187, 36, 168, 46, 248, 192) // Layer must be a Group or TileGrid subclass.
TRANSLATION("Length must be an int", 21, 249, 137, 43, 140, 184, 5, 57, 96) // Length must be an int
TRANSLATION("Length must be non-negative", 27, 249, 137, 43, 140, 184, 17, 83, 97, 10, 177, 131, 204, 64) // Length must be non-negative
TRANSLATION("MISO pin init failed.", 21, 238, 110, 120, 59, 221, 0, 52, 56, 10, 132, 232, 83, 198) // MISO pin init failed.
TRANSLATION("MOSI pin init failed.", 21, 238, 119, 188, 27, 157, 0, 52, 56, 10, 132, 232, 83, 198) // MOSI pin init failed.
TRANSLATION("Maximum x value when mirrored is %d", 35, 238, 14, 131, 178, 235, 3, 71, 184, 25, 242, 146, 5, 134, 204, 172, 83, 212, 195, 48) // Maximum x value when mirrored is %d
TRANSLATION("MicroPython NLR jump failed. Likely memory corruption.", 54, 238, 28, 153, 119, 111, 140, 170, 129, 221, 249, 187, 225, 247, 93, 101, 161, 80, 157, 10, 120, 195, 230, 62, 2, 165, 225, 97, 88, 173, 120, 73, 89, 174, 183, 139, 24) // MicroPython NLR jump failed. Likely memory corruption.
TRANSLATION("MicroPython fatal error.", 24, 238, 28, 153, 119, 111, 140, 170, 129, 80, 192, 211, 209, 198) // MicroPython fatal error.
TRANSLATION("Missing MISO or MOSI Pin", 24, 238, 27, 185, 165, 97, 220, 220, 240, 119, 185, 253, 206, 247, 131, 112, 55, 77, 0) // Missing MISO or MOSI Pin
TRANSLATION("Must be a %q subclass.", 22, 238, 92, 240, 25, 8, 4, 48, 240, 131, 221, 146, 84, 23, 124, 96) // Must be a %q subclass.
TRANSLATION("Must provide MISO or MOSI pin", 29, 238, 92, 240, 22, 178, 230, 57, 144, 119, 55, 60, 29, 238, 127, 115, 189, 224, 220, 232, 0) // Must provide MISO or MOSI pin
TRANSLATION("Name too long", 13, 238, 141, 132, 16, 170, 20, 84, 172) // Name too long
TRANSLATION("No CCCD for this Characteristic", 31, 238, 168, 109, 109, 109, 109, 233, 198, 83, 112, 218, 251, 13, 224, 228) // No CCCD for this Characteristic
TRANSLATION("No I2C device at address: %x", 28, 238, 168, 110, 117, 182, 130, 101, 152, 228, 64, 48, 3, 57, 177, 59, 245, 195, 14, 128) // No I2C device at address: %x
TRANSLATION("No MISO Pin", 11, 238, 168, 119, 55, 60, 29, 224, 221, 52) // No MISO Pin
TRANSLATION("No MOSI Pin", 11, 238, 168, 119, 59, 222, 13, 192, 221, 52) // No MOSI Pin
TRANSLATION("No RX pin", 9, 238, 168, 119, 255, 175, 64) // No RX pin
TRANSLATION("No TX pin", 9, 238, 168, 111, 127, 94, 128) // No TX pin
TRANSLATION("No connection: length cannot be determined", 42, 238, 168, 73, 81, 10, 92, 93, 126, 96, 75, 199, 144, 130, 101, 4, 214, 26, 20, 192) // No connection: length cannot be determined
TRANSLATION("No default %q bus", 17, 238, 168, 76, 170, 27, 169, 1, 135, 132, 50, 92, 224) // No default %q bus
TRANSLATION("No hardware random available", 28, 238, 168, 101, 22, 158, 113, 98, 6, 20, 154, 216, 3, 152, 78, 158, 32) // No hardware random available
TRANSLATION("No more timers available on this pin.", 37, 238, 168, 88, 172, 94, 219, 56, 14, 97, 58, 120, 129, 80, 35, 41, 191, 67, 24) // No more timers available on this pin.
TRANSLATION("No pulldown on pin; 1Mohm recommended", 37, 238, 168, 91, 117, 41, 53, 206, 128, 169, 208, 255, 216, 117, 123, 139, 150, 192, 98, 146, 217, 97, 36, 202, 96) // No pulldown on pin; 1Mohm recommended
TRANSLATION("No space left on device", 23, 238, 168, 61, 163, 34, 10, 21, 80, 10, 129, 50, 204, 114, 32) // No space left on device
TRANSLATION("No such file/directory", 22, 238, 168, 61, 210, 202, 21, 29, 11, 169, 51, 98, 148, 43, 94) // No such file/directory
TRANSLATION("Not connected", 13, 238, 172, 4, 149, 16, 165, 5, 48) // Not connected
TRANSLATION("Not running saved code.\n", 25, 238, 172, 3, 92, 136, 105, 88, 56, 230, 41, 132, 150, 101, 143, 143, 198) // Not running saved code.\r\n
TRANSLATION("Not supported", 13, 238, 172, 7, 156) // Not supported
TRANSLATION("Object has been deinitialized and can no longer be used. Create a new object.", 77, 239, 100, 251, 138, 80, 25, 69, 195, 33, 18, 4, 200, 208, 224, 198, 135, 251, 20, 249, 50, 20, 4, 80, 162, 165, 100, 193, 144, 130, 231, 41, 227, 13, 166, 33, 130, 1, 4, 44, 252, 220, 96) // Object has been deinitialized and can no longer be used. Create a new object.
TRANSLATION("Only Windows format, uncompressed BMP supported: given header size is %d", 72, 239, 37, 47, 15, 156, 210, 107, 157, 253, 45, 112, 185, 36, 182, 90, 196, 238, 83, 14, 207, 115, 116, 60, 253, 112, 172, 243, 18, 6, 82, 25, 147, 123, 26, 152, 102) // Only Windows format, uncompressed BMP supported: given header size is %d
TRANSLATION("Only monochrome, indexed 4bpp or 8bpp, and 16bpp or greater BMPs supported: %d bpp given", 88, 239, 37, 47, 11, 21, 22, 89, 89, 108, 45, 112, 52, 153, 104, 41, 135, 240, 201, 109, 188, 255, 246, 201, 109, 186, 252, 158, 175, 193, 146, 219, 121, 245, 177, 12, 19, 7, 103, 185, 186, 225, 231, 235, 134, 25, 134, 75, 109, 10, 207, 49, 32) // Only monochrome, indexed 4bpp or 8bpp, and 16bpp or greater BMPs supported: %d bpp given
TRANSLATION("Only one color can be transparent at a time", 43, 239, 37, 47, 5, 66, 9, 45, 21, 130, 66, 129, 144, 130, 24, 81, 237, 22, 36, 128, 24, 1, 246, 192) // Only one color can be transparent at a time
TRANSLATION("PWM duty_cycle must be between 0 and 65535 inclusive (16 bit resolution)", 72, 221, 249, 251, 129, 59, 162, 253, 249, 95, 42, 22, 12, 133, 25, 200, 144, 54, 121, 63, 7, 191, 239, 251, 222, 248, 26, 74, 151, 57, 230, 32, 233, 117, 126, 0, 200, 112, 12, 78, 180, 187, 139, 166) // PWM duty_cycle must be between 0 and 65535 inclusive (16 bit resolution)
TRANSLATION("ParallelBus not yet supported", 29, 221, 22, 26, 80, 169, 217, 185, 245, 111, 40, 15, 56) // ParallelBus not yet supported
TRANSLATION("Permission denied", 17, 221, 38, 176, 221, 205, 80, 38, 72, 101, 48) // Permission denied
TRANSLATION("Pin does not have ADC capabilities", 34, 221, 52, 9, 169, 62, 174, 81, 204, 65, 216, 219, 218, 9, 13, 163, 144, 232, 112, 100, 224) // Pin does not have ADC capabilities
TRANSLATION("Pin is input only", 17, 221, 52, 212, 251, 65, 82, 151, 128) // Pin is input only
TRANSLATION("Pin number already reserved by EXTI", 35, 221, 52, 15, 196, 6, 140, 67, 59, 193, 137, 201, 179, 20, 195, 37, 225, 218, 254, 187, 219, 128) // Pin number already reserved by EXTI
TRANSLATION("Plus any modules on the filesystem\n", 36, 221, 165, 206, 2, 151, 133, 139, 59, 168, 78, 10, 158, 213, 71, 66, 123, 222, 10, 206, 63, 24) // Plus any modules on the filesystem\r\n
TRANSLATION("Polygon needs at least 3 points", 31, 221, 90, 95, 90, 160, 33, 20, 220, 6, 2, 132, 47, 1, 239, 5, 170, 105, 14) // Polygon needs at least 3 points
TRANSLATION("Port does not accept pins or frequency. Construct and pass a PWMOut Carrier instead", 83, 221, 86, 128, 154, 147, 234, 140, 164, 86, 199, 65, 249, 245, 55, 215, 126, 48, 218, 84, 120, 107, 165, 28, 155, 69, 220, 4, 55, 126, 126, 231, 122, 232, 13, 161, 102, 50, 96, 52, 120, 33, 152) // Port does not accept pins or frequency. Construct and pass a PWMOut Carrier instead
TRANSLATION("Prefix buffer must be on the heap", 33, 221, 98, 168, 244, 7, 209, 129, 83, 218, 202, 67, 104) // Prefix buffer must be on the heap
TRANSLATION("Prepare queue full", 18, 221, 98, 180, 88, 131, 134, 226, 184, 130, 171, 169, 64) // Prepare queue full
TRANSLATION("Press any key to enter the REPL. Use CTRL-D to reload.\n", 56, 221, 98, 119, 1, 75, 195, 128, 175, 214, 36, 130, 111, 107, 191, 218, 221, 249, 177, 135, 133, 200, 54, 183, 187, 255, 54, 198, 222, 179, 21, 20, 103, 143, 143, 198) // Press any key to enter the REPL. Use CTRL-D to reload.\r\n
TRANSLATION("Pull not used when direction is output.", 39, 221, 186, 148, 213, 185, 202, 97, 159, 41, 32, 76, 216, 165, 197, 168, 183, 69, 183, 70, 48) // Pull not used when direction is output.
TRANSLATION("RNG DeInit Error", 16, 239, 247, 127, 144, 109, 151, 243, 96) // RNG DeInit Error
TRANSLATION("RNG Init Error", 14, 239, 247, 127, 144, 127, 54) // RNG Init Error
TRANSLATION("RTC is not supported on this board", 34, 239, 239, 109, 106, 121, 188, 224, 168, 17, 148, 220, 50, 40, 180, 192) // RTC is not supported on this board
TRANSLATION("RTS/CTS/RS485 Not yet supported on this device", 46, 239, 239, 120, 58, 155, 91, 222, 14, 167, 127, 193, 252, 63, 219, 223, 14, 234, 192, 94, 80, 30, 112, 84, 8, 202, 110, 19, 44, 199, 34) // RTS/CTS/RS485 Not yet supported on this device
TRANSLATION("Random number generation error", 30, 239, 138, 77, 108, 15, 196, 43, 36, 38, 30, 47, 68) // Random number generation error
TRANSLATION("Read not permitted", 18, 239, 144, 207, 86, 210, 107, 14, 32, 166) // Read not permitted
TRANSLATION("Read-only", 9, 239, 144, 207, 97, 82, 151, 128) // Read-only
TRANSLATION("Read-only filesystem", 20, 239, 144, 207, 97, 82, 151, 133, 71, 66, 123, 222, 10, 192) // Read-only filesystem
TRANSLATION("Read-only object", 16, 239, 144, 207, 97, 82, 151, 243, 64) // Read-only object
TRANSLATION("Refresh too soon", 16, 239, 149, 76, 79, 148, 33, 84, 29, 85, 0) // Refresh too soon
TRANSLATION("Running in safe mode! ", 22, 239, 220, 136, 105, 95, 41, 198, 162, 11, 22, 101, 254, 128) // Running in safe mode! 
TRANSLATION("SD card CSD format not supported", 32, 240, 109, 132, 133, 166, 27, 94, 13, 191, 75, 87, 206) // SD card CSD format not supported
TRANSLATION("SPI Init Error", 14, 240, 110, 238, 7, 243, 96) // SPI Init Error
TRANSLATION("SPI Re-initialization error", 27, 240, 110, 238, 7, 124, 182, 13, 14, 12, 104, 127, 176, 241, 122, 32) // SPI Re-initialization error
TRANSLATION("Scan already in progess. Stop with stop_scan.", 45, 240, 72, 80, 6, 140, 67, 59, 249, 86, 178, 214, 78, 248, 195, 193, 11, 111, 186, 240, 182, 239, 188, 133, 49, 128) // Scan already in progess. Stop with stop_scan.
TRANSLATION("Slices not supported", 20, 240, 80, 228, 79, 171, 231) // Slices not supported
TRANSLATION("Splitting with sub-captures", 27, 240, 91, 67, 136, 52, 175, 221, 123, 178, 108, 72, 109, 139, 152, 156) // Splitting with sub-captures
TRANSLATION("Stack size must be at least 256", 31, 240, 64, 203, 131, 216, 192, 48, 20, 33, 120, 14, 183, 191, 240, 0) // Stack size must be at least 256
TRANSLATION("Supply at least one UART pin", 28, 240, 93, 109, 180, 188, 6, 2, 132, 47, 0, 168, 65, 225, 236, 119, 247, 186, 0) // Supply at least one UART pin
TRANSLATION("Temperature read timed out", 26, 222, 43, 45, 38, 24, 185, 136, 24, 134, 126, 220, 193, 110, 128) // Temperature read timed out
TRANSLATION("The CircuitPython heap was corrupted because the stack was too small.\nPlease increase the stack size if you know how, or if not:", 129, 222, 202, 65, 180, 109, 43, 142, 55, 111, 140, 170, 129, 148, 134, 208, 206, 46, 18, 86, 107, 173, 130, 152, 100, 41, 13, 206, 94, 211, 192, 203, 128, 51, 139, 132, 42, 131, 216, 52, 166, 62, 63, 27, 118, 132, 46, 64, 105, 38, 33, 114, 246, 158, 6, 92, 30, 192, 29, 65, 122, 220, 28, 8, 185, 195, 42, 231, 215, 231, 157, 64, 139, 29, 112) // The CircuitPython heap was corrupted because the stack was too small.\r\nPlease increase the stack size if you know how, or if not:
TRANSLATION("The `microcontroller` module was used to boot into safe mode. Press reset to exit safe mode.\n", 94, 222, 202, 65, 255, 86, 28, 153, 100, 169, 12, 180, 161, 55, 253, 5, 139, 59, 168, 65, 156, 92, 46, 114, 158, 182, 69, 88, 229, 168, 56, 212, 65, 98, 204, 177, 134, 235, 19, 184, 49, 57, 70, 177, 104, 56, 7, 26, 136, 44, 89, 150, 62, 63, 24) // The `microcontroller` module was used to boot into safe mode. Press reset to exit safe mode.\r\n
TRANSLATION("The microcontroller's power dipped. Make sure your power supply provides\nenough power for the whole circuit and press reset (after ejecting CIRCUITPY).\n", 154, 222, 202, 65, 97, 201, 150, 74, 144, 203, 74, 19, 98, 112, 181, 115, 147, 4, 206, 219, 74, 120, 195, 184, 60, 4, 15, 115, 16, 94, 183, 48, 90, 185, 201, 129, 238, 182, 218, 94, 22, 178, 230, 57, 147, 241, 248, 196, 139, 117, 121, 66, 213, 206, 77, 167, 25, 72, 51, 229, 90, 16, 72, 218, 87, 28, 114, 109, 98, 119, 6, 39, 40, 14, 144, 213, 4, 192, 95, 113, 74, 13, 43, 13, 173, 206, 254, 215, 135, 115, 123, 119, 254, 122, 120, 248, 252, 96) // The microcontroller\'s power dipped. Make sure your power supply provides\r\nenough power for the whole circuit and press reset (after ejecting CIRCUITPY).\r\n
TRANSLATION("Tile height must exactly divide bitmap height", 45, 222, 58, 16, 101, 35, 175, 44, 122, 101, 160, 101, 20, 188, 38, 121, 142, 100, 25, 14, 44, 27, 67, 41, 29, 121, 96) // Tile height must exactly divide bitmap height
TRANSLATION("Tile index out of bounds", 24, 222, 58, 16, 26, 76, 180, 122, 185, 22, 228, 155, 128) // Tile index out of bounds
TRANSLATION("Tile value out of bounds", 24, 222, 58, 23, 185, 234, 228, 91, 146, 110) // Tile value out of bounds
TRANSLATION("Tile width must exactly divide bitmap width", 43, 222, 58, 16, 103, 57, 198, 95, 76, 180, 12, 162, 151, 132, 207, 49, 204, 131, 33, 197, 131, 104, 103, 57, 198, 80) // Tile width must exactly divide bitmap width
TRANSLATION("Timeout is too long: Maximum timeout length is %d seconds", 57, 222, 59, 9, 110, 141, 72, 85, 10, 42, 87, 215, 14, 224, 232, 59, 46, 179, 219, 91, 163, 153, 169, 134, 96, 229, 37, 73, 184) // Timeout is too long: Maximum timeout length is %d seconds
TRANSLATION("Timeout waiting for HCI response", 32, 222, 59, 9, 110, 128, 206, 39, 6, 149, 233, 252, 187, 91, 128, 196, 246, 170, 57, 0) // Timeout waiting for HCI response
TRANSLATION("Timeout waiting to write HCI request", 36, 222, 59, 9, 110, 128, 206, 39, 6, 149, 235, 103, 99, 130, 15, 151, 107, 112, 24, 184, 110, 39, 128) // Timeout waiting to write HCI request
TRANSLATION("Timer was reserved for internal use - declare PWM pins earlier in the program", 77, 222, 59, 9, 131, 56, 184, 49, 57, 54, 98, 158, 153, 164, 19, 32, 208, 46, 114, 13, 128, 153, 74, 130, 196, 27, 191, 63, 115, 160, 224, 66, 212, 50, 110, 84, 101, 32, 181, 150, 182, 27, 0) // Timer was reserved for internal use - declare PWM pins earlier in the program
TRANSLATION("Too many Adapters", 17, 222, 255, 33, 216, 152, 219, 4, 206) // Too many Adapters
TRANSLATION("Too many display busses", 23, 222, 255, 33, 51, 123, 104, 55, 134, 75, 157, 201, 192) // Too many display busses
TRANSLATION("Too many displays", 17, 222, 255, 33, 51, 123, 104, 55, 184) // Too many displays
TRANSLATION("Total data to write is larger than outgoing_packet_length", 57, 222, 88, 26, 4, 198, 7, 91, 59, 28, 22, 165, 5, 171, 38, 8, 202, 40, 11, 116, 86, 166, 149, 239, 218, 50, 224, 40, 223, 252, 0) // Total data to write is larger than outgoing_packet_length
TRANSLATION("Traceback (most recent call last):\n", 36, 222, 97, 145, 100, 25, 112, 7, 74, 197, 120, 6, 41, 18, 64, 72, 105, 64, 160, 188, 116, 250, 252, 126, 48) // Traceback (most recent call last):\r\n
TRANSLATION("Tuple or struct_time argument required", 38, 222, 186, 218, 23, 61, 225, 174, 148, 111, 193, 216, 90, 94, 180, 192) // Tuple or struct_time argument required
TRANSLATION("UART Buffer allocation error", 28, 240, 246, 59, 251, 193, 252, 64, 105, 69, 144, 241, 122, 32) // UART Buffer allocation error
TRANSLATION("UART De-init error", 18, 240, 246, 59, 251, 193, 182, 91, 6, 135, 30, 136) // UART De-init error
TRANSLATION("UART Init Error", 15, 240, 246, 59, 251, 193, 252, 216) // UART Init Error
TRANSLATION("UART Re-init error", 18, 240, 246, 59, 251, 193, 223, 45, 131, 67, 143, 68) // UART Re-init error
TRANSLATION("UART write error", 16, 240, 246, 59, 251, 193, 157, 142, 11, 209) // UART write error
TRANSLATION("UUID integer value must be 0-0xffff", 35, 240, 248, 119, 54, 249, 101, 89, 55, 185, 131, 103, 99, 103, 69, 85, 85, 80) // UUID integer value must be 0-0xffff
TRANSLATION("UUID string not 'xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx'", 54, 240, 248, 119, 54, 195, 243, 213, 197, 255, 122, 52, 108, 104, 209, 163, 70, 198, 141, 26, 52, 108, 104, 209, 163, 70, 199, 253, 255, 222, 32) // UUID string not \'xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx\'
TRANSLATION("UUID value is not str, int or byte buffer", 41, 240, 248, 119, 54, 253, 205, 79, 51, 195, 107, 242, 249, 249, 47, 130, 15, 160) // UUID value is not str, int or byte buffer
TRANSLATION("Unable to find I2C Display at %x", 32, 240, 167, 139, 90, 163, 73, 134, 231, 91, 104, 54, 205, 237, 160, 222, 3, 1, 135, 64) // Unable to find I2C Display at %x
TRANSLATION("Unable to init parser", 21, 240, 167, 139, 88, 208, 224, 45, 22, 114, 96) // Unable to init parser
TRANSLATION("Unable to read color palette data", 33, 240, 167, 139, 89, 136, 102, 18, 90, 43, 5, 163, 66, 136, 32, 152, 192, 128) // Unable to read color palette data
TRANSLATION("Unknown ATT error: 0x%02x", 25, 240, 167, 2, 46, 116, 14, 198, 246, 247, 163, 215, 13, 157, 24, 118, 122, 218, 0) // Unknown ATT error: 0x%02x
TRANSLATION("Unknown hci_result_t: %d", 24, 240, 167, 2, 46, 116, 12, 178, 61, 246, 39, 186, 145, 191, 29, 112, 195, 48) // Unknown hci_result_t: %d
TRANSLATION("Unknown reason.", 15, 240, 167, 2, 46, 116, 6, 33, 117, 76, 96) // Unknown reason.
TRANSLATION("Unlikely", 8, 240, 165, 15, 128, 169, 120) // Unlikely
TRANSLATION("Unmatched number of items on RHS (expected %d, got %d).", 55, 240, 165, 131, 18, 202, 83, 15, 199, 156, 112, 86, 56, 42, 7, 127, 229, 240, 7, 72, 191, 92, 51, 215, 10, 214, 3, 12, 250, 120, 192) // Unmatched number of items on RHS (expected %d, got %d).
TRANSLATION("Unsupported display bus type", 28, 240, 167, 156, 38, 111, 109, 6, 240, 201, 115, 244, 64) // Unsupported display bus type
TRANSLATION("Unsupported group type", 22, 240, 167, 156, 43, 101, 186, 222, 136) // Unsupported group type
TRANSLATION("Unsupported operation", 21, 240, 167, 156, 22, 210, 97, 226) // Unsupported operation
TRANSLATION("Unsupported pull value.", 23, 240, 167, 156, 45, 186, 148, 247, 49, 128) // Unsupported pull value.
TRANSLATION("Value length != required fixed length", 37, 254, 131, 75, 139, 152, 31, 233, 240, 250, 211, 10, 143, 65, 79, 152) // Value length != required fixed length
TRANSLATION("Value length > max_length", 25, 254, 131, 75, 139, 152, 31, 16, 88, 58, 55, 255, 0) // Value length > max_length
TRANSLATION("Value not allowed", 17, 254, 131, 75, 139, 84, 105, 69, 206, 83) // Value not allowed
TRANSLATION("Voltage read timed out", 22, 254, 139, 72, 26, 200, 24, 134, 126, 220, 193, 110, 128) // Voltage read timed out
TRANSLATION("WARNING: Your code filename has two extensions\n", 48, 249, 251, 29, 254, 238, 231, 119, 249, 117, 195, 254, 86, 230, 9, 44, 200, 42, 58, 18, 13, 132, 25, 69, 194, 51, 168, 22, 136, 36, 115, 84, 126, 63, 24) // WARNING: Your code filename has two extensions\r\n
TRANSLATION("Watchdog timer expired.", 23, 249, 198, 37, 150, 107, 95, 182, 192, 90, 45, 54, 41, 227) // Watchdog timer expired.
TRANSLATION("Welcome to Adafruit CircuitPython %s!\n\nPlease visit learn.adafruit.com/category/circuitpython for project guides.\n\nTo list built-in modules please do `help(\"modules\")`.\n", 174, 249, 202, 146, 91, 11, 91, 177, 49, 169, 174, 56, 13, 163, 105, 92, 113, 187, 124, 101, 84, 12, 47, 254, 156, 126, 55, 31, 141, 187, 66, 23, 32, 204, 110, 112, 20, 33, 100, 198, 51, 26, 154, 227, 140, 114, 91, 58, 146, 24, 42, 213, 175, 234, 72, 218, 87, 28, 91, 124, 101, 84, 211, 181, 151, 238, 41, 64, 87, 113, 204, 159, 31, 31, 141, 199, 227, 111, 40, 80, 222, 3, 37, 199, 72, 216, 52, 11, 22, 119, 80, 156, 45, 161, 11, 144, 77, 67, 254, 178, 149, 45, 233, 127, 173, 139, 59, 168, 79, 254, 189, 63, 250, 199, 199, 227, 0) // Welcome to Adafruit CircuitPython %s!\r\n\r\nPlease visit learn.adafruit.com/category/circuitpython for project guides.\r\n\r\nTo list built-in modules please do `help(\"modules\")`.\r\n
TRANSLATION("Write not permitted", 19, 249, 216, 224, 181, 109, 38, 176, 226, 10, 96) // Write not permitted
TRANSLATION("Writes not supported on Characteristic", 38, 249, 216, 224, 159, 87, 206, 10, 129, 181, 246, 27, 193, 200) // Writes not supported on Characteristic
TRANSLATION("You are in safe mode: something unanticipated happened.\n", 57, 255, 149, 184, 5, 139, 148, 227, 81, 5, 139, 50, 235, 131, 173, 133, 25, 77, 43, 11, 144, 82, 14, 71, 104, 193, 76, 50, 141, 182, 146, 20, 241, 241, 248, 192) // You are in safe mode: something unanticipated happened.\r\n
TRANSLATION("\nCode done running.\n", 22, 227, 241, 182, 150, 100, 19, 84, 32, 107, 145, 13, 43, 199, 199, 227, 0) // \r\nCode done running.\r\n
TRANSLATION("\nCode stopped by auto-reload.\n", 32, 227, 241, 182, 150, 100, 15, 11, 109, 165, 48, 201, 120, 13, 208, 187, 12, 84, 81, 158, 62, 63, 24) // \r\nCode stopped by auto-reload.\r\n
TRANSLATION("\nPlease file an issue with the contents of your CIRCUITPY drive at \nhttps://github.com/adafruit/circuitpython/issues\n", 120, 227, 241, 183, 104, 66, 228, 21, 29, 8, 5, 0, 221, 238, 47, 118, 50, 144, 73, 82, 9, 33, 249, 215, 173, 204, 27, 91, 157, 253, 175, 14, 230, 246, 239, 252, 132, 216, 243, 16, 12, 7, 31, 141, 150, 34, 215, 235, 245, 58, 149, 156, 101, 187, 38, 57, 45, 157, 65, 152, 212, 215, 28, 117, 36, 109, 43, 142, 45, 190, 50, 170, 117, 13, 222, 226, 126, 63, 24) // \r\nPlease file an issue with the contents of your CIRCUITPY drive at \r\nhttps://github.com/adafruit/circuitpython/issues\r\n
TRANSLATION("__init__() should return None, not '%q'", 39, 223, 223, 52, 56, 223, 223, 233, 116, 193, 242, 173, 212, 152, 49, 69, 204, 129, 221, 84, 45, 125, 92, 88, 120, 113, 0) // __init__() should return None, not \'%q\'
TRANSLATION("__new__ arg must be a user-type", 31, 223, 223, 66, 207, 191, 190, 2, 213, 224, 16, 185, 201, 182, 34, 251, 72) // __new__ arg must be a user-type
TRANSLATION("a bytes-like object is required", 31, 31, 65, 246, 40, 124, 5, 205, 212, 98, 225, 184, 216, 166) // a bytes-like object is required
TRANSLATION("abort() called", 14, 28, 138, 209, 210, 233, 132, 134, 148, 41, 128) // abort() called
TRANSLATION("arg is an empty sequence", 24, 22, 175, 80, 80, 10, 203, 98, 240, 127, 172, 128) // arg is an empty sequence
TRANSLATION("argsort argument must be an ndarray", 35, 22, 173, 213, 163, 75, 0, 167, 168) // argsort argument must be an ndarray
TRANSLATION("argsort is not implemented for flattened arrays", 47, 22, 173, 213, 163, 83, 204, 118, 91, 66, 176, 146, 10, 122, 117, 80, 98, 9, 10, 97, 228, 112) // argsort is not implemented for flattened arrays
TRANSLATION("argument has wrong type", 23, 254, 193, 148, 92, 51, 178, 165, 125, 16) // argument has wrong type
TRANSLATION("argument must be ndarray", 24, 254, 216, 18, 126, 64) // argument must be ndarray
TRANSLATION("argument num/types mismatch", 27, 254, 192, 151, 89, 212, 139, 237, 39, 11, 13, 236, 24, 150, 80) // argument num/types mismatch
TRANSLATION("argument should be a '%q' not a '%q'", 36, 254, 222, 185, 0, 242, 53, 71, 144) // argument should be a \'%q\' not a \'%q\'
TRANSLATION("arguments must be ndarrays", 26, 254, 207, 129, 39, 228, 112) // arguments must be ndarrays
TRANSLATION("array and index length must be equal", 36, 242, 114, 77, 38, 90, 57, 152, 11, 134, 225, 160) // array and index length must be equal
TRANSLATION("array/bytes required on right side", 34, 242, 117, 50, 95, 4, 254, 180, 193, 80, 24, 235, 203, 0, 231, 50) // array/bytes required on right side
TRANSLATION("attempt to get (arg)min/(arg)max of empty sequence", 50, 24, 130, 178, 216, 214, 172, 160, 58, 66, 213, 244, 236, 52, 234, 116, 133, 171, 233, 216, 58, 57, 197, 101, 177, 120, 63, 214, 64) // attempt to get (arg)min/(arg)max of empty sequence
TRANSLATION("attempt to get argmin/argmax of an empty sequence", 49, 24, 130, 178, 216, 214, 172, 160, 5, 171, 176, 211, 168, 45, 93, 131, 163, 156, 40, 5, 101, 177, 120, 63, 214, 64) // attempt to get argmin/argmax of an empty sequence
TRANSLATION("attributes not supported yet", 28, 31, 209, 245, 124, 225, 121, 64) // attributes not supported yet
TRANSLATION("axis is out of bounds", 21, 29, 6, 250, 139, 116, 115, 178, 45, 201, 55) // axis is out of bounds
TRANSLATION("axis must be None, or an integer", 32, 29, 6, 248, 59, 170, 133, 175, 207, 20, 229, 149, 100, 192) // axis must be None, or an integer
TRANSLATION("axis too long", 13, 29, 6, 225, 10, 161, 69, 74, 192) // axis too long
TRANSLATION("bad conversion specifier", 24, 200, 51, 9, 42, 102, 38, 115, 84, 246, 73, 128) // bad conversion specifier
TRANSLATION("bad typecode", 12, 200, 51, 232, 201, 102, 64) // bad typecode
TRANSLATION("bits must be in range 5 to 9", 28, 200, 112, 248, 13, 3, 242, 15, 127, 91, 253, 192) // bits must be in range 5 to 9
TRANSLATION("buffer is smaller than requested size", 37, 250, 53, 30, 193, 165, 9, 130, 50, 138, 3, 23, 13, 196, 240, 83, 246, 0) // buffer is smaller than requested size
TRANSLATION("buffer size must be a multiple of element size", 46, 250, 61, 140, 2, 31, 227, 156, 84, 43, 9, 35, 216) // buffer size must be a multiple of element size
TRANSLATION("buffer size must match format", 29, 250, 61, 143, 78, 193, 137, 101, 244, 128) // buffer size must match format
TRANSLATION("buffer slices must be of equal length", 37, 250, 1, 232, 114, 39, 192, 181, 1, 112, 220, 52, 230, 0) // buffer slices must be of equal length
TRANSLATION("buffer too small", 16, 250, 2, 21, 65, 236, 26, 80) // buffer too small
TRANSLATION("byte code not implemented", 25, 201, 124, 16, 73, 102, 90, 167, 101, 180, 43, 9, 32, 166) // byte code not implemented
TRANSLATION("byteorder is not a string", 25, 201, 124, 18, 180, 201, 181, 60, 194, 31, 152) // byteorder is not a string
TRANSLATION("bytes length not a multiple of item size", 40, 201, 124, 19, 243, 53, 68, 63, 199, 56, 224, 172, 246, 0) // bytes length not a multiple of item size
TRANSLATION("bytes value out of range", 24, 201, 124, 19, 251, 158, 175, 228) // bytes value out of range
TRANSLATION("can't add special method to already-subclassed class", 52, 250, 70, 115, 7, 180, 164, 99, 64, 176, 163, 42, 207, 88, 104, 196, 51, 191, 97, 238, 201, 42, 11, 185, 76, 37, 65, 119) // can\'t add special method to already-subclassed class
TRANSLATION("can't assign to expression", 26, 250, 69, 220, 235, 77, 98, 209, 107, 19, 185, 170, 0) // can\'t assign to expression
TRANSLATION("can't convert %q to %q", 22, 250, 100, 169, 152, 154, 3, 15, 14, 182, 30, 16) // can\'t convert %q to %q
TRANSLATION("can't convert '%q' object to %q implicitly", 42, 250, 100, 169, 152, 154, 57, 28, 221, 108, 60, 32, 118, 91, 67, 145, 197, 47) // can\'t convert \'%q\' object to %q implicitly
TRANSLATION("can't declare nonlocal in outer code", 36, 250, 102, 82, 160, 177, 2, 42, 81, 100, 52, 229, 45, 208, 76, 18, 89, 144) // can\'t declare nonlocal in outer code
TRANSLATION("can't delete expression", 23, 250, 102, 84, 40, 32, 45, 22, 177, 59, 154, 160) // can\'t delete expression
TRANSLATION("can't do truncated division of a complex number", 47, 250, 102, 161, 13, 114, 72, 96, 166, 19, 60, 198, 230, 169, 206, 16, 146, 217, 109, 11, 64, 126, 32) // can\'t do truncated division of a complex number
TRANSLATION("can't have multiple **x", 23, 250, 114, 142, 98, 15, 240, 31, 191, 247, 232) // can\'t have multiple **x
TRANSLATION("can't have multiple *x", 22, 250, 114, 142, 98, 15, 240, 31, 191, 64) // can\'t have multiple *x
TRANSLATION("can't pend throw to just-started generator", 42, 250, 109, 36, 152, 70, 86, 92, 250, 223, 117, 207, 27, 15, 2, 208, 83, 10, 201, 9, 134, 21, 128) // can\'t pend throw to just-started generator
TRANSLATION("can't send non-None value to a just-started generator", 53, 250, 92, 146, 96, 138, 155, 29, 213, 66, 247, 53, 132, 62, 235, 158, 54, 30, 5, 160, 166, 21, 146, 19, 12, 43, 0) // can\'t send non-None value to a just-started generator
TRANSLATION("can't set 512 block size", 24, 250, 92, 160, 61, 254, 175, 88, 50, 81, 101, 193, 236, 0) // can\'t set 512 block size
TRANSLATION("can't set attribute", 19, 250, 92, 160, 7, 244) // can\'t set attribute
TRANSLATION("can't switch from automatic field numbering to manual field specification", 73, 250, 95, 57, 196, 178, 133, 76, 182, 0, 221, 11, 96, 193, 200, 42, 50, 164, 195, 241, 52, 175, 90, 193, 75, 134, 129, 81, 149, 39, 236, 200, 120, 128) // can\'t switch from automatic field numbering to manual field specification
TRANSLATION("can't switch from manual field specification to automatic field numbering", 73, 250, 95, 57, 196, 178, 133, 76, 182, 5, 130, 151, 13, 2, 163, 42, 79, 217, 144, 241, 107, 13, 208, 182, 12, 28, 130, 163, 42, 76, 63, 19, 74, 192) // can\'t switch from manual field specification to automatic field numbering
TRANSLATION("cannot cast output with casting rule", 36, 151, 142, 66, 240, 11, 116, 91, 116, 123, 178, 23, 131, 74, 193, 174, 161, 0) // cannot cast output with casting rule
TRANSLATION("cannot create '%q' instances", 28, 151, 142, 76, 67, 5, 200, 3, 71, 129, 73, 19, 128) // cannot create \'%q\' instances
TRANSLATION("cannot import name %q", 21, 151, 140, 236, 181, 90, 1, 6, 194, 12, 60, 32) // cannot import name %q
TRANSLATION("cannot perform relative import", 30, 151, 142, 210, 106, 149, 172, 6, 42, 12, 30, 98, 3, 178, 213, 104) // cannot perform relative import
TRANSLATION("chr() arg not in range(0x110000)", 32, 150, 86, 233, 116, 192, 90, 189, 83, 64, 252, 186, 91, 58, 58, 189, 93, 157, 157, 157, 158, 152) // chr() arg not in range(0x110000)
TRANSLATION("circle can only be registered in one parent", 43, 145, 180, 168, 65, 33, 64, 84, 165, 225, 144, 129, 138, 179, 120, 38, 41, 242, 149, 8, 45, 22, 36, 128) // circle can only be registered in one parent
TRANSLATION("clip point must be (x,y) tuple", 30, 149, 14, 208, 181, 77, 35, 7, 75, 70, 189, 253, 48, 139, 173, 161, 0) // clip point must be (x,y) tuple
TRANSLATION("code outside range 0~127", 24, 146, 204, 191, 119, 228, 27, 63, 253, 234, 245, 191, 244) // code outside range 0~127
TRANSLATION("color buffer must be 3 bytes (RGB) or 4 bytes (RGB + pad byte)", 62, 146, 209, 88, 62, 140, 30, 247, 160, 225, 210, 239, 255, 46, 207, 79, 159, 252, 61, 7, 14, 151, 127, 249, 118, 67, 255, 33, 104, 207, 208, 233, 128) // color buffer must be 3 bytes (RGB) or 4 bytes (RGB + pad byte)
TRANSLATION("color buffer must be a buffer, tuple, list, or int", 50, 146, 209, 88, 62, 140, 2, 31, 70, 184, 69, 214, 208, 181, 194, 134, 241, 175, 207, 52, 128) // color buffer must be a buffer, tuple, list, or int
TRANSLATION("color buffer must be a bytearray or array of type 'b' or 'B'", 60, 146, 209, 88, 62, 140, 3, 232, 121, 57, 254, 78, 116, 95, 105, 6, 44, 152, 185, 248, 187, 56, 128) // color buffer must be a bytearray or array of type \'b\' or \'B\'
TRANSLATION("color must be between 0x000000 and 0xffffff", 43, 146, 209, 91, 6, 66, 140, 228, 72, 27, 58, 54, 118, 118, 118, 118, 118, 121, 59, 58, 42, 170, 170, 170, 168) // color must be between 0x000000 and 0xffffff
TRANSLATION("color should be an int", 22, 146, 209, 91, 215, 32, 20, 229, 128) // color should be an int
TRANSLATION("complex division by zero", 24, 146, 217, 109, 11, 64, 76, 243, 27, 154, 160, 100, 188, 63, 98, 101) // complex division by zero
TRANSLATION("constant must be an integer", 27, 146, 163, 192, 164, 96, 20, 229, 149, 100, 192) // constant must be an integer
TRANSLATION("convolve arguments must be linear arrays", 40, 146, 166, 101, 166, 98, 210, 124, 20, 52, 33, 96, 242, 56) // convolve arguments must be linear arrays
TRANSLATION("convolve arguments must be ndarrays", 35, 146, 166, 101, 166, 98, 210, 124, 9, 63, 35, 128) // convolve arguments must be ndarrays
TRANSLATION("convolve arguments must not be empty", 36, 146, 166, 101, 166, 98, 210, 127, 79, 205, 144, 128, 172, 182, 47) // convolve arguments must not be empty
TRANSLATION("could not invert Vandermonde matrix", 35, 146, 221, 73, 234, 154, 102, 38, 128, 254, 130, 147, 38, 177, 82, 100, 22, 12, 49, 232) // could not invert Vandermonde matrix
TRANSLATION("couldn't determine SD card version", 34, 146, 221, 73, 166, 40, 9, 148, 19, 88, 104, 65, 224, 219, 9, 11, 76, 51, 19, 57, 170, 0) // couldn\'t determine SD card version
TRANSLATION("cross is defined for 1D arrays of length 3", 42, 147, 43, 190, 167, 213, 167, 213, 219, 15, 35, 243, 191, 0, 247, 128) // cross is defined for 1D arrays of length 3
TRANSLATION("data type not understood", 24, 152, 192, 244, 117, 110, 73, 147, 60, 42, 204) // data type not understood
TRANSLATION("default 'except' must be last", 29, 153, 84, 55, 82, 3, 17, 104, 145, 91, 24, 176, 80, 94, 0) // default \'except\' must be last
TRANSLATION("default is not a function", 25, 153, 84, 55, 82, 53, 60, 194, 30, 80) // default is not a function
TRANSLATION("dict update sequence has wrong length", 37, 153, 202, 2, 235, 102, 48, 64, 255, 89, 6, 81, 112, 206, 202, 149, 243, 0) // dict update sequence has wrong length
TRANSLATION("diff argument must be an ndarray", 32, 153, 213, 86, 150, 1, 79, 80) // diff argument must be an ndarray
TRANSLATION("differentiation order out of range", 34, 153, 213, 81, 49, 36, 24, 241, 2, 180, 201, 189, 95, 200) // differentiation order out of range
TRANSLATION("division by zero", 16, 153, 230, 55, 53, 64, 201, 120, 126, 196, 202) // division by zero
TRANSLATION("empty separator", 15, 43, 45, 139, 193, 202, 209, 97, 133, 96) // empty separator
TRANSLATION("empty sequence", 14, 43, 45, 139, 193, 254, 178) // empty sequence
TRANSLATION("end_x should be an int", 22, 36, 158, 254, 143, 92, 128, 83, 150) // end_x should be an int
TRANSLATION("exceptions must derive from BaseException", 41, 45, 18, 43, 120, 159, 211, 153, 49, 230, 32, 169, 150, 192, 236, 139, 151, 107, 68, 138, 222, 32) // exceptions must derive from BaseException
TRANSLATION("expected ':' after format specifier", 35, 47, 215, 23, 95, 16, 13, 80, 77, 233, 123, 36, 192) // expected \':\' after format specifier
TRANSLATION("expecting just a value for set", 30, 45, 22, 148, 160, 210, 176, 251, 174, 120, 1, 247, 52, 220, 160) // expecting just a value for set
TRANSLATION("expecting key:value for dict", 28, 45, 22, 148, 160, 210, 176, 224, 43, 250, 249, 134, 151, 22, 156, 206, 80) // expecting key:value for dict
TRANSLATION("ext_hook is not a function", 26, 45, 17, 191, 149, 87, 131, 83, 204, 33, 229) // ext_hook is not a function
TRANSLATION("extra keyword arguments given", 29, 45, 16, 194, 31, 126, 147, 133, 103, 152, 144) // extra keyword arguments given
TRANSLATION("extra positional arguments given", 32, 45, 16, 194, 22, 171, 159, 16, 211, 73, 194, 179, 204, 72) // extra positional arguments given
TRANSLATION("file must be a file opened in byte mode", 39, 168, 232, 88, 4, 42, 58, 16, 45, 164, 133, 62, 86, 75, 224, 130, 197, 153, 0) // file must be a file opened in byte mode
TRANSLATION("filesystem must provide mount method", 36, 168, 232, 79, 123, 193, 89, 233, 218, 203, 152, 230, 65, 98, 220, 144, 22, 20, 101, 89, 128) // filesystem must provide mount method
TRANSLATION("first argument must be a callable", 33, 168, 217, 227, 75, 0, 132, 134, 148, 241, 0) // first argument must be a callable
TRANSLATION("first argument must be a function", 33, 168, 217, 227, 75, 0, 135, 148) // first argument must be a function
TRANSLATION("first argument must be a tuple of ndarrays", 42, 168, 217, 227, 75, 0, 132, 93, 109, 11, 156, 147, 242, 56) // first argument must be a tuple of ndarrays
TRANSLATION("first argument must be an iterable", 34, 168, 217, 227, 75, 0, 160, 28, 19, 120, 128) // first argument must be an iterable
TRANSLATION("first argument must be an ndarray", 33, 168, 217, 227, 75, 0, 167, 168) // first argument must be an ndarray
TRANSLATION("first argument to super() must be type", 38, 168, 217, 227, 75, 89, 238, 180, 155, 165, 211, 193, 23, 218, 64) // first argument to super() must be type
TRANSLATION("flattening order must be either 'C', or 'F'", 43, 170, 131, 16, 72, 105, 88, 43, 76, 155, 1, 28, 101, 38, 12, 91, 88, 181, 249, 248, 190, 76, 64) // flattening order must be either \'C\', or \'F\'
TRANSLATION("flip argument must be an ndarray", 32, 170, 135, 110, 150, 1, 79, 80) // flip argument must be an ndarray
TRANSLATION("format requires a dict", 22, 169, 90, 193, 143, 89, 192, 66, 103, 40) // format requires a dict
TRANSLATION("function does not take keyword arguments", 40, 242, 132, 212, 159, 86, 7, 128, 131, 239, 210, 112) // function does not take keyword arguments
TRANSLATION("function expected at most %d arguments, got %d", 46, 242, 129, 126, 163, 1, 98, 188, 6, 25, 233, 62, 184, 86, 176, 24, 102) // function expected at most %d arguments, got %d
TRANSLATION("function got multiple values for argument '%q'", 46, 242, 133, 107, 1, 254, 61, 199, 211, 254, 220, 128) // function got multiple values for argument \'%q\'
TRANSLATION("function has the same sign at the ends of interval", 50, 242, 134, 81, 127, 105, 198, 194, 7, 58, 208, 6, 61, 162, 73, 191, 56, 210, 9, 179, 13, 0) // function has the same sign at the ends of interval
TRANSLATION("function is defined for ndarrays only", 37, 242, 234, 125, 90, 105, 63, 35, 130, 165, 47) // function is defined for ndarrays only
TRANSLATION("function missing %d required positional arguments", 49, 242, 133, 134, 238, 105, 88, 97, 159, 173, 48, 181, 92, 248, 134, 154, 78) // function missing %d required positional arguments
TRANSLATION("function missing keyword-only argument", 38, 242, 133, 134, 238, 105, 88, 125, 251, 10, 148, 191, 72) // function missing keyword-only argument
TRANSLATION("function missing required keyword argument '%q'", 47, 242, 133, 134, 238, 105, 95, 173, 48, 251, 244, 185, 0) // function missing required keyword argument \'%q\'
TRANSLATION("function missing required positional argument #%d", 49, 242, 133, 134, 238, 105, 95, 173, 48, 181, 92, 248, 134, 154, 65, 255, 140, 51) // function missing required positional argument #%d
TRANSLATION("function takes %d positional arguments but %d were given", 56, 242, 132, 15, 1, 56, 97, 152, 90, 174, 124, 67, 77, 39, 12, 151, 64, 97, 152, 103, 38, 32, 172, 243, 18, 0) // function takes %d positional arguments but %d were given
TRANSLATION("function takes exactly 9 arguments", 34, 242, 132, 15, 1, 56, 22, 129, 148, 82, 240, 255, 125, 39) // function takes exactly 9 arguments
TRANSLATION("generator already executing", 27, 172, 144, 152, 97, 88, 6, 140, 67, 59, 192, 180, 20, 174, 131, 74, 192) // generator already executing
TRANSLATION("generator ignored GeneratorExit", 31, 172, 144, 152, 97, 88, 14, 180, 86, 41, 135, 242, 36, 38, 24, 86, 237, 104, 56) // generator ignored GeneratorExit
TRANSLATION("identifier redefined as global", 30, 57, 146, 65, 212, 100, 192, 197, 245, 0, 184, 87, 69, 200, 52) // identifier redefined as global
TRANSLATION("identifier redefined as nonlocal", 32, 57, 146, 65, 212, 100, 192, 197, 245, 0, 184, 34, 165, 22, 67, 64) // identifier redefined as nonlocal
TRANSLATION("incomplete format", 17, 52, 146, 217, 109, 10, 11, 210) // incomplete format
TRANSLATION("incomplete format key", 21, 52, 146, 217, 109, 10, 11, 210, 14, 2, 188) // incomplete format key
TRANSLATION("incorrect padding", 17, 52, 146, 179, 20, 160, 45, 25, 204, 210, 176) // incorrect padding
TRANSLATION("index is out of bounds", 22, 52, 153, 104, 212, 91, 163, 157, 145, 110, 73, 184) // index is out of bounds
TRANSLATION("index out of range", 18, 52, 153, 104, 245, 127, 32) // index out of range
TRANSLATION("indices must be integers, slices, or Boolean lists", 50, 52, 153, 200, 159, 7, 247, 125, 112, 122, 28, 137, 245, 249, 253, 149, 90, 16, 160, 80, 222, 28) // indices must be integers, slices, or Boolean lists
TRANSLATION("initial_value length is wrong", 29, 52, 56, 49, 166, 254, 97, 165, 197, 204, 212, 206, 202, 149, 128) // initial_value length is wrong
TRANSLATION("input and output shapes are not compatible", 42, 251, 121, 43, 116, 91, 116, 3, 229, 27, 73, 192, 88, 181, 100, 182, 90, 48, 121, 40, 64) // input and output shapes are not compatible
TRANSLATION("input argument must be an integer, a tuple, or a list", 53, 251, 116, 176, 10, 114, 202, 178, 109, 112, 16, 139, 173, 161, 107, 243, 196, 40, 111, 0) // input argument must be an integer, a tuple, or a list
TRANSLATION("input array length must be power of 2", 37, 251, 67, 201, 204, 193, 106, 231, 38, 231, 117, 128) // input array length must be power of 2
TRANSLATION("input arrays are not compatible", 31, 251, 67, 200, 224, 44, 90, 178, 91, 45, 24, 60, 148, 32) // input arrays are not compatible
TRANSLATION("input data must be an iterable", 30, 251, 66, 99, 3, 128, 80, 14, 9, 188, 64) // input data must be an iterable
TRANSLATION("input matrix is asymmetric", 26, 251, 66, 193, 134, 61, 26, 130, 247, 217, 97, 67, 28, 128) // input matrix is asymmetric
TRANSLATION("input matrix is singular", 24, 251, 66, 193, 134, 61, 26, 142, 105, 93, 212, 22) // input matrix is singular
TRANSLATION("input must be a tensor of rank 2", 32, 251, 112, 8, 65, 35, 171, 115, 152, 83, 128, 58, 192) // input must be a tensor of rank 2
TRANSLATION("input must be an ndarray", 24, 251, 112, 10, 122, 128) // input must be an ndarray
TRANSLATION("input must be one-dimensional", 29, 251, 112, 42, 22, 196, 206, 194, 71, 53, 65, 160) // input must be one-dimensional
TRANSLATION("input must be square matrix", 27, 251, 112, 63, 13, 194, 196, 22, 12, 49, 232) // input must be square matrix
TRANSLATION("input must be tuple, list, range, or ndarray", 44, 251, 112, 69, 214, 208, 181, 194, 134, 241, 174, 31, 150, 191, 61, 39, 228) // input must be tuple, list, range, or ndarray
TRANSLATION("input vectors must be of equal length", 37, 251, 67, 49, 74, 21, 159, 2, 212, 5, 195, 112, 211, 152) // input vectors must be of equal length
TRANSLATION("inputs are not iterable", 23, 251, 92, 5, 139, 84, 224, 155, 196) // inputs are not iterable
TRANSLATION("int() arg 2 must be >= 2 and <= 36", 34, 52, 142, 151, 76, 5, 171, 14, 182, 15, 139, 225, 14, 183, 39, 254, 62, 16, 247, 190, 0) // int() arg 2 must be >= 2 and <= 36
TRANSLATION("integer required", 16, 254, 254, 180, 192) // integer required
TRANSLATION("interp is defined for 1D arrays of equal length", 47, 52, 130, 107, 117, 62, 173, 62, 174, 216, 121, 31, 156, 92, 55, 13, 57, 128) // interp is defined for 1D arrays of equal length
TRANSLATION("interval must be in range %s-%s", 31, 52, 130, 108, 195, 76, 6, 129, 249, 6, 23, 216, 194, 224) // interval must be in range %s-%s
TRANSLATION("invalid format specifier", 24, 52, 204, 52, 57, 250, 94, 201, 48) // invalid format specifier
TRANSLATION("invalid micropython decorator", 29, 52, 204, 52, 57, 133, 135, 38, 91, 111, 140, 170, 129, 50, 146, 176, 194, 176) // invalid micropython decorator
TRANSLATION("invalid step", 12, 52, 204, 52, 57, 131, 193, 90) // invalid step
TRANSLATION("invalid syntax", 14, 52, 204, 52, 57, 131, 222, 144, 58, 0) // invalid syntax
TRANSLATION("invalid syntax for integer with base %d", 39, 52, 204, 52, 57, 131, 222, 144, 58, 52, 255, 191, 187, 144, 92, 131, 12, 192) // invalid syntax for integer with base %d
TRANSLATION("invalid syntax for number", 25, 52, 204, 52, 57, 131, 222, 144, 58, 52, 255, 16) // invalid syntax for number
TRANSLATION("issubclass() arg 1 must be a class", 34, 55, 123, 178, 74, 130, 239, 210, 233, 128, 181, 97, 213, 192, 33, 42, 11, 184) // issubclass() arg 1 must be a class
TRANSLATION("issubclass() arg 2 must be a class or a tuple of classes", 56, 55, 123, 178, 74, 130, 239, 210, 233, 128, 181, 97, 214, 192, 33, 42, 11, 191, 60, 66, 46, 182, 133, 206, 149, 5, 220, 156) // issubclass() arg 2 must be a class or a tuple of classes
TRANSLATION("iterables are not of the same length", 36, 56, 38, 241, 56, 11, 22, 170, 213, 237, 56, 216, 92, 192) // iterables are not of the same length
TRANSLATION("iterations did not converge", 27, 56, 38, 30, 39, 9, 156, 245, 100, 169, 152, 154, 178) // iterations did not converge
TRANSLATION("join expects a list of str/bytes objects consistent with self object", 68, 251, 148, 208, 11, 69, 165, 40, 112, 16, 161, 188, 115, 158, 27, 169, 146, 248, 39, 230, 184, 73, 81, 205, 224, 146, 61, 215, 42, 85, 205) // join expects a list of str/bytes objects consistent with self object
TRANSLATION("keyword argument(s) not yet implemented - use normal args instead", 65, 251, 244, 186, 79, 211, 213, 188, 160, 14, 203, 104, 86, 18, 65, 76, 54, 2, 231, 32, 69, 107, 6, 128, 45, 91, 129, 163, 193, 12, 192) // keyword argument(s) not yet implemented - use normal args instead
TRANSLATION("keywords must be strings", 24, 251, 223, 7, 230, 224) // keywords must be strings
TRANSLATION("length argument not allowed for this type", 41, 252, 52, 181, 70, 148, 92, 229, 61, 56, 202, 111, 209) // length argument not allowed for this type
TRANSLATION("lhs and rhs should be compatible", 32, 166, 87, 228, 182, 87, 245, 200, 36, 182, 90, 48, 121, 40, 64) // lhs and rhs should be compatible
TRANSLATION("local variable referenced before assignment", 43, 162, 200, 104, 25, 133, 143, 196, 12, 85, 19, 18, 72, 166, 25, 10, 165, 98, 1, 119, 58, 210, 194, 72) // local variable referenced before assignment
TRANSLATION("malformed f-string", 18, 176, 105, 82, 181, 133, 48, 171, 99, 243) // malformed f-string
TRANSLATION("math domain error", 17, 176, 99, 40, 77, 108, 19, 79, 68) // math domain error
TRANSLATION("matrix dimensions do not match", 30, 176, 97, 143, 64, 76, 236, 36, 115, 84, 112, 154, 234, 216, 49, 44, 160) // matrix dimensions do not match
TRANSLATION("matrix is not positive definite", 31, 176, 97, 143, 70, 167, 154, 213, 115, 131, 204, 65, 50, 168, 208, 224, 128) // matrix is not positive definite
TRANSLATION("max_length must be 0-%d when fixed_length is %s", 47, 176, 116, 111, 254, 24, 54, 118, 48, 204, 51, 229, 36, 10, 143, 65, 79, 127, 240, 212, 194, 224) // max_length must be 0-%d when fixed_length is %s
TRANSLATION("max_length must be <= 512", 25, 176, 116, 111, 254, 24, 63, 227, 225, 15, 127, 171, 214) // max_length must be <= 512
TRANSLATION("max_length must be >= 0", 23, 176, 116, 111, 254, 24, 62, 47, 132, 54, 64) // max_length must be >= 0
TRANSLATION("maximum number of dimensions is 4", 33, 176, 116, 29, 151, 88, 31, 143, 58, 103, 97, 35, 154, 163, 234, 127, 0) // maximum number of dimensions is 4
TRANSLATION("maximum recursion depth exceeded", 32, 176, 116, 29, 151, 88, 12, 82, 185, 156, 213, 2, 101, 108, 101, 2, 209, 34, 41, 148, 192) // maximum recursion depth exceeded
TRANSLATION("maxiter must be > 0", 19, 176, 116, 28, 19, 96, 248, 131, 100) // maxiter must be > 0
TRANSLATION("maxiter should be > 0", 21, 176, 116, 28, 19, 122, 228, 31, 16, 108, 128) // maxiter should be > 0
TRANSLATION("median argument must be an ndarray", 34, 176, 166, 98, 154, 88, 5, 61, 64) // median argument must be an ndarray
TRANSLATION("memory allocation failed, allocating %u bytes", 45, 176, 172, 86, 188, 6, 148, 89, 15, 16, 84, 39, 66, 158, 184, 13, 40, 178, 24, 52, 172, 48, 221, 232, 56) // memory allocation failed, allocating %u bytes
TRANSLATION("memory allocation failed, heap is locked", 40, 176, 172, 86, 188, 6, 148, 89, 15, 16, 84, 39, 66, 158, 184, 101, 33, 183, 82, 139, 46, 2, 152) // memory allocation failed, heap is locked
TRANSLATION("memoryview: length is not a multiple of itemsize", 48, 176, 172, 86, 191, 49, 150, 126, 191, 51, 83, 204, 33, 254, 57, 199, 5, 99, 159, 236, 64) // memoryview: length is not a multiple of itemsize
TRANSLATION("more degrees of freedom than data points", 40, 177, 88, 130, 101, 91, 17, 63, 58, 166, 34, 154, 216, 17, 148, 80, 38, 48, 33, 106, 154, 67, 128) // more degrees of freedom than data points
TRANSLATION("multiple *x in assignment", 25, 255, 1, 251, 244, 114, 133, 220, 235, 75, 9, 32) // multiple *x in assignment
TRANSLATION("multiple bases have instance lay-out conflict", 45, 255, 1, 144, 92, 156, 50, 142, 98, 3, 71, 129, 73, 16, 80, 111, 216, 91, 160, 36, 169, 85, 14, 80) // multiple bases have instance lay-out conflict
TRANSLATION("must use keyword argument for key function", 42, 178, 231, 128, 185, 200, 62, 253, 45, 62, 2, 188, 60, 160) // must use keyword argument for key function
TRANSLATION("name '%q' is not defined", 24, 65, 176, 185, 26, 158, 111, 168) // name \'%q\' is not defined
TRANSLATION("name reused for argument", 24, 65, 176, 129, 138, 231, 41, 233, 255, 96) // name reused for argument
TRANSLATION("need more than %d values to unpack", 34, 66, 41, 133, 138, 196, 17, 148, 80, 48, 207, 220, 125, 107, 146, 209, 151, 0) // need more than %d values to unpack
TRANSLATION("negative shift count", 20, 66, 172, 96, 243, 16, 62, 83, 170, 2, 75, 114, 64) // negative shift count
TRANSLATION("no SD card", 10, 69, 15, 6, 216, 72, 90, 96) // no SD card
TRANSLATION("no active exception to reraise", 30, 69, 1, 148, 30, 98, 2, 209, 34, 183, 139, 89, 137, 132, 220, 128) // no active exception to reraise
TRANSLATION("no binding for nonlocal found", 29, 69, 12, 134, 147, 52, 175, 77, 21, 40, 178, 26, 5, 75, 114, 76) // no binding for nonlocal found
TRANSLATION("no default packer", 17, 69, 9, 149, 67, 117, 32, 45, 25, 112, 19, 0) // no default packer
TRANSLATION("no module named '%q'", 20, 69, 11, 22, 119, 80, 129, 6, 194, 159, 32) // no module named \'%q\'
TRANSLATION("no reset pin available", 22, 69, 6, 39, 40, 232, 0, 230, 19, 167, 136) // no reset pin available
TRANSLATION("no response from SD card", 24, 69, 6, 39, 181, 81, 200, 42, 101, 176, 60, 27, 97, 33, 105, 128) // no response from SD card
TRANSLATION("non-default argument follows default argument", 45, 69, 77, 137, 149, 67, 117, 35, 72, 42, 90, 81, 115, 184, 76, 170, 27, 169, 26, 64) // non-default argument follows default argument
TRANSLATION("non-hex digit found", 19, 69, 77, 140, 165, 160, 38, 117, 156, 5, 75, 114, 76) // non-hex digit found
TRANSLATION("non-keyword arg after */**", 26, 69, 77, 143, 188, 5, 171, 1, 170, 9, 131, 247, 245, 63, 127, 239) // non-keyword arg after */**
TRANSLATION("non-keyword arg after keyword arg", 33, 69, 77, 143, 188, 5, 171, 1, 170, 9, 131, 239, 1, 106, 192) // non-keyword arg after keyword arg
TRANSLATION("non-zero timeout must be >= interval", 36, 69, 77, 143, 216, 153, 125, 181, 186, 48, 124, 95, 15, 44, 155, 48, 208) // non-zero timeout must be >= interval
TRANSLATION("norm is defined for 1D and 2D arrays", 36, 69, 107, 53, 62, 173, 62, 174, 223, 39, 173, 182, 30, 71) // norm is defined for 1D and 2D arrays
TRANSLATION("not a 128-bit UUID", 18, 243, 8, 117, 122, 223, 237, 177, 144, 224, 60, 62, 29, 205, 176) // not a 128-bit UUID
TRANSLATION("not all arguments converted during string formatting", 52, 243, 13, 41, 164, 225, 37, 76, 196, 208, 83, 9, 220, 198, 149, 135, 231, 233, 65, 165, 96) // not all arguments converted during string formatting
TRANSLATION("not enough arguments for format string", 38, 243, 18, 45, 213, 229, 210, 125, 58, 149, 172, 24, 15, 204) // not enough arguments for format string
TRANSLATION("number of points must be at least 2", 35, 252, 121, 214, 169, 164, 62, 1, 128, 161, 11, 192, 117, 128) // number of points must be at least 2
TRANSLATION("object ", 7, 92, 159, 113, 74, 0) // object 
TRANSLATION("object '%q' is not a tuple or list", 34, 92, 159, 113, 74, 57, 26, 158, 97, 8, 186, 218, 23, 62, 134, 240) // object \'%q\' is not a tuple or list
TRANSLATION("object not in sequence", 22, 92, 159, 113, 74, 53, 77, 1, 254, 178) // object not in sequence
TRANSLATION("object of type '%q' has no len()", 32, 92, 159, 113, 74, 57, 209, 125, 165, 200, 12, 162, 224, 138, 20, 36, 233, 116, 192) // object of type \'%q\' has no len()
TRANSLATION("object with buffer protocol required", 36, 92, 159, 113, 74, 61, 223, 160, 45, 101, 133, 146, 211, 214, 152) // object with buffer protocol required
TRANSLATION("odd-length string", 17, 89, 207, 99, 240, 15, 204) // odd-length string
TRANSLATION("offset is too large", 19, 90, 170, 114, 141, 72, 85, 10, 11, 86, 64) // offset is too large
TRANSLATION("offset must be non-negative and no greater than buffer length", 61, 90, 170, 114, 140, 8, 169, 176, 133, 88, 193, 230, 46, 74, 40, 86, 196, 48, 76, 17, 148, 80, 62, 142, 96) // offset must be non-negative and no greater than buffer length
TRANSLATION("offset out of bounds", 20, 90, 170, 114, 143, 87, 34, 220, 147, 112) // offset out of bounds
TRANSLATION("only slices with step=1 (aka None) are supported", 48, 84, 165, 224, 244, 57, 19, 251, 175, 5, 111, 195, 213, 14, 144, 240, 8, 119, 85, 11, 166, 2, 196, 30, 112) // only slices with step=1 (aka None) are supported
TRANSLATION("operands could not be broadcast together", 40, 91, 73, 133, 38, 225, 37, 186, 147, 213, 200, 65, 145, 148, 103, 33, 120, 8, 90, 202, 50, 147, 0) // operands could not be broadcast together
TRANSLATION("operation is implemented for 1D Boolean arrays only", 51, 91, 73, 135, 139, 80, 236, 182, 133, 97, 36, 20, 244, 250, 187, 97, 217, 85, 161, 10, 7, 145, 193, 82, 151, 128) // operation is implemented for 1D Boolean arrays only
TRANSLATION("operation is not implemented on ndarrays", 40, 91, 73, 135, 139, 83, 204, 118, 91, 66, 176, 146, 10, 96, 169, 234, 56) // operation is not implemented on ndarrays
TRANSLATION("operation is not supported for given type", 41, 91, 73, 135, 139, 83, 205, 231, 211, 172, 243, 18, 116, 64) // operation is not supported for given type
TRANSLATION("ord() expected a character, but string of length %d found", 57, 86, 159, 75, 166, 5, 250, 136, 75, 236, 215, 12, 151, 64, 126, 124, 239, 192, 48, 204, 42, 91, 146, 96) // ord() expected a character, but string of length %d found
TRANSLATION("out of range of source", 22, 91, 163, 157, 249, 115, 157, 110, 105, 16) // out of range of source
TRANSLATION("out of range of target", 22, 91, 163, 157, 249, 115, 160, 90, 178, 128) // out of range of target
TRANSLATION("overflow converting long int to machine word", 44, 92, 196, 213, 81, 115, 132, 149, 51, 19, 65, 165, 97, 69, 74, 249, 122, 214, 12, 178, 154, 16, 103, 86, 152) // overflow converting long int to machine word
TRANSLATION("palette_index should be an int", 30, 180, 104, 81, 5, 190, 105, 50, 209, 235, 144, 10, 114, 192) // palette_index should be an int
TRANSLATION("pixel coordinates out of bounds", 31, 180, 244, 21, 2, 74, 173, 51, 65, 130, 127, 87, 34, 220, 147, 112) // pixel coordinates out of bounds
TRANSLATION("pixel value requires too many bits", 34, 180, 244, 21, 61, 207, 89, 194, 63, 200, 100, 56, 112) // pixel value requires too many bits
TRANSLATION("pixel_shader must be displayio.Palette or displayio.ColorConverter", 66, 180, 244, 21, 55, 223, 40, 204, 155, 4, 205, 237, 160, 222, 107, 143, 116, 104, 81, 5, 207, 153, 189, 180, 27, 205, 113, 237, 45, 21, 182, 149, 51, 19, 65, 48) // pixel_shader must be displayio.Palette or displayio.ColorConverter
TRANSLATION("polygon can only be registered in one parent", 44, 181, 105, 125, 106, 129, 33, 64, 84, 165, 225, 144, 129, 138, 179, 120, 38, 41, 242, 149, 8, 45, 22, 36, 128) // polygon can only be registered in one parent
TRANSLATION("pop from empty %q", 17, 181, 109, 10, 153, 108, 2, 178, 216, 188, 48, 240, 128) // pop from empty %q
TRANSLATION("pow() 3rd argument cannot be 0", 30, 181, 115, 244, 186, 97, 239, 52, 244, 130, 94, 60, 132, 27, 32) // pow() 3rd argument cannot be 0
TRANSLATION("pow() with 3 arguments requires integers", 40, 181, 115, 244, 186, 126, 239, 189, 164, 254, 179, 242, 202, 178, 103) // pow() with 3 arguments requires integers
TRANSLATION("real and imaginary parts must be of equal length", 48, 98, 26, 114, 78, 193, 172, 208, 90, 240, 180, 90, 31, 2, 212, 5, 195, 112, 211, 152) // real and imaginary parts must be of equal length
TRANSLATION("requested length %d but object has length %d", 44, 98, 225, 184, 158, 10, 124, 192, 195, 48, 201, 116, 115, 67, 40, 191, 48, 48, 204) // requested length %d but object has length %d
TRANSLATION("results cannot be cast to specified type", 40, 98, 123, 169, 14, 18, 241, 228, 32, 144, 188, 107, 61, 165, 35, 168, 202, 125, 16) // results cannot be cast to specified type
TRANSLATION("roll argument must be an ndarray", 32, 101, 165, 52, 176, 10, 122, 128) // roll argument must be an ndarray
TRANSLATION("rsplit(None,n)", 14, 103, 182, 135, 29, 46, 234, 161, 107, 167, 76) // rsplit(None,n)
TRANSLATION("shape must be a tuple", 21, 124, 163, 105, 96, 16, 139, 173, 161, 0) // shape must be a tuple
TRANSLATION("short read", 10, 124, 170, 208, 12, 67, 48) // short read
TRANSLATION("sign not allowed in string format specifier", 43, 115, 173, 53, 70, 148, 92, 229, 62, 87, 231, 233, 123, 36, 192) // sign not allowed in string format specifier
TRANSLATION("sign not allowed with integer format specifier 'c'", 50, 115, 173, 53, 70, 148, 92, 229, 63, 119, 251, 250, 94, 201, 48, 98, 150, 32) // sign not allowed with integer format specifier \'c\'
TRANSLATION("single '}' encountered in format string", 39, 115, 74, 232, 65, 139, 255, 152, 128, 146, 75, 114, 65, 49, 79, 149, 82, 181, 131, 1, 249, 128) // single \'}\' encountered in format string
TRANSLATION("size is defined for ndarrays only", 33, 115, 253, 139, 83, 234, 211, 73, 249, 28, 21, 41, 120) // size is defined for ndarrays only
TRANSLATION("sleep length must be non-negative", 33, 122, 17, 91, 204, 192, 138, 155, 8, 85, 140, 30, 98) // sleep length must be non-negative
TRANSLATION("slice step cannot be zero", 25, 122, 28, 136, 30, 10, 208, 151, 143, 33, 7, 236, 76, 160) // slice step cannot be zero
TRANSLATION("small int overflow", 18, 123, 6, 148, 229, 130, 230, 38, 170, 139, 156) // small int overflow
TRANSLATION("soft reboot\n", 13, 117, 170, 1, 139, 34, 172, 113, 248, 192) // soft reboot\r\n
TRANSLATION("sort argument must be an ndarray", 32, 117, 104, 210, 192, 41, 234, 0) // sort argument must be an ndarray
TRANSLATION("sos array must be of shape (n_section, 6)", 41, 117, 112, 242, 96, 90, 129, 242, 141, 164, 29, 36, 223, 114, 151, 22, 184, 124, 29, 48) // sos array must be of shape (n_section, 6)
TRANSLATION("sos[:, 3] should be all ones", 28, 117, 127, 255, 122, 250, 225, 239, 127, 253, 235, 144, 13, 40, 10, 132, 224) // sos[:, 3] should be all ones
TRANSLATION("sosfilt requires iterable arguments", 35, 117, 122, 142, 145, 235, 56, 28, 19, 120, 180, 156) // sosfilt requires iterable arguments
TRANSLATION("source palette too large", 24, 117, 185, 164, 65, 104, 208, 162, 8, 33, 84, 40, 45, 89, 0) // source palette too large
TRANSLATION("start/end indices", 17, 120, 22, 142, 161, 36, 192, 210, 103, 34, 112) // start/end indices
TRANSLATION("start_x should be an int", 24, 120, 22, 141, 253, 30, 185, 0, 167, 44) // start_x should be an int
TRANSLATION("step must be non-zero", 21, 120, 43, 112, 34, 166, 199, 236, 76, 160) // step must be non-zero
TRANSLATION("stop must be 1 or 2", 19, 120, 91, 112, 117, 121, 253, 96) // stop must be 1 or 2
TRANSLATION("stop not reachable from start", 29, 120, 91, 117, 88, 134, 89, 124, 65, 83, 45, 128, 240, 45, 0) // stop not reachable from start
TRANSLATION("stream operation not supported", 30, 120, 98, 27, 1, 109, 38, 30, 45, 95, 56) // stream operation not supported
TRANSLATION("string indices must be integers, not %q", 39, 252, 192, 210, 103, 34, 124, 31, 221, 245, 245, 112, 240, 128) // string indices must be integers, not %q
TRANSLATION("string not supported; use bytes or bytearray", 44, 252, 245, 124, 255, 251, 11, 156, 189, 7, 231, 228, 190, 11, 200) // string not supported; use bytes or bytearray
TRANSLATION("substring not found", 19, 123, 178, 126, 122, 181, 45, 201, 48) // substring not found
TRANSLATION("super() can't find self", 23, 123, 173, 38, 233, 116, 195, 233, 168, 210, 96, 229, 74, 128) // super() can\'t find self
TRANSLATION("syntax error in JSON", 20, 123, 210, 7, 71, 163, 202, 255, 243, 193, 222, 238, 128) // syntax error in JSON
TRANSLATION("threshold must be in the range 0-65536", 38, 140, 172, 79, 149, 105, 60, 6, 158, 215, 228, 27, 59, 31, 7, 191, 239, 251, 223, 0) // threshold must be in the range 0-65536
TRANSLATION("time.struct_time() takes a 9-sequence", 37, 131, 176, 177, 188, 53, 210, 141, 248, 59, 11, 165, 211, 8, 30, 2, 112, 16, 255, 125, 135, 250, 200) // time.struct_time() takes a 9-sequence
TRANSLATION("timeout must be 0.0-100.0 seconds", 33, 131, 176, 150, 232, 193, 179, 143, 103, 99, 171, 179, 179, 143, 100, 28, 164, 169, 55) // timeout must be 0.0-100.0 seconds
TRANSLATION("timeout must be >= 0.0", 22, 131, 176, 150, 232, 193, 241, 124, 33, 179, 143, 100) // timeout must be >= 0.0
TRANSLATION("timeout waiting for v1 card", 27, 131, 176, 150, 232, 12, 226, 112, 105, 94, 158, 110, 168, 72, 90, 96) // timeout waiting for v1 card
TRANSLATION("timeout waiting for v2 card", 27, 131, 176, 150, 232, 12, 226, 112, 105, 94, 158, 110, 176, 72, 90, 96) // timeout waiting for v2 card
TRANSLATION("timestamp out of range for platform time_t", 42, 131, 176, 158, 6, 203, 125, 95, 203, 78, 218, 12, 84, 173, 103, 183, 191, 0) // timestamp out of range for platform time_t
TRANSLATION("tobytes can be invoked for dense arrays only", 44, 133, 201, 124, 19, 132, 133, 3, 33, 1, 166, 101, 224, 41, 233, 204, 145, 200, 60, 142, 10, 148, 188) // tobytes can be invoked for dense arrays only
TRANSLATION("too many arguments provided with the given format", 49, 143, 243, 164, 225, 107, 46, 99, 153, 79, 221, 140, 164, 21, 158, 98, 79, 72) // too many arguments provided with the given format
TRANSLATION("too many dimensions", 19, 143, 242, 19, 59, 9, 28, 213, 28) // too many dimensions
TRANSLATION("too many indices", 16, 143, 242, 6, 147, 57, 19, 128) // too many indices
TRANSLATION("too many values to unpack (expected %d)", 39, 143, 243, 238, 62, 181, 201, 104, 203, 128, 58, 69, 250, 225, 159, 76) // too many values to unpack (expected %d)
TRANSLATION("trapz is defined for 1D arrays", 30, 134, 27, 127, 109, 79, 171, 79, 171, 182, 30, 71) // trapz is defined for 1D arrays
TRANSLATION("trapz is defined for 1D arrays of equal length", 46, 134, 27, 127, 109, 79, 171, 79, 171, 182, 30, 71, 231, 23, 13, 195, 78, 96) // trapz is defined for 1D arrays of equal length
TRANSLATION("tx and rx cannot both be None", 29, 141, 28, 150, 208, 18, 241, 228, 88, 202, 25, 8, 59, 170, 132) // tx and rx cannot both be None
TRANSLATION("type '%q' is not an acceptable base type", 40, 139, 237, 46, 70, 167, 152, 80, 6, 82, 43, 99, 196, 25, 5, 203, 162) // type \'%q\' is not an acceptable base type
TRANSLATION("type is not an acceptable base type", 35, 139, 237, 45, 79, 48, 160, 12, 164, 86, 199, 136, 50, 11, 151, 68) // type is not an acceptable base type
TRANSLATION("type object 'generator' has no attribute '__await__'", 52, 139, 237, 46, 104, 98, 172, 144, 152, 97, 91, 16, 101, 23, 4, 80, 31, 208, 49, 111, 239, 142, 113, 56, 223, 223, 196) // type object \'generator\' has no attribute \'__await__\'
TRANSLATION("type takes 1 or 3 arguments", 27, 139, 237, 32, 129, 224, 39, 14, 175, 63, 222, 210, 112) // type takes 1 or 3 arguments
TRANSLATION("unexpected indent", 17, 185, 11, 245, 52, 153, 36, 0) // unexpected indent
TRANSLATION("unexpected keyword argument '%q'", 32, 185, 11, 245, 251, 244, 185, 0) // unexpected keyword argument \'%q\'
TRANSLATION("unicode name escapes", 20, 185, 14, 75, 50, 4, 27, 8, 9, 228, 54, 147, 128) // unicode name escapes
TRANSLATION("unindent does not match any outer indentation level", 51, 185, 13, 38, 73, 1, 53, 39, 213, 176, 98, 89, 64, 82, 240, 91, 160, 152, 13, 38, 73, 3, 196, 20, 44, 197, 64) // unindent does not match any outer indentation level
TRANSLATION("unknown format code '%c' for object of type '%q'", 48, 185, 56, 17, 115, 167, 164, 18, 89, 144, 98, 195, 44, 90, 107, 147, 238, 41, 71, 58, 47, 180, 185, 0) // unknown format code \'%c\' for object of type \'%q\'
TRANSLATION("unmatched '{' in format", 23, 185, 44, 24, 150, 82, 152, 98, 255, 255, 23, 42, 165, 107, 6, 0) // unmatched \'{\' in format
TRANSLATION("unreadable attribute", 20, 185, 24, 134, 126, 32, 31, 208) // unreadable attribute
TRANSLATION("unsupported %q type", 19, 185, 60, 225, 135, 135, 162) // unsupported %q type
TRANSLATION("unsupported format character '%c' (0x%x) at index %d", 52, 185, 60, 254, 144, 75, 236, 12, 88, 101, 136, 58, 91, 58, 48, 232, 233, 128, 192, 26, 76, 180, 6, 25, 128) // unsupported format character \'%c\' (0x%x) at index %d
TRANSLATION("unsupported type for %q: '%q'", 29, 185, 60, 253, 29, 60, 60, 61, 126, 64) // unsupported type for %q: \'%q\'
TRANSLATION("unsupported types for %q: '%q', '%q'", 36, 185, 60, 253, 23, 211, 195, 195, 215, 228, 107, 242, 0) // unsupported types for %q: \'%q\', \'%q\'
TRANSLATION("value must fit in %d byte(s)", 28, 204, 52, 184, 189, 58, 142, 57, 88, 103, 232, 116, 159, 166) // value must fit in %d byte(s)
TRANSLATION("value_count must be > 0", 23, 204, 52, 184, 183, 228, 183, 36, 96, 248, 131, 100) // value_count must be > 0
TRANSLATION("vectors must have same lengths", 30, 204, 82, 133, 103, 244, 242, 142, 98, 7, 27, 11, 152, 224) // vectors must have same lengths
TRANSLATION("window must be <= interval", 26, 206, 105, 53, 207, 131, 254, 62, 30, 89, 54, 97, 160) // window must be <= interval
TRANSLATION("wrong axis index", 16, 206, 202, 149, 128, 232, 55, 3, 73, 150, 128) // wrong axis index
TRANSLATION("wrong axis specified", 20, 206, 202, 149, 128, 232, 55, 246, 74, 96) // wrong axis specified
TRANSLATION("wrong input type", 16, 206, 202, 149, 135, 219, 209) // wrong input type
TRANSLATION("wrong number of arguments", 25, 206, 202, 149, 135, 227, 206, 254, 206) // wrong number of arguments
TRANSLATION("wrong operand type", 18, 206, 202, 149, 130, 218, 76, 41, 62, 136) // wrong operand type
TRANSLATION("wrong output type", 17, 206, 202, 149, 130, 221, 22, 221, 29, 16) // wrong output type
TRANSLATION("x value out of bounds", 21, 209, 238, 122, 185, 22, 228, 155, 128) // x value out of bounds
TRANSLATION("y should be an int", 18, 191, 215, 32, 20, 229, 128) // y should be an int
TRANSLATION("y value out of bounds", 21, 191, 220, 245, 114, 45, 201, 55) // y value out of bounds
TRANSLATION("zero step", 9, 253, 137, 148, 30, 10, 208) // zero step
TRANSLATION("zi must be an ndarray", 21, 253, 143, 0, 167, 168) // zi must be an ndarray
TRANSLATION("zi must be of float type", 24, 253, 143, 2, 212, 21, 81, 70, 58, 32) // zi must be of float type
TRANSLATION("zi must be of shape (n_section, 2)", 34, 253, 143, 2, 212, 15, 148, 109, 32, 233, 38, 251, 148, 184, 181, 195, 173, 211) // zi must be of shape (n_section, 2)

// 8633 bytes worth of qstr
// 18576 bytes worth of translations
// 9389 bytes worth of translations compressed
// 9187 bytes saved
