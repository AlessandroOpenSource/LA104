// # words 63
// words [' must be ', ' argument', 'supported', 'multiple ', ' outside ', ' safe mod', 'implement', 'function', ' ndarray', ' require', ' specifi', ' out of ', 'ttribute', 'argument', 'xpected ', 'sequence', ' length', ' object', 'nvalid ', ' format', 'keyword', 'defined', 'integer', ' failed', 'arrays', "can't ", 'annot ', 'string', ' error', 'number', 'erator', 'ircuit', ' not ', ' for ', ' type', " '%q'", 'input', ' with', ' the ', ' and ', 'ython', 'uffer', ' size', 'range', 'value', ' file', 'class', ' code', 'opera', 'bytes', 'wrong', 'tion', ' to ', ' is ', 'not ', 'able', ' of ', 'ing ', ' or ', 'sion', ' pin', 'time', ' in']
// 32   772 0000 0
// 97 a 497 0001 1
// 101 e 746 0010 2
// 110 n 392 0011 3
// 111 o 441 0100 4
// 114 r 417 0101 5
// 115 s 419 0110 6
// 116 t 519 0111 7
// 99 c 228 10000 16
// 100 d 289 10001 17
// 105 i 330 10010 18
// 108 l 267 10011 19
// 117 u 219 10100 20
// 102 f 114 101010 42
// 104 h 106 101011 43
// 109 m 181 101100 44
// 112 p 183 101101 45
// 121 y 101 101110 46
// 128  must be  63 1011110 94
// 37 % 57 1011111 95
// 39 \' 70 1100000 96
// 46 . 60 1100001 97
// 98 b 83 1100010 98
// 103 g 93 1100011 99
// 118 v 62 1100100 100
// 119 w 59 1100101 101
// 120 x 66 1100110 102
// 10 \n 31 11001110 206
// 13 \r 31 11001111 207
// 129  argument 41 11010000 208
// 161  for  29 11010001 209
// 190  in 47 11010010 210
// 181  is  46 11010011 211
// 160  not  43 11010100 212
// 180  to  28 11010101 213
// 40 ( 30 11010110 214
// 41 ) 30 11010111 215
// 44 , 27 11011000 216
// 45 - 33 11011001 217
// 67 C 37 11011010 218
// 73 I 44 11011011 219
// 83 S 25 11011100 220
// 84 T 28 11011101 221
// 185 ing  26 11011110 222
// 107 k 37 11011111 223
// 113 q 43 11100000 224
// 179 tion 36 11100001 225
// 163  \'%q\' 19 111000100 452
// 147  format 14 111000101 453
// 144  length 20 111000110 454
// 145  object 18 111000111 455
// 184  of  24 111001000 456
// 186  or  16 111001001 457
// 188  pin 13 111001010 458
// 166  the  13 111001011 459
// 162  type 17 111001100 460
// 165  with 13 111001101 461
// 47 / 24 111001110 462
// 48 0 22 111001111 463
// 49 1 19 111010000 464
// 50 2 18 111010001 465
// 58 : 17 111010010 466
// 65 A 17 111010011 467
// 68 D 18 111010100 468
// 69 E 13 111010101 469
// 77 M 15 111010110 470
// 78 N 23 111010111 471
// 80 P 25 111011000 472
// 82 R 25 111011001 473
// 85 U 20 111011010 474
// 95 _ 25 111011011 475
// 183 able 18 111011100 476
// 154 annot  15 111011101 477
// 152 arrays 17 111011110 478
// 153 can\'t  16 111011111 479
// 135 function 20 111100000 480
// 164 input 17 111100001 481
// 106 j 14 111100010 482
// 182 not  20 111100011 483
// 146 nvalid  20 111100100 484
// 187 sion 14 111100101 485
// 130 supported 15 111100110 486
// 122 z 13 111100111 487
// 167  and  12 1111010000 976
// 175  code 8 1111010001 977
// 156  error 12 1111010010 978
// 173  file 9 1111010011 979
// 136  ndarray 10 1111010100 980
// 139  out of  7 1111010101 981
// 132  outside  7 1111010110 982
// 137  require 11 1111010111 983
// 170  size 11 1111011000 984
// 138  specifi 10 1111011001 985
// 42 * 8 1111011010 986
// 51 3 7 1111011011 987
// 53 5 9 1111011100 988
// 66 B 10 1111011101 989
// 70 F 10 1111011110 990
// 72 H 10 1111011111 991
// 76 L 8 1111100000 992
// 79 O 11 1111100001 993
// 141 argument 9 1111100010 994
// 177 bytes 8 1111100011 995
// 174 class 8 1111100100 996
// 149 defined 11 1111100101 997
// 158 erator 8 1111100110 998
// 159 ircuit 8 1111100111 999
// 148 keyword 12 1111101000 1000
// 131 multiple  9 1111101001 1001
// 157 number 9 1111101010 1002
// 176 opera 8 1111101011 1003
// 171 range 10 1111101100 1004
// 143 sequence 7 1111101101 1005
// 155 string 12 1111101110 1006
// 189 time 12 1111101111 1007
// 140 ttribute 9 1111110000 1008
// 169 uffer 11 1111110001 1009
// 172 value 10 1111110010 1010
// 178 wrong 8 1111110011 1011
// 142 xpected  7 1111110100 1012
// 168 ython 11 1111110101 1013
// 151  failed 6 11111101100 2028
// 133  safe mod 6 11111101101 2029
// 33 ! 3 11111101110 2030
// 34 \" 4 11111101111 2031
// 52 4 3 11111110000 2032
// 54 6 6 11111110001 2033
// 57 9 3 11111110010 2034
// 61 = 4 11111110011 2035
// 62 > 3 11111110100 2036
// 71 G 4 11111110101 2037
// 86 V 4 11111110110 2038
// 87 W 5 11111110111 2039
// 88 X 3 11111111000 2040
// 89 Y 4 11111111001 2041
// 96 ` 4 11111111010 2042
// 134 implement 6 11111111011 2043
// 150 integer 5 11111111100 2044
// 59 ; 2 111111111010 4090
// 35 # 1 1111111110110 8182
// 55 7 1 1111111110111 8183
// 56 8 1 1111111111000 8184
// 60 < 1 1111111111001 8185
// 74 J 1 1111111111010 8186
// 91 [ 1 1111111111011 8187
// 93 ] 1 1111111111100 8188
// 123 { 1 1111111111101 8189
// 125 } 1 1111111111110 8190
// 126 ~ 1 1111111111111 8191
// length count {4: 8, 5: 5, 6: 5, 7: 9, 8: 20, 9: 36, 10: 38, 11: 17, 12: 1, 13: 10}
// values [' ', 'a', 'e', 'n', 'o', 'r', 's', 't', 'c', 'd', 'i', 'l', 'u', 'f', 'h', 'm', 'p', 'y', ' must be ', '%', "'", '.', 'b', 'g', 'v', 'w', 'x', '\n', '\r', ' argument', ' for ', ' in', ' is ', ' not ', ' to ', '(', ')', ',', '-', 'C', 'I', 'S', 'T', 'ing ', 'k', 'q', 'tion', " '%q'", ' format', ' length', ' object', ' of ', ' or ', ' pin', ' the ', ' type', ' with', '/', '0', '1', '2', ':', 'A', 'D', 'E', 'M', 'N', 'P', 'R', 'U', '_', 'able', 'annot ', 'arrays', "can't ", 'function', 'input', 'j', 'not ', 'nvalid ', 'sion', 'supported', 'z', ' and ', ' code', ' error', ' file', ' ndarray', ' out of ', ' outside ', ' require', ' size', ' specifi', '*', '3', '5', 'B', 'F', 'H', 'L', 'O', 'argument', 'bytes', 'class', 'defined', 'erator', 'ircuit', 'keyword', 'multiple ', 'number', 'opera', 'range', 'sequence', 'string', 'time', 'ttribute', 'uffer', 'value', 'wrong', 'xpected ', 'ython', ' failed', ' safe mod', '!', '"', '4', '6', '9', '=', '>', 'G', 'V', 'W', 'X', 'Y', '`', 'implement', 'integer', ';', '#', '7', '8', '<', 'J', '[', ']', '{', '}', '~'] lengths 14 bytearray(b'\x00\x00\x00\x08\x05\x05\t\x14$&\x11\x01\n\x00')
// [' ', 'a', 'e', 'n', 'o', 'r', 's', 't', 'c', 'd', 'i', 'l', 'u', 'f', 'h', 'm', 'p', 'y', ' must be ', '%', "'", '.', 'b', 'g', 'v', 'w', 'x', '\n', '\r', ' argument', ' for ', ' in', ' is ', ' not ', ' to ', '(', ')', ',', '-', 'C', 'I', 'S', 'T', 'ing ', 'k', 'q', 'tion', " '%q'", ' format', ' length', ' object', ' of ', ' or ', ' pin', ' the ', ' type', ' with', '/', '0', '1', '2', ':', 'A', 'D', 'E', 'M', 'N', 'P', 'R', 'U', '_', 'able', 'annot ', 'arrays', "can't ", 'function', 'input', 'j', 'not ', 'nvalid ', 'sion', 'supported', 'z', ' and ', ' code', ' error', ' file', ' ndarray', ' out of ', ' outside ', ' require', ' size', ' specifi', '*', '3', '5', 'B', 'F', 'H', 'L', 'O', 'argument', 'bytes', 'class', 'defined', 'erator', 'ircuit', 'keyword', 'multiple ', 'number', 'opera', 'range', 'sequence', 'string', 'time', 'ttribute', 'uffer', 'value', 'wrong', 'xpected ', 'ython', ' failed', ' safe mod', '!', '"', '4', '6', '9', '=', '>', 'G', 'V', 'W', 'X', 'Y', '`', 'implement', 'integer', ';', '#', '7', '8', '<', 'J', '[', ']', '{', '}', '~'] bytearray(b'\x00\x00\x00\x08\x05\x05\t\x14$&\x11\x01\n\x00')
// [' ', 'a', 'e', 'n', 'o', 'r', 's', 't', 'c', 'd', 'i', 'l', 'u', 'f', 'h', 'm', 'p', 'y', '\x80', '%', "'", '.', 'b', 'g', 'v', 'w', 'x', '\n', '\r', '\x81', '¡', '¾', 'µ', '\xa0', '´', '(', ')', ',', '-', 'C', 'I', 'S', 'T', '¹', 'k', 'q', '³', '£', '\x93', '\x90', '\x91', '¸', 'º', '¼', '¦', '¢', '¥', '/', '0', '1', '2', ':', 'A', 'D', 'E', 'M', 'N', 'P', 'R', 'U', '_', '·', '\x9a', '\x98', '\x99', '\x87', '¤', 'j', '¶', '\x92', '»', '\x82', 'z', '§', '¯', '\x9c', '\xad', '\x88', '\x8b', '\x84', '\x89', 'ª', '\x8a', '*', '3', '5', 'B', 'F', 'H', 'L', 'O', '\x8d', '±', '®', '\x95', '\x9e', '\x9f', '\x94', '\x83', '\x9d', '°', '«', '\x8f', '\x9b', '½', '\x8c', '©', '¬', '²', '\x8e', '¨', '\x97', '\x85', '!', '"', '4', '6', '9', '=', '>', 'G', 'V', 'W', 'X', 'Y', '`', '\x86', '\x96', ';', '#', '7', '8', '<', 'J', '[', ']', '{', '}', '~'] bytearray(b'\x00\x00\x00\x08\x05\x05\t\x14$&\x11\x01\n\x00')
// This file was automatically generated by makeqstrdata.py

QDEF(MP_QSTR_NULL, (const byte*)"\x00\x00" "")
QDEF(MP_QSTR_, (const byte*)"\x05\x00" "")
QDEF(MP_QSTR___dir__, (const byte*)"\x7a\x07" "__dir__")
QDEF(MP_QSTR___abs__, (const byte*)"\x95\x07" "__abs__")
QDEF(MP_QSTR___add__, (const byte*)"\xc4\x07" "__add__")
QDEF(MP_QSTR___aenter__, (const byte*)"\x4c\x0a" "__aenter__")
QDEF(MP_QSTR___aexit__, (const byte*)"\xc4\x09" "__aexit__")
QDEF(MP_QSTR___aiter__, (const byte*)"\x4e\x09" "__aiter__")
QDEF(MP_QSTR___and__, (const byte*)"\x0e\x07" "__and__")
QDEF(MP_QSTR___anext__, (const byte*)"\x83\x09" "__anext__")
QDEF(MP_QSTR___await__, (const byte*)"\x4f\x09" "__await__")
QDEF(MP_QSTR___bool__, (const byte*)"\x2b\x08" "__bool__")
QDEF(MP_QSTR___build_class__, (const byte*)"\x42\x0f" "__build_class__")
QDEF(MP_QSTR___bytes__, (const byte*)"\xdc\x09" "__bytes__")
QDEF(MP_QSTR___call__, (const byte*)"\xa7\x08" "__call__")
QDEF(MP_QSTR___class__, (const byte*)"\x2b\x09" "__class__")
QDEF(MP_QSTR___contains__, (const byte*)"\xc6\x0c" "__contains__")
QDEF(MP_QSTR___del__, (const byte*)"\x68\x07" "__del__")
QDEF(MP_QSTR___delete__, (const byte*)"\xdc\x0a" "__delete__")
QDEF(MP_QSTR___delitem__, (const byte*)"\xfd\x0b" "__delitem__")
QDEF(MP_QSTR___dict__, (const byte*)"\x7f\x08" "__dict__")
QDEF(MP_QSTR___divmod__, (const byte*)"\x78\x0a" "__divmod__")
QDEF(MP_QSTR___enter__, (const byte*)"\x6d\x09" "__enter__")
QDEF(MP_QSTR___eq__, (const byte*)"\x71\x06" "__eq__")
QDEF(MP_QSTR___exit__, (const byte*)"\x45\x08" "__exit__")
QDEF(MP_QSTR___file__, (const byte*)"\x03\x08" "__file__")
QDEF(MP_QSTR___floordiv__, (const byte*)"\x46\x0c" "__floordiv__")
QDEF(MP_QSTR___func__, (const byte*)"\x5b\x08" "__func__")
QDEF(MP_QSTR___ge__, (const byte*)"\xa7\x06" "__ge__")
QDEF(MP_QSTR___get__, (const byte*)"\xb3\x07" "__get__")
QDEF(MP_QSTR___getattr__, (const byte*)"\x40\x0b" "__getattr__")
QDEF(MP_QSTR___getitem__, (const byte*)"\x26\x0b" "__getitem__")
QDEF(MP_QSTR___gt__, (const byte*)"\xb6\x06" "__gt__")
QDEF(MP_QSTR___hash__, (const byte*)"\xf7\x08" "__hash__")
QDEF(MP_QSTR___iadd__, (const byte*)"\x6d\x08" "__iadd__")
QDEF(MP_QSTR___import__, (const byte*)"\x38\x0a" "__import__")
QDEF(MP_QSTR___init__, (const byte*)"\x5f\x08" "__init__")
QDEF(MP_QSTR___invert__, (const byte*)"\xf7\x0a" "__invert__")
QDEF(MP_QSTR___isub__, (const byte*)"\x08\x08" "__isub__")
QDEF(MP_QSTR___iter__, (const byte*)"\xcf\x08" "__iter__")
QDEF(MP_QSTR___le__, (const byte*)"\xcc\x06" "__le__")
QDEF(MP_QSTR___len__, (const byte*)"\xe2\x07" "__len__")
QDEF(MP_QSTR___lshift__, (const byte*)"\x09\x0a" "__lshift__")
QDEF(MP_QSTR___lt__, (const byte*)"\x5d\x06" "__lt__")
QDEF(MP_QSTR___main__, (const byte*)"\x8e\x08" "__main__")
QDEF(MP_QSTR___mod__, (const byte*)"\x63\x07" "__mod__")
QDEF(MP_QSTR___module__, (const byte*)"\xff\x0a" "__module__")
QDEF(MP_QSTR___mul__, (const byte*)"\x31\x07" "__mul__")
QDEF(MP_QSTR___name__, (const byte*)"\xe2\x08" "__name__")
QDEF(MP_QSTR___neg__, (const byte*)"\x69\x07" "__neg__")
QDEF(MP_QSTR___new__, (const byte*)"\x79\x07" "__new__")
QDEF(MP_QSTR___next__, (const byte*)"\x02\x08" "__next__")
QDEF(MP_QSTR___or__, (const byte*)"\x38\x06" "__or__")
QDEF(MP_QSTR___path__, (const byte*)"\xc8\x08" "__path__")
QDEF(MP_QSTR___pos__, (const byte*)"\x29\x07" "__pos__")
QDEF(MP_QSTR___pow__, (const byte*)"\x2d\x07" "__pow__")
QDEF(MP_QSTR___qualname__, (const byte*)"\x6b\x0c" "__qualname__")
QDEF(MP_QSTR___radd__, (const byte*)"\x16\x08" "__radd__")
QDEF(MP_QSTR___rand__, (const byte*)"\xdc\x08" "__rand__")
QDEF(MP_QSTR___repl_print__, (const byte*)"\x01\x0e" "__repl_print__")
QDEF(MP_QSTR___repr__, (const byte*)"\x10\x08" "__repr__")
QDEF(MP_QSTR___reversed__, (const byte*)"\x61\x0c" "__reversed__")
QDEF(MP_QSTR___rfloordiv__, (const byte*)"\x54\x0d" "__rfloordiv__")
QDEF(MP_QSTR___rlshift__, (const byte*)"\x1b\x0b" "__rlshift__")
QDEF(MP_QSTR___rmod__, (const byte*)"\x31\x08" "__rmod__")
QDEF(MP_QSTR___rmul__, (const byte*)"\x63\x08" "__rmul__")
QDEF(MP_QSTR___ror__, (const byte*)"\x2a\x07" "__ror__")
QDEF(MP_QSTR___rpow__, (const byte*)"\xff\x08" "__rpow__")
QDEF(MP_QSTR___rrshift__, (const byte*)"\xc5\x0b" "__rrshift__")
QDEF(MP_QSTR___rshift__, (const byte*)"\x57\x0a" "__rshift__")
QDEF(MP_QSTR___rsub__, (const byte*)"\x73\x08" "__rsub__")
QDEF(MP_QSTR___rtruediv__, (const byte*)"\x5a\x0c" "__rtruediv__")
QDEF(MP_QSTR___rxor__, (const byte*)"\xf2\x08" "__rxor__")
QDEF(MP_QSTR___set__, (const byte*)"\xa7\x07" "__set__")
QDEF(MP_QSTR___setitem__, (const byte*)"\x32\x0b" "__setitem__")
QDEF(MP_QSTR___str__, (const byte*)"\xd0\x07" "__str__")
QDEF(MP_QSTR___sub__, (const byte*)"\x21\x07" "__sub__")
QDEF(MP_QSTR___traceback__, (const byte*)"\x4f\x0d" "__traceback__")
QDEF(MP_QSTR___truediv__, (const byte*)"\x88\x0b" "__truediv__")
QDEF(MP_QSTR___version__, (const byte*)"\x3f\x0b" "__version__")
QDEF(MP_QSTR___xor__, (const byte*)"\x20\x07" "__xor__")
QDEF(MP_QSTR__star_, (const byte*)"\x8f\x01" "*")
QDEF(MP_QSTR__, (const byte*)"\xfa\x01" "_")
QDEF(MP_QSTR__slash_, (const byte*)"\x8a\x01" "/")
QDEF(MP_QSTR__percent__hash_o, (const byte*)"\x6c\x03" "%#o")
QDEF(MP_QSTR__percent__hash_x, (const byte*)"\x7b\x03" "%#x")
QDEF(MP_QSTR__brace_open__colon__hash_b_brace_close_, (const byte*)"\x58\x05" "{:#b}")
QDEF(MP_QSTR__space_, (const byte*)"\x85\x01" " ")
QDEF(MP_QSTR__0x0a_, (const byte*)"\xaf\x01" "\x0a")
QDEF(MP_QSTR_maximum_space_recursion_space_depth_space_exceeded, (const byte*)"\x73\x20" "maximum recursion depth exceeded")
QDEF(MP_QSTR__lt_module_gt_, (const byte*)"\xbd\x08" "<module>")
QDEF(MP_QSTR__lt_lambda_gt_, (const byte*)"\x80\x08" "<lambda>")
QDEF(MP_QSTR__lt_listcomp_gt_, (const byte*)"\xd4\x0a" "<listcomp>")
QDEF(MP_QSTR__lt_dictcomp_gt_, (const byte*)"\xcc\x0a" "<dictcomp>")
QDEF(MP_QSTR__lt_setcomp_gt_, (const byte*)"\x54\x09" "<setcomp>")
QDEF(MP_QSTR__lt_genexpr_gt_, (const byte*)"\x34\x09" "<genexpr>")
QDEF(MP_QSTR__lt_string_gt_, (const byte*)"\x52\x08" "<string>")
QDEF(MP_QSTR__lt_stdin_gt_, (const byte*)"\xe3\x07" "<stdin>")
QDEF(MP_QSTR_utf_hyphen_8, (const byte*)"\xb7\x05" "utf-8")
QDEF(MP_QSTR_pystack_space_exhausted, (const byte*)"\x25\x11" "pystack exhausted")
QDEF(MP_QSTR__dot_frozen, (const byte*)"\x81\x07" ".frozen")
QDEF(MP_QSTR__slash_lib, (const byte*)"\x8d\x04" "/lib")
QDEF(MP_QSTR_AUTO_RELOAD, (const byte*)"\x04\x0b" "AUTO_RELOAD")
QDEF(MP_QSTR_ArithmeticError, (const byte*)"\x2d\x0f" "ArithmeticError")
QDEF(MP_QSTR_AssertionError, (const byte*)"\x97\x0e" "AssertionError")
QDEF(MP_QSTR_AttributeError, (const byte*)"\x21\x0e" "AttributeError")
QDEF(MP_QSTR_BOOTLOADER, (const byte*)"\xe2\x0a" "BOOTLOADER")
QDEF(MP_QSTR_BROWNOUT, (const byte*)"\x8d\x08" "BROWNOUT")
QDEF(MP_QSTR_BaseException, (const byte*)"\x07\x0d" "BaseException")
QDEF(MP_QSTR_BrokenPipeError, (const byte*)"\x2e\x0f" "BrokenPipeError")
QDEF(MP_QSTR_BytesIO, (const byte*)"\x1a\x07" "BytesIO")
QDEF(MP_QSTR_C, (const byte*)"\xe6\x01" "C")
QDEF(MP_QSTR_ConnectionError, (const byte*)"\x4b\x0f" "ConnectionError")
QDEF(MP_QSTR_DEBUG, (const byte*)"\x34\x05" "DEBUG")
QDEF(MP_QSTR_DEEP_SLEEP_ALARM, (const byte*)"\x0d\x10" "DEEP_SLEEP_ALARM")
QDEF(MP_QSTR_DOWN, (const byte*)"\x37\x04" "DOWN")
QDEF(MP_QSTR_DigitalInOut, (const byte*)"\xf6\x0c" "DigitalInOut")
QDEF(MP_QSTR_Direction, (const byte*)"\x40\x09" "Direction")
QDEF(MP_QSTR_DriveMode, (const byte*)"\xaa\x09" "DriveMode")
QDEF(MP_QSTR_EACCES, (const byte*)"\x37\x06" "EACCES")
QDEF(MP_QSTR_EADDRINUSE, (const byte*)"\x17\x0a" "EADDRINUSE")
QDEF(MP_QSTR_EAGAIN, (const byte*)"\x20\x06" "EAGAIN")
QDEF(MP_QSTR_EALREADY, (const byte*)"\x46\x08" "EALREADY")
QDEF(MP_QSTR_EBADF, (const byte*)"\x61\x05" "EBADF")
QDEF(MP_QSTR_ECONNABORTED, (const byte*)"\x27\x0c" "ECONNABORTED")
QDEF(MP_QSTR_ECONNREFUSED, (const byte*)"\x3a\x0c" "ECONNREFUSED")
QDEF(MP_QSTR_ECONNRESET, (const byte*)"\x19\x0a" "ECONNRESET")
QDEF(MP_QSTR_EEXIST, (const byte*)"\x53\x06" "EEXIST")
QDEF(MP_QSTR_EHOSTUNREACH, (const byte*)"\x86\x0c" "EHOSTUNREACH")
QDEF(MP_QSTR_EINPROGRESS, (const byte*)"\x9a\x0b" "EINPROGRESS")
QDEF(MP_QSTR_EINVAL, (const byte*)"\x5c\x06" "EINVAL")
QDEF(MP_QSTR_EIO, (const byte*)"\x86\x03" "EIO")
QDEF(MP_QSTR_EISDIR, (const byte*)"\xa5\x06" "EISDIR")
QDEF(MP_QSTR_ENOBUFS, (const byte*)"\xe3\x07" "ENOBUFS")
QDEF(MP_QSTR_ENODEV, (const byte*)"\xb6\x06" "ENODEV")
QDEF(MP_QSTR_ENOENT, (const byte*)"\x5e\x06" "ENOENT")
QDEF(MP_QSTR_ENOMEM, (const byte*)"\xa4\x06" "ENOMEM")
QDEF(MP_QSTR_ENOTCONN, (const byte*)"\x79\x08" "ENOTCONN")
QDEF(MP_QSTR_EOFError, (const byte*)"\x91\x08" "EOFError")
QDEF(MP_QSTR_EOPNOTSUPP, (const byte*)"\xac\x0a" "EOPNOTSUPP")
QDEF(MP_QSTR_EPERM, (const byte*)"\xea\x05" "EPERM")
QDEF(MP_QSTR_ETIMEDOUT, (const byte*)"\xff\x09" "ETIMEDOUT")
QDEF(MP_QSTR_EVEN, (const byte*)"\xdd\x04" "EVEN")
QDEF(MP_QSTR_Ellipsis, (const byte*)"\xf0\x08" "Ellipsis")
QDEF(MP_QSTR_Exception, (const byte*)"\xf2\x09" "Exception")
QDEF(MP_QSTR_ExtType, (const byte*)"\x54\x07" "ExtType")
QDEF(MP_QSTR_FileIO, (const byte*)"\xc5\x06" "FileIO")
QDEF(MP_QSTR_Flash, (const byte*)"\x95\x05" "Flash")
QDEF(MP_QSTR_GamePad, (const byte*)"\x3e\x07" "GamePad")
QDEF(MP_QSTR_GeneratorExit, (const byte*)"\x16\x0d" "GeneratorExit")
QDEF(MP_QSTR_I2C, (const byte*)"\x5d\x03" "I2C")
QDEF(MP_QSTR_I2CDevice, (const byte*)"\x45\x09" "I2CDevice")
QDEF(MP_QSTR_INPUT, (const byte*)"\x53\x05" "INPUT")
QDEF(MP_QSTR_ImportError, (const byte*)"\x20\x0b" "ImportError")
QDEF(MP_QSTR_IndentationError, (const byte*)"\x5c\x10" "IndentationError")
QDEF(MP_QSTR_IndexError, (const byte*)"\x83\x0a" "IndexError")
QDEF(MP_QSTR_KeyError, (const byte*)"\xea\x08" "KeyError")
QDEF(MP_QSTR_KeyboardInterrupt, (const byte*)"\xaf\x11" "KeyboardInterrupt")
QDEF(MP_QSTR_LookupError, (const byte*)"\xff\x0b" "LookupError")
QDEF(MP_QSTR_M, (const byte*)"\xe8\x01" "M")
QDEF(MP_QSTR_MISO, (const byte*)"\x9d\x04" "MISO")
QDEF(MP_QSTR_MOSI, (const byte*)"\x1d\x04" "MOSI")
QDEF(MP_QSTR_MemoryError, (const byte*)"\xdc\x0b" "MemoryError")
QDEF(MP_QSTR_MpyError, (const byte*)"\x39\x08" "MpyError")
QDEF(MP_QSTR_NORMAL, (const byte*)"\xf6\x06" "NORMAL")
QDEF(MP_QSTR_NaN, (const byte*)"\x24\x03" "NaN")
QDEF(MP_QSTR_NameError, (const byte*)"\xba\x09" "NameError")
QDEF(MP_QSTR_NoneType, (const byte*)"\x17\x08" "NoneType")
QDEF(MP_QSTR_NotImplementedError, (const byte*)"\xc6\x13" "NotImplementedError")
QDEF(MP_QSTR_ODD, (const byte*)"\x6a\x03" "ODD")
QDEF(MP_QSTR_OPEN_DRAIN, (const byte*)"\x5e\x0a" "OPEN_DRAIN")
QDEF(MP_QSTR_OSError, (const byte*)"\xa1\x07" "OSError")
QDEF(MP_QSTR_OUTPUT, (const byte*)"\xda\x06" "OUTPUT")
QDEF(MP_QSTR_OneWire, (const byte*)"\x68\x07" "OneWire")
QDEF(MP_QSTR_OrderedDict, (const byte*)"\xf0\x0b" "OrderedDict")
QDEF(MP_QSTR_OverflowError, (const byte*)"\x81\x0d" "OverflowError")
QDEF(MP_QSTR_POWER_ON, (const byte*)"\xc4\x08" "POWER_ON")
QDEF(MP_QSTR_PUSH_PULL, (const byte*)"\x81\x09" "PUSH_PULL")
QDEF(MP_QSTR_Parity, (const byte*)"\x22\x06" "Parity")
QDEF(MP_QSTR_Pin, (const byte*)"\x12\x03" "Pin")
QDEF(MP_QSTR_Processor, (const byte*)"\x13\x09" "Processor")
QDEF(MP_QSTR_Pull, (const byte*)"\x60\x04" "Pull")
QDEF(MP_QSTR_REPL_RELOAD, (const byte*)"\x20\x0b" "REPL_RELOAD")
QDEF(MP_QSTR_RESET_PIN, (const byte*)"\x38\x09" "RESET_PIN")
QDEF(MP_QSTR_ReloadException, (const byte*)"\x03\x0f" "ReloadException")
QDEF(MP_QSTR_ResetReason, (const byte*)"\x54\x0b" "ResetReason")
QDEF(MP_QSTR_RunMode, (const byte*)"\x8f\x07" "RunMode")
QDEF(MP_QSTR_RunReason, (const byte*)"\xe8\x09" "RunReason")
QDEF(MP_QSTR_Runtime, (const byte*)"\xb9\x07" "Runtime")
QDEF(MP_QSTR_RuntimeError, (const byte*)"\x61\x0c" "RuntimeError")
QDEF(MP_QSTR_SAFE_MODE, (const byte*)"\x08\x09" "SAFE_MODE")
QDEF(MP_QSTR_SDCard, (const byte*)"\xa6\x06" "SDCard")
QDEF(MP_QSTR_SOFTWARE, (const byte*)"\xca\x08" "SOFTWARE")
QDEF(MP_QSTR_SPI, (const byte*)"\xef\x03" "SPI")
QDEF(MP_QSTR_SPIDevice, (const byte*)"\x37\x09" "SPIDevice")
QDEF(MP_QSTR_STARTUP, (const byte*)"\x80\x07" "STARTUP")
QDEF(MP_QSTR_SUPERVISOR_RELOAD, (const byte*)"\xfb\x11" "SUPERVISOR_RELOAD")
QDEF(MP_QSTR_StopAsyncIteration, (const byte*)"\xec\x12" "StopAsyncIteration")
QDEF(MP_QSTR_StopIteration, (const byte*)"\xea\x0d" "StopIteration")
QDEF(MP_QSTR_StringIO, (const byte*)"\x76\x08" "StringIO")
QDEF(MP_QSTR_SyntaxError, (const byte*)"\x94\x0b" "SyntaxError")
QDEF(MP_QSTR_SystemExit, (const byte*)"\x20\x0a" "SystemExit")
QDEF(MP_QSTR_TextIOWrapper, (const byte*)"\xad\x0d" "TextIOWrapper")
QDEF(MP_QSTR_TimeoutError, (const byte*)"\x66\x0c" "TimeoutError")
QDEF(MP_QSTR_TouchIn, (const byte*)"\x67\x07" "TouchIn")
QDEF(MP_QSTR_TypeError, (const byte*)"\x25\x09" "TypeError")
QDEF(MP_QSTR_UART, (const byte*)"\xb7\x04" "UART")
QDEF(MP_QSTR_ULAB, (const byte*)"\x5f\x04" "ULAB")
QDEF(MP_QSTR_UNKNOWN, (const byte*)"\x8d\x07" "UNKNOWN")
QDEF(MP_QSTR_UP, (const byte*)"\xa0\x02" "UP")
QDEF(MP_QSTR_UnicodeError, (const byte*)"\x22\x0c" "UnicodeError")
QDEF(MP_QSTR_ValueError, (const byte*)"\x96\x0a" "ValueError")
QDEF(MP_QSTR_VfsFat, (const byte*)"\x15\x06" "VfsFat")
QDEF(MP_QSTR_WATCHDOG, (const byte*)"\x01\x08" "WATCHDOG")
QDEF(MP_QSTR_ZeroDivisionError, (const byte*)"\xb6\x11" "ZeroDivisionError")
QDEF(MP_QSTR__os, (const byte*)"\x86\x03" "_os")
QDEF(MP_QSTR__time, (const byte*)"\x0f\x05" "_time")
QDEF(MP_QSTR_a, (const byte*)"\xc4\x01" "a")
QDEF(MP_QSTR_a2b_base64, (const byte*)"\x3c\x0a" "a2b_base64")
QDEF(MP_QSTR_abs, (const byte*)"\x95\x03" "abs")
QDEF(MP_QSTR_acos, (const byte*)"\x1b\x04" "acos")
QDEF(MP_QSTR_acosh, (const byte*)"\x13\x05" "acosh")
QDEF(MP_QSTR_adafruit_bus_device, (const byte*)"\xa1\x13" "adafruit_bus_device")
QDEF(MP_QSTR_add, (const byte*)"\x44\x03" "add")
QDEF(MP_QSTR_address, (const byte*)"\x73\x07" "address")
QDEF(MP_QSTR_all, (const byte*)"\x44\x03" "all")
QDEF(MP_QSTR_any, (const byte*)"\x13\x03" "any")
QDEF(MP_QSTR_append, (const byte*)"\x6b\x06" "append")
QDEF(MP_QSTR_approx, (const byte*)"\xc1\x06" "approx")
QDEF(MP_QSTR_arange, (const byte*)"\x7b\x06" "arange")
QDEF(MP_QSTR_arctan2, (const byte*)"\x1c\x07" "arctan2")
QDEF(MP_QSTR_argmax, (const byte*)"\xa5\x06" "argmax")
QDEF(MP_QSTR_argmin, (const byte*)"\xbb\x06" "argmin")
QDEF(MP_QSTR_args, (const byte*)"\xc2\x04" "args")
QDEF(MP_QSTR_argsort, (const byte*)"\x2b\x07" "argsort")
QDEF(MP_QSTR_argv, (const byte*)"\xc7\x04" "argv")
QDEF(MP_QSTR_around, (const byte*)"\x06\x06" "around")
QDEF(MP_QSTR_array, (const byte*)"\x7c\x05" "array")
QDEF(MP_QSTR_asin, (const byte*)"\x50\x04" "asin")
QDEF(MP_QSTR_asinh, (const byte*)"\x38\x05" "asinh")
QDEF(MP_QSTR_atan, (const byte*)"\x1f\x04" "atan")
QDEF(MP_QSTR_atan2, (const byte*)"\xcd\x05" "atan2")
QDEF(MP_QSTR_atanh, (const byte*)"\x97\x05" "atanh")
QDEF(MP_QSTR_axis, (const byte*)"\x06\x04" "axis")
QDEF(MP_QSTR_b2a_base64, (const byte*)"\x3c\x0a" "b2a_base64")
QDEF(MP_QSTR_base, (const byte*)"\xf0\x04" "base")
QDEF(MP_QSTR_baudrate, (const byte*)"\xf5\x08" "baudrate")
QDEF(MP_QSTR_bin, (const byte*)"\xe0\x03" "bin")
QDEF(MP_QSTR_binascii, (const byte*)"\x91\x08" "binascii")
QDEF(MP_QSTR_bisect, (const byte*)"\x8f\x06" "bisect")
QDEF(MP_QSTR_bit_length, (const byte*)"\xb9\x0a" "bit_length")
QDEF(MP_QSTR_bitbangio, (const byte*)"\x56\x09" "bitbangio")
QDEF(MP_QSTR_bits, (const byte*)"\x49\x04" "bits")
QDEF(MP_QSTR_board, (const byte*)"\x7f\x05" "board")
QDEF(MP_QSTR_bool, (const byte*)"\xeb\x04" "bool")
QDEF(MP_QSTR_bound_method, (const byte*)"\x97\x0c" "bound_method")
QDEF(MP_QSTR_buffer, (const byte*)"\xe5\x06" "buffer")
QDEF(MP_QSTR_buffer_in, (const byte*)"\xbd\x09" "buffer_in")
QDEF(MP_QSTR_buffer_out, (const byte*)"\x14\x0a" "buffer_out")
QDEF(MP_QSTR_buffering, (const byte*)"\x25\x09" "buffering")
QDEF(MP_QSTR_builtins, (const byte*)"\xf7\x08" "builtins")
QDEF(MP_QSTR_busio, (const byte*)"\x87\x05" "busio")
QDEF(MP_QSTR_bytearray, (const byte*)"\x76\x09" "bytearray")
QDEF(MP_QSTR_bytecode, (const byte*)"\x22\x08" "bytecode")
QDEF(MP_QSTR_byteorder, (const byte*)"\x61\x09" "byteorder")
QDEF(MP_QSTR_bytes, (const byte*)"\x5c\x05" "bytes")
QDEF(MP_QSTR_calcsize, (const byte*)"\x4d\x08" "calcsize")
QDEF(MP_QSTR_callable, (const byte*)"\x0d\x08" "callable")
QDEF(MP_QSTR_cast, (const byte*)"\x40\x04" "cast")
QDEF(MP_QSTR_ceil, (const byte*)"\x06\x04" "ceil")
QDEF(MP_QSTR_center, (const byte*)"\x4e\x06" "center")
QDEF(MP_QSTR_chdir, (const byte*)"\xb1\x05" "chdir")
QDEF(MP_QSTR_chip_select, (const byte*)"\x60\x0b" "chip_select")
QDEF(MP_QSTR_choice, (const byte*)"\x2e\x06" "choice")
QDEF(MP_QSTR_cholesky, (const byte*)"\x89\x08" "cholesky")
QDEF(MP_QSTR_chr, (const byte*)"\xdc\x03" "chr")
QDEF(MP_QSTR_circuitpython, (const byte*)"\x02\x0d" "circuitpython")
QDEF(MP_QSTR_classmethod, (const byte*)"\xb4\x0b" "classmethod")
QDEF(MP_QSTR_clear, (const byte*)"\x7c\x05" "clear")
QDEF(MP_QSTR_clip, (const byte*)"\xd3\x04" "clip")
QDEF(MP_QSTR_clock, (const byte*)"\x2d\x05" "clock")
QDEF(MP_QSTR_close, (const byte*)"\x33\x05" "close")
QDEF(MP_QSTR_closure, (const byte*)"\x74\x07" "closure")
QDEF(MP_QSTR_code, (const byte*)"\x68\x04" "code")
QDEF(MP_QSTR_collect, (const byte*)"\x9b\x07" "collect")
QDEF(MP_QSTR_collections, (const byte*)"\xe0\x0b" "collections")
QDEF(MP_QSTR_compare, (const byte*)"\x22\x07" "compare")
QDEF(MP_QSTR_compile, (const byte*)"\xf4\x07" "compile")
QDEF(MP_QSTR_complex, (const byte*)"\xc5\x07" "complex")
QDEF(MP_QSTR_concatenate, (const byte*)"\x0a\x0b" "concatenate")
QDEF(MP_QSTR_configure, (const byte*)"\x8d\x09" "configure")
QDEF(MP_QSTR_const, (const byte*)"\xc0\x05" "const")
QDEF(MP_QSTR_convolve, (const byte*)"\x41\x08" "convolve")
QDEF(MP_QSTR_copy, (const byte*)"\xe0\x04" "copy")
QDEF(MP_QSTR_copysign, (const byte*)"\x33\x08" "copysign")
QDEF(MP_QSTR_cos, (const byte*)"\x7a\x03" "cos")
QDEF(MP_QSTR_cosh, (const byte*)"\xd2\x04" "cosh")
QDEF(MP_QSTR_count, (const byte*)"\xa6\x05" "count")
QDEF(MP_QSTR_cpu, (const byte*)"\xc3\x03" "cpu")
QDEF(MP_QSTR_cross, (const byte*)"\x7b\x05" "cross")
QDEF(MP_QSTR_cs, (const byte*)"\xf5\x02" "cs")
QDEF(MP_QSTR_cts, (const byte*)"\x41\x03" "cts")
QDEF(MP_QSTR_data, (const byte*)"\x15\x04" "data")
QDEF(MP_QSTR_ddof, (const byte*)"\xec\x04" "ddof")
QDEF(MP_QSTR_decimals, (const byte*)"\x1d\x08" "decimals")
QDEF(MP_QSTR_decode, (const byte*)"\xa9\x06" "decode")
QDEF(MP_QSTR_default, (const byte*)"\xce\x07" "default")
QDEF(MP_QSTR_degrees, (const byte*)"\x02\x07" "degrees")
QDEF(MP_QSTR_deinit, (const byte*)"\x9e\x06" "deinit")
QDEF(MP_QSTR_delattr, (const byte*)"\xdb\x07" "delattr")
QDEF(MP_QSTR_delay_us, (const byte*)"\xa9\x08" "delay_us")
QDEF(MP_QSTR_deleter, (const byte*)"\x6e\x07" "deleter")
QDEF(MP_QSTR_det, (const byte*)"\x70\x03" "det")
QDEF(MP_QSTR_device_address, (const byte*)"\x14\x0e" "device_address")
QDEF(MP_QSTR_diag, (const byte*)"\x6e\x04" "diag")
QDEF(MP_QSTR_dict, (const byte*)"\x3f\x04" "dict")
QDEF(MP_QSTR_dict_view, (const byte*)"\x2d\x09" "dict_view")
QDEF(MP_QSTR_diff, (const byte*)"\xc8\x04" "diff")
QDEF(MP_QSTR_difference, (const byte*)"\x72\x0a" "difference")
QDEF(MP_QSTR_difference_update, (const byte*)"\x9c\x11" "difference_update")
QDEF(MP_QSTR_digitalio, (const byte*)"\x19\x09" "digitalio")
QDEF(MP_QSTR_dir, (const byte*)"\xfa\x03" "dir")
QDEF(MP_QSTR_direction, (const byte*)"\x20\x09" "direction")
QDEF(MP_QSTR_disable, (const byte*)"\x91\x07" "disable")
QDEF(MP_QSTR_disable_autoreload, (const byte*)"\xb0\x12" "disable_autoreload")
QDEF(MP_QSTR_disable_concurrent_write_protection, (const byte*)"\x3b\x23" "disable_concurrent_write_protection")
QDEF(MP_QSTR_disable_interrupts, (const byte*)"\xfa\x12" "disable_interrupts")
QDEF(MP_QSTR_discard, (const byte*)"\x0f\x07" "discard")
QDEF(MP_QSTR_divmod, (const byte*)"\xb8\x06" "divmod")
QDEF(MP_QSTR_doc, (const byte*)"\x2d\x03" "doc")
QDEF(MP_QSTR_dot, (const byte*)"\x3a\x03" "dot")
QDEF(MP_QSTR_drive_mode, (const byte*)"\x15\x0a" "drive_mode")
QDEF(MP_QSTR_dtype, (const byte*)"\x59\x05" "dtype")
QDEF(MP_QSTR_dump, (const byte*)"\xe9\x04" "dump")
QDEF(MP_QSTR_dumps, (const byte*)"\x7a\x05" "dumps")
QDEF(MP_QSTR_dx, (const byte*)"\x99\x02" "dx")
QDEF(MP_QSTR_e, (const byte*)"\xc0\x01" "e")
QDEF(MP_QSTR_edgeitems, (const byte*)"\xc0\x09" "edgeitems")
QDEF(MP_QSTR_eig, (const byte*)"\xae\x03" "eig")
QDEF(MP_QSTR_enable, (const byte*)"\x04\x06" "enable")
QDEF(MP_QSTR_enable_autoreload, (const byte*)"\x85\x11" "enable_autoreload")
QDEF(MP_QSTR_enable_interrupts, (const byte*)"\x4f\x11" "enable_interrupts")
QDEF(MP_QSTR_encode, (const byte*)"\x43\x06" "encode")
QDEF(MP_QSTR_encoding, (const byte*)"\x06\x08" "encoding")
QDEF(MP_QSTR_end, (const byte*)"\x0a\x03" "end")
QDEF(MP_QSTR_endpoint, (const byte*)"\x06\x08" "endpoint")
QDEF(MP_QSTR_endswith, (const byte*)"\x1b\x08" "endswith")
QDEF(MP_QSTR_enumerate, (const byte*)"\x71\x09" "enumerate")
QDEF(MP_QSTR_equal, (const byte*)"\x89\x05" "equal")
QDEF(MP_QSTR_erase_filesystem, (const byte*)"\x79\x10" "erase_filesystem")
QDEF(MP_QSTR_erf, (const byte*)"\x94\x03" "erf")
QDEF(MP_QSTR_erfc, (const byte*)"\x77\x04" "erfc")
QDEF(MP_QSTR_errno, (const byte*)"\xc1\x05" "errno")
QDEF(MP_QSTR_errorcode, (const byte*)"\x10\x09" "errorcode")
QDEF(MP_QSTR_eval, (const byte*)"\x9b\x04" "eval")
QDEF(MP_QSTR_exec, (const byte*)"\x1e\x04" "exec")
QDEF(MP_QSTR_exit, (const byte*)"\x85\x04" "exit")
QDEF(MP_QSTR_exp, (const byte*)"\xc8\x03" "exp")
QDEF(MP_QSTR_expm1, (const byte*)"\x74\x05" "expm1")
QDEF(MP_QSTR_ext_hook, (const byte*)"\x30\x08" "ext_hook")
QDEF(MP_QSTR_extend, (const byte*)"\x63\x06" "extend")
QDEF(MP_QSTR_extra_clocks, (const byte*)"\x1b\x0c" "extra_clocks")
QDEF(MP_QSTR_eye, (const byte*)"\xbc\x03" "eye")
QDEF(MP_QSTR_fabs, (const byte*)"\x93\x04" "fabs")
QDEF(MP_QSTR_fatol, (const byte*)"\x95\x05" "fatol")
QDEF(MP_QSTR_fft, (const byte*)"\x91\x03" "fft")
QDEF(MP_QSTR_file, (const byte*)"\xc3\x04" "file")
QDEF(MP_QSTR_filename, (const byte*)"\xe4\x08" "filename")
QDEF(MP_QSTR_filename2, (const byte*)"\x56\x09" "filename2")
QDEF(MP_QSTR_filter, (const byte*)"\x25\x06" "filter")
QDEF(MP_QSTR_find, (const byte*)"\x01\x04" "find")
QDEF(MP_QSTR_flatten, (const byte*)"\x25\x07" "flatten")
QDEF(MP_QSTR_flip, (const byte*)"\x76\x04" "flip")
QDEF(MP_QSTR_float, (const byte*)"\x35\x05" "float")
QDEF(MP_QSTR_floor, (const byte*)"\x7d\x05" "floor")
QDEF(MP_QSTR_flush, (const byte*)"\x61\x05" "flush")
QDEF(MP_QSTR_fmin, (const byte*)"\x29\x04" "fmin")
QDEF(MP_QSTR_fmod, (const byte*)"\xe5\x04" "fmod")
QDEF(MP_QSTR_format, (const byte*)"\x26\x06" "format")
QDEF(MP_QSTR_frequency, (const byte*)"\xa1\x09" "frequency")
QDEF(MP_QSTR_frexp, (const byte*)"\x1c\x05" "frexp")
QDEF(MP_QSTR_from_bytes, (const byte*)"\x35\x0a" "from_bytes")
QDEF(MP_QSTR_frombuffer, (const byte*)"\x93\x0a" "frombuffer")
QDEF(MP_QSTR_fromkeys, (const byte*)"\x37\x08" "fromkeys")
QDEF(MP_QSTR_frozenset, (const byte*)"\xed\x09" "frozenset")
QDEF(MP_QSTR_full, (const byte*)"\xd6\x04" "full")
QDEF(MP_QSTR_function, (const byte*)"\x27\x08" "function")
QDEF(MP_QSTR_gamepad, (const byte*)"\x3e\x07" "gamepad")
QDEF(MP_QSTR_gamma, (const byte*)"\x02\x05" "gamma")
QDEF(MP_QSTR_gc, (const byte*)"\x61\x02" "gc")
QDEF(MP_QSTR_generator, (const byte*)"\x96\x09" "generator")
QDEF(MP_QSTR_get, (const byte*)"\x33\x03" "get")
QDEF(MP_QSTR_get_pressed, (const byte*)"\xea\x0b" "get_pressed")
QDEF(MP_QSTR_get_printoptions, (const byte*)"\x4d\x10" "get_printoptions")
QDEF(MP_QSTR_getattr, (const byte*)"\xc0\x07" "getattr")
QDEF(MP_QSTR_getcwd, (const byte*)"\x03\x06" "getcwd")
QDEF(MP_QSTR_getmount, (const byte*)"\xde\x08" "getmount")
QDEF(MP_QSTR_getrandbits, (const byte*)"\x66\x0b" "getrandbits")
QDEF(MP_QSTR_getter, (const byte*)"\x90\x06" "getter")
QDEF(MP_QSTR_getvalue, (const byte*)"\x78\x08" "getvalue")
QDEF(MP_QSTR_globals, (const byte*)"\x9d\x07" "globals")
QDEF(MP_QSTR_group, (const byte*)"\xba\x05" "group")
QDEF(MP_QSTR_groups, (const byte*)"\x89\x06" "groups")
QDEF(MP_QSTR_hasattr, (const byte*)"\x8c\x07" "hasattr")
QDEF(MP_QSTR_hash, (const byte*)"\xb7\x04" "hash")
QDEF(MP_QSTR_heap_lock, (const byte*)"\xad\x09" "heap_lock")
QDEF(MP_QSTR_heap_unlock, (const byte*)"\x56\x0b" "heap_unlock")
QDEF(MP_QSTR_help, (const byte*)"\x94\x04" "help")
QDEF(MP_QSTR_hex, (const byte*)"\x70\x03" "hex")
QDEF(MP_QSTR_hexlify, (const byte*)"\x2a\x07" "hexlify")
QDEF(MP_QSTR_i2c, (const byte*)"\x5d\x03" "i2c")
QDEF(MP_QSTR_i2c_device, (const byte*)"\x9a\x0a" "i2c_device")
QDEF(MP_QSTR_id, (const byte*)"\x28\x02" "id")
QDEF(MP_QSTR_ifft, (const byte*)"\xf8\x04" "ifft")
QDEF(MP_QSTR_ilistdir, (const byte*)"\x71\x08" "ilistdir")
QDEF(MP_QSTR_imag, (const byte*)"\x47\x04" "imag")
QDEF(MP_QSTR_implementation, (const byte*)"\x17\x0e" "implementation")
QDEF(MP_QSTR_in_buffer, (const byte*)"\x1d\x09" "in_buffer")
QDEF(MP_QSTR_in_end, (const byte*)"\xf2\x06" "in_end")
QDEF(MP_QSTR_in_start, (const byte*)"\x7d\x08" "in_start")
QDEF(MP_QSTR_in_waiting, (const byte*)"\xd6\x0a" "in_waiting")
QDEF(MP_QSTR_index, (const byte*)"\x7b\x05" "index")
QDEF(MP_QSTR_indices, (const byte*)"\x5a\x07" "indices")
QDEF(MP_QSTR_inf, (const byte*)"\x04\x03" "inf")
QDEF(MP_QSTR_input, (const byte*)"\x73\x05" "input")
QDEF(MP_QSTR_insert, (const byte*)"\x12\x06" "insert")
QDEF(MP_QSTR_int, (const byte*)"\x16\x03" "int")
QDEF(MP_QSTR_int16, (const byte*)"\xf1\x05" "int16")
QDEF(MP_QSTR_int8, (const byte*)"\xee\x04" "int8")
QDEF(MP_QSTR_interp, (const byte*)"\xf1\x06" "interp")
QDEF(MP_QSTR_intersection, (const byte*)"\x28\x0c" "intersection")
QDEF(MP_QSTR_intersection_update, (const byte*)"\x06\x13" "intersection_update")
QDEF(MP_QSTR_inv, (const byte*)"\x14\x03" "inv")
QDEF(MP_QSTR_io, (const byte*)"\x23\x02" "io")
QDEF(MP_QSTR_ioctl, (const byte*)"\x78\x05" "ioctl")
QDEF(MP_QSTR_isalpha, (const byte*)"\xeb\x07" "isalpha")
QDEF(MP_QSTR_isdigit, (const byte*)"\xa8\x07" "isdigit")
QDEF(MP_QSTR_isdisjoint, (const byte*)"\xf7\x0a" "isdisjoint")
QDEF(MP_QSTR_isenabled, (const byte*)"\x9a\x09" "isenabled")
QDEF(MP_QSTR_isfinite, (const byte*)"\xa6\x08" "isfinite")
QDEF(MP_QSTR_isinf, (const byte*)"\x3e\x05" "isinf")
QDEF(MP_QSTR_isinstance, (const byte*)"\xb6\x0a" "isinstance")
QDEF(MP_QSTR_islower, (const byte*)"\xfc\x07" "islower")
QDEF(MP_QSTR_isnan, (const byte*)"\x9e\x05" "isnan")
QDEF(MP_QSTR_isspace, (const byte*)"\x5b\x07" "isspace")
QDEF(MP_QSTR_issubclass, (const byte*)"\xb5\x0a" "issubclass")
QDEF(MP_QSTR_issubset, (const byte*)"\xb9\x08" "issubset")
QDEF(MP_QSTR_issuperset, (const byte*)"\xfc\x0a" "issuperset")
QDEF(MP_QSTR_isupper, (const byte*)"\xdd\x07" "isupper")
QDEF(MP_QSTR_items, (const byte*)"\xe3\x05" "items")
QDEF(MP_QSTR_itemsize, (const byte*)"\x75\x08" "itemsize")
QDEF(MP_QSTR_iter, (const byte*)"\x8f\x04" "iter")
QDEF(MP_QSTR_iterable, (const byte*)"\x25\x08" "iterable")
QDEF(MP_QSTR_iterator, (const byte*)"\x47\x08" "iterator")
QDEF(MP_QSTR_join, (const byte*)"\xa7\x04" "join")
QDEF(MP_QSTR_json, (const byte*)"\xfd\x04" "json")
QDEF(MP_QSTR_k, (const byte*)"\xce\x01" "k")
QDEF(MP_QSTR_kbd_intr, (const byte*)"\xf6\x08" "kbd_intr")
QDEF(MP_QSTR_keepends, (const byte*)"\x62\x08" "keepends")
QDEF(MP_QSTR_key, (const byte*)"\x32\x03" "key")
QDEF(MP_QSTR_keys, (const byte*)"\x01\x04" "keys")
QDEF(MP_QSTR_label, (const byte*)"\x43\x05" "label")
QDEF(MP_QSTR_ldexp, (const byte*)"\x40\x05" "ldexp")
QDEF(MP_QSTR_left, (const byte*)"\xde\x04" "left")
QDEF(MP_QSTR_len, (const byte*)"\x62\x03" "len")
QDEF(MP_QSTR_length, (const byte*)"\x59\x06" "length")
QDEF(MP_QSTR_lgamma, (const byte*)"\xce\x06" "lgamma")
QDEF(MP_QSTR_linalg, (const byte*)"\x44\x06" "linalg")
QDEF(MP_QSTR_linspace, (const byte*)"\x6a\x08" "linspace")
QDEF(MP_QSTR_list, (const byte*)"\x27\x04" "list")
QDEF(MP_QSTR_listdir, (const byte*)"\x98\x07" "listdir")
QDEF(MP_QSTR_little, (const byte*)"\x89\x06" "little")
QDEF(MP_QSTR_load, (const byte*)"\x63\x04" "load")
QDEF(MP_QSTR_loads, (const byte*)"\xb0\x05" "loads")
QDEF(MP_QSTR_locals, (const byte*)"\x3b\x06" "locals")
QDEF(MP_QSTR_localtime, (const byte*)"\x7d\x09" "localtime")
QDEF(MP_QSTR_log, (const byte*)"\x21\x03" "log")
QDEF(MP_QSTR_log10, (const byte*)"\x40\x05" "log10")
QDEF(MP_QSTR_log2, (const byte*)"\x73\x04" "log2")
QDEF(MP_QSTR_logspace, (const byte*)"\x85\x08" "logspace")
QDEF(MP_QSTR_lower, (const byte*)"\xc6\x05" "lower")
QDEF(MP_QSTR_lstrip, (const byte*)"\xe5\x06" "lstrip")
QDEF(MP_QSTR_machine, (const byte*)"\x60\x07" "machine")
QDEF(MP_QSTR_map, (const byte*)"\xb9\x03" "map")
QDEF(MP_QSTR_match, (const byte*)"\x96\x05" "match")
QDEF(MP_QSTR_math, (const byte*)"\x35\x04" "math")
QDEF(MP_QSTR_max, (const byte*)"\xb1\x03" "max")
QDEF(MP_QSTR_maximum, (const byte*)"\x6d\x07" "maximum")
QDEF(MP_QSTR_maxiter, (const byte*)"\x3b\x07" "maxiter")
QDEF(MP_QSTR_maxsize, (const byte*)"\xd4\x07" "maxsize")
QDEF(MP_QSTR_mean, (const byte*)"\xc2\x04" "mean")
QDEF(MP_QSTR_median, (const byte*)"\x0f\x06" "median")
QDEF(MP_QSTR_mem_alloc, (const byte*)"\x52\x09" "mem_alloc")
QDEF(MP_QSTR_mem_free, (const byte*)"\xcb\x08" "mem_free")
QDEF(MP_QSTR_memoryview, (const byte*)"\x69\x0a" "memoryview")
QDEF(MP_QSTR_microcontroller, (const byte*)"\xa3\x0f" "microcontroller")
QDEF(MP_QSTR_micropython, (const byte*)"\x0b\x0b" "micropython")
QDEF(MP_QSTR_min, (const byte*)"\xaf\x03" "min")
QDEF(MP_QSTR_minimum, (const byte*)"\x73\x07" "minimum")
QDEF(MP_QSTR_mkdir, (const byte*)"\x9c\x05" "mkdir")
QDEF(MP_QSTR_mkfs, (const byte*)"\x76\x04" "mkfs")
QDEF(MP_QSTR_mktime, (const byte*)"\x96\x06" "mktime")
QDEF(MP_QSTR_mode, (const byte*)"\x26\x04" "mode")
QDEF(MP_QSTR_modf, (const byte*)"\x25\x04" "modf")
QDEF(MP_QSTR_module, (const byte*)"\xbf\x06" "module")
QDEF(MP_QSTR_modules, (const byte*)"\xec\x07" "modules")
QDEF(MP_QSTR_monotonic, (const byte*)"\x19\x09" "monotonic")
QDEF(MP_QSTR_monotonic_ns, (const byte*)"\x3b\x0c" "monotonic_ns")
QDEF(MP_QSTR_mount, (const byte*)"\xa8\x05" "mount")
QDEF(MP_QSTR_msgpack, (const byte*)"\x45\x07" "msgpack")
QDEF(MP_QSTR_n, (const byte*)"\xcb\x01" "n")
QDEF(MP_QSTR_name, (const byte*)"\xa2\x04" "name")
QDEF(MP_QSTR_namedtuple, (const byte*)"\x1e\x0a" "namedtuple")
QDEF(MP_QSTR_nan, (const byte*)"\xe4\x03" "nan")
QDEF(MP_QSTR_native, (const byte*)"\x84\x06" "native")
QDEF(MP_QSTR_ndarray, (const byte*)"\x76\x07" "ndarray")
QDEF(MP_QSTR_ndinfo, (const byte*)"\xa1\x06" "ndinfo")
QDEF(MP_QSTR_newton, (const byte*)"\x4c\x06" "newton")
QDEF(MP_QSTR_next, (const byte*)"\x42\x04" "next")
QDEF(MP_QSTR_nodename, (const byte*)"\x62\x08" "nodename")
QDEF(MP_QSTR_norm, (const byte*)"\x1b\x04" "norm")
QDEF(MP_QSTR_not_equal, (const byte*)"\x63\x09" "not_equal")
QDEF(MP_QSTR_num, (const byte*)"\x73\x03" "num")
QDEF(MP_QSTR_numerical, (const byte*)"\xc3\x09" "numerical")
QDEF(MP_QSTR_nvm, (const byte*)"\x90\x03" "nvm")
QDEF(MP_QSTR_obj, (const byte*)"\x02\x03" "obj")
QDEF(MP_QSTR_object, (const byte*)"\x90\x06" "object")
QDEF(MP_QSTR_oct, (const byte*)"\xfd\x03" "oct")
QDEF(MP_QSTR_offset, (const byte*)"\x48\x06" "offset")
QDEF(MP_QSTR_on_next_reset, (const byte*)"\xb6\x0d" "on_next_reset")
QDEF(MP_QSTR_ones, (const byte*)"\xd2\x04" "ones")
QDEF(MP_QSTR_open, (const byte*)"\xd1\x04" "open")
QDEF(MP_QSTR_opt_level, (const byte*)"\x87\x09" "opt_level")
QDEF(MP_QSTR_ord, (const byte*)"\x1c\x03" "ord")
QDEF(MP_QSTR_order, (const byte*)"\x6b\x05" "order")
QDEF(MP_QSTR_os, (const byte*)"\x79\x02" "os")
QDEF(MP_QSTR_otypes, (const byte*)"\xe1\x06" "otypes")
QDEF(MP_QSTR_out_buffer, (const byte*)"\xf4\x0a" "out_buffer")
QDEF(MP_QSTR_out_end, (const byte*)"\x7b\x07" "out_end")
QDEF(MP_QSTR_out_start, (const byte*)"\xf4\x09" "out_start")
QDEF(MP_QSTR_pack, (const byte*)"\xbc\x04" "pack")
QDEF(MP_QSTR_pack_into, (const byte*)"\x1f\x09" "pack_into")
QDEF(MP_QSTR_parity, (const byte*)"\x42\x06" "parity")
QDEF(MP_QSTR_partition, (const byte*)"\x87\x09" "partition")
QDEF(MP_QSTR_path, (const byte*)"\x88\x04" "path")
QDEF(MP_QSTR_pend_throw, (const byte*)"\xf3\x0a" "pend_throw")
QDEF(MP_QSTR_phase, (const byte*)"\x6a\x05" "phase")
QDEF(MP_QSTR_pi, (const byte*)"\x1c\x02" "pi")
QDEF(MP_QSTR_pin, (const byte*)"\xf2\x03" "pin")
QDEF(MP_QSTR_polarity, (const byte*)"\x41\x08" "polarity")
QDEF(MP_QSTR_poly, (const byte*)"\x8f\x04" "poly")
QDEF(MP_QSTR_polyfit, (const byte*)"\x34\x07" "polyfit")
QDEF(MP_QSTR_polyval, (const byte*)"\x34\x07" "polyval")
QDEF(MP_QSTR_pop, (const byte*)"\x2a\x03" "pop")
QDEF(MP_QSTR_popitem, (const byte*)"\xbf\x07" "popitem")
QDEF(MP_QSTR_pow, (const byte*)"\x2d\x03" "pow")
QDEF(MP_QSTR_print, (const byte*)"\x54\x05" "print")
QDEF(MP_QSTR_print_exception, (const byte*)"\x1c\x0f" "print_exception")
QDEF(MP_QSTR_probe, (const byte*)"\x4f\x05" "probe")
QDEF(MP_QSTR_property, (const byte*)"\xc2\x08" "property")
QDEF(MP_QSTR_protocol_pin, (const byte*)"\x1b\x0c" "protocol_pin")
QDEF(MP_QSTR_protocol_stream, (const byte*)"\x90\x0f" "protocol_stream")
QDEF(MP_QSTR_protocol_vfs, (const byte*)"\xef\x0c" "protocol_vfs")
QDEF(MP_QSTR_pull, (const byte*)"\x80\x04" "pull")
QDEF(MP_QSTR_pystack_use, (const byte*)"\xfe\x0b" "pystack_use")
QDEF(MP_QSTR_r, (const byte*)"\xd7\x01" "r")
QDEF(MP_QSTR_radians, (const byte*)"\x87\x07" "radians")
QDEF(MP_QSTR_randint, (const byte*)"\xaf\x07" "randint")
QDEF(MP_QSTR_random, (const byte*)"\xbe\x06" "random")
QDEF(MP_QSTR_randrange, (const byte*)"\xa3\x09" "randrange")
QDEF(MP_QSTR_range, (const byte*)"\x1a\x05" "range")
QDEF(MP_QSTR_raw_value, (const byte*)"\xf5\x09" "raw_value")
QDEF(MP_QSTR_re, (const byte*)"\xd2\x02" "re")
QDEF(MP_QSTR_read, (const byte*)"\xb7\x04" "read")
QDEF(MP_QSTR_read_bit, (const byte*)"\x97\x08" "read_bit")
QDEF(MP_QSTR_readblocks, (const byte*)"\x2d\x0a" "readblocks")
QDEF(MP_QSTR_readfrom_into, (const byte*)"\x82\x0d" "readfrom_into")
QDEF(MP_QSTR_readinto, (const byte*)"\x4b\x08" "readinto")
QDEF(MP_QSTR_readline, (const byte*)"\xf9\x08" "readline")
QDEF(MP_QSTR_readlines, (const byte*)"\x6a\x09" "readlines")
QDEF(MP_QSTR_readonly, (const byte*)"\x03\x08" "readonly")
QDEF(MP_QSTR_real, (const byte*)"\xbf\x04" "real")
QDEF(MP_QSTR_receiver_buffer_size, (const byte*)"\x99\x14" "receiver_buffer_size")
QDEF(MP_QSTR_release, (const byte*)"\xec\x07" "release")
QDEF(MP_QSTR_reload, (const byte*)"\x74\x06" "reload")
QDEF(MP_QSTR_remount, (const byte*)"\x9f\x07" "remount")
QDEF(MP_QSTR_remove, (const byte*)"\x63\x06" "remove")
QDEF(MP_QSTR_rename, (const byte*)"\x35\x06" "rename")
QDEF(MP_QSTR_replace, (const byte*)"\x49\x07" "replace")
QDEF(MP_QSTR_repr, (const byte*)"\xd0\x04" "repr")
QDEF(MP_QSTR_reset, (const byte*)"\x10\x05" "reset")
QDEF(MP_QSTR_reset_input_buffer, (const byte*)"\xe6\x12" "reset_input_buffer")
QDEF(MP_QSTR_reset_reason, (const byte*)"\x0b\x0c" "reset_reason")
QDEF(MP_QSTR_reshape, (const byte*)"\x7d\x07" "reshape")
QDEF(MP_QSTR_retstep, (const byte*)"\x34\x07" "retstep")
QDEF(MP_QSTR_reverse, (const byte*)"\x25\x07" "reverse")
QDEF(MP_QSTR_reversed, (const byte*)"\xa1\x08" "reversed")
QDEF(MP_QSTR_rfind, (const byte*)"\xd2\x05" "rfind")
QDEF(MP_QSTR_right, (const byte*)"\xe5\x05" "right")
QDEF(MP_QSTR_rindex, (const byte*)"\xe9\x06" "rindex")
QDEF(MP_QSTR_rmdir, (const byte*)"\x45\x05" "rmdir")
QDEF(MP_QSTR_roll, (const byte*)"\x58\x04" "roll")
QDEF(MP_QSTR_round, (const byte*)"\xe7\x05" "round")
QDEF(MP_QSTR_rpartition, (const byte*)"\x15\x0a" "rpartition")
QDEF(MP_QSTR_rs485_dir, (const byte*)"\xdd\x09" "rs485_dir")
QDEF(MP_QSTR_rs485_invert, (const byte*)"\xb0\x0c" "rs485_invert")
QDEF(MP_QSTR_rsplit, (const byte*)"\xa5\x06" "rsplit")
QDEF(MP_QSTR_rstrip, (const byte*)"\x3b\x06" "rstrip")
QDEF(MP_QSTR_rtol, (const byte*)"\xa0\x04" "rtol")
QDEF(MP_QSTR_rts, (const byte*)"\x50\x03" "rts")
QDEF(MP_QSTR_run_reason, (const byte*)"\x77\x0a" "run_reason")
QDEF(MP_QSTR_runtime, (const byte*)"\x99\x07" "runtime")
QDEF(MP_QSTR_rx, (const byte*)"\xcf\x02" "rx")
QDEF(MP_QSTR_scan, (const byte*)"\x1a\x04" "scan")
QDEF(MP_QSTR_scl, (const byte*)"\xf9\x03" "scl")
QDEF(MP_QSTR_sda, (const byte*)"\x53\x03" "sda")
QDEF(MP_QSTR_sdcardio, (const byte*)"\xa0\x08" "sdcardio")
QDEF(MP_QSTR_sdio, (const byte*)"\xd4\x04" "sdio")
QDEF(MP_QSTR_search, (const byte*)"\xab\x06" "search")
QDEF(MP_QSTR_seed, (const byte*)"\x92\x04" "seed")
QDEF(MP_QSTR_seek, (const byte*)"\x9d\x04" "seek")
QDEF(MP_QSTR_send, (const byte*)"\xb9\x04" "send")
QDEF(MP_QSTR_sep, (const byte*)"\x23\x03" "sep")
QDEF(MP_QSTR_serial_bytes_available, (const byte*)"\x45\x16" "serial_bytes_available")
QDEF(MP_QSTR_serial_connected, (const byte*)"\xa5\x10" "serial_connected")
QDEF(MP_QSTR_set, (const byte*)"\x27\x03" "set")
QDEF(MP_QSTR_set_next_stack_limit, (const byte*)"\xa4\x14" "set_next_stack_limit")
QDEF(MP_QSTR_set_printoptions, (const byte*)"\xd9\x10" "set_printoptions")
QDEF(MP_QSTR_set_rgb_status_brightness, (const byte*)"\x92\x19" "set_rgb_status_brightness")
QDEF(MP_QSTR_setattr, (const byte*)"\xd4\x07" "setattr")
QDEF(MP_QSTR_setdefault, (const byte*)"\x6c\x0a" "setdefault")
QDEF(MP_QSTR_setter, (const byte*)"\x04\x06" "setter")
QDEF(MP_QSTR_shape, (const byte*)"\xca\x05" "shape")
QDEF(MP_QSTR_signed, (const byte*)"\x37\x06" "signed")
QDEF(MP_QSTR_sin, (const byte*)"\xb1\x03" "sin")
QDEF(MP_QSTR_sinh, (const byte*)"\xb9\x04" "sinh")
QDEF(MP_QSTR_size, (const byte*)"\x20\x04" "size")
QDEF(MP_QSTR_sleep, (const byte*)"\xea\x05" "sleep")
QDEF(MP_QSTR_slice, (const byte*)"\xb5\x05" "slice")
QDEF(MP_QSTR_sort, (const byte*)"\xbf\x04" "sort")
QDEF(MP_QSTR_sorted, (const byte*)"\x5e\x06" "sorted")
QDEF(MP_QSTR_sos, (const byte*)"\x6a\x03" "sos")
QDEF(MP_QSTR_sosfilt, (const byte*)"\xbd\x07" "sosfilt")
QDEF(MP_QSTR_span, (const byte*)"\xc9\x04" "span")
QDEF(MP_QSTR_spectrogram, (const byte*)"\x30\x0b" "spectrogram")
QDEF(MP_QSTR_spi, (const byte*)"\xcf\x03" "spi")
QDEF(MP_QSTR_spi_device, (const byte*)"\xc8\x0a" "spi_device")
QDEF(MP_QSTR_split, (const byte*)"\xb7\x05" "split")
QDEF(MP_QSTR_splitlines, (const byte*)"\x6a\x0a" "splitlines")
QDEF(MP_QSTR_sqrt, (const byte*)"\x21\x04" "sqrt")
QDEF(MP_QSTR_start, (const byte*)"\x85\x05" "start")
QDEF(MP_QSTR_startswith, (const byte*)"\x74\x0a" "startswith")
QDEF(MP_QSTR_stat, (const byte*)"\xd7\x04" "stat")
QDEF(MP_QSTR_staticmethod, (const byte*)"\x62\x0c" "staticmethod")
QDEF(MP_QSTR_statvfs, (const byte*)"\x14\x07" "statvfs")
QDEF(MP_QSTR_std, (const byte*)"\x46\x03" "std")
QDEF(MP_QSTR_stderr, (const byte*)"\xa3\x06" "stderr")
QDEF(MP_QSTR_stdin, (const byte*)"\x21\x05" "stdin")
QDEF(MP_QSTR_stdout, (const byte*)"\x08\x06" "stdout")
QDEF(MP_QSTR_step, (const byte*)"\x57\x04" "step")
QDEF(MP_QSTR_stop, (const byte*)"\x9d\x04" "stop")
QDEF(MP_QSTR_storage, (const byte*)"\xbc\x07" "storage")
QDEF(MP_QSTR_str, (const byte*)"\x50\x03" "str")
QDEF(MP_QSTR_strerror, (const byte*)"\x48\x08" "strerror")
QDEF(MP_QSTR_strides, (const byte*)"\xcb\x07" "strides")
QDEF(MP_QSTR_strip, (const byte*)"\x29\x05" "strip")
QDEF(MP_QSTR_struct, (const byte*)"\x12\x06" "struct")
QDEF(MP_QSTR_struct_time, (const byte*)"\xf8\x0b" "struct_time")
QDEF(MP_QSTR_sub, (const byte*)"\x21\x03" "sub")
QDEF(MP_QSTR_sum, (const byte*)"\x2e\x03" "sum")
QDEF(MP_QSTR_super, (const byte*)"\xc4\x05" "super")
QDEF(MP_QSTR_supervisor, (const byte*)"\x35\x0a" "supervisor")
QDEF(MP_QSTR_switch_to_input, (const byte*)"\xfa\x0f" "switch_to_input")
QDEF(MP_QSTR_switch_to_output, (const byte*)"\xf3\x10" "switch_to_output")
QDEF(MP_QSTR_symmetric_difference, (const byte*)"\xce\x14" "symmetric_difference")
QDEF(MP_QSTR_symmetric_difference_update, (const byte*)"\x60\x1b" "symmetric_difference_update")
QDEF(MP_QSTR_sync, (const byte*)"\xa2\x04" "sync")
QDEF(MP_QSTR_sys, (const byte*)"\xbc\x03" "sys")
QDEF(MP_QSTR_sysname, (const byte*)"\x9b\x07" "sysname")
QDEF(MP_QSTR_tan, (const byte*)"\xfe\x03" "tan")
QDEF(MP_QSTR_tanh, (const byte*)"\xd6\x04" "tanh")
QDEF(MP_QSTR_tell, (const byte*)"\x14\x04" "tell")
QDEF(MP_QSTR_temperature, (const byte*)"\xe9\x0b" "temperature")
QDEF(MP_QSTR_threshold, (const byte*)"\xf2\x09" "threshold")
QDEF(MP_QSTR_throw, (const byte*)"\xb3\x05" "throw")
QDEF(MP_QSTR_time, (const byte*)"\xf0\x04" "time")
QDEF(MP_QSTR_timeout, (const byte*)"\x3e\x07" "timeout")
QDEF(MP_QSTR_tm_hour, (const byte*)"\xa3\x07" "tm_hour")
QDEF(MP_QSTR_tm_isdst, (const byte*)"\xda\x08" "tm_isdst")
QDEF(MP_QSTR_tm_mday, (const byte*)"\xd2\x07" "tm_mday")
QDEF(MP_QSTR_tm_min, (const byte*)"\xa9\x06" "tm_min")
QDEF(MP_QSTR_tm_mon, (const byte*)"\x6f\x06" "tm_mon")
QDEF(MP_QSTR_tm_sec, (const byte*)"\x36\x06" "tm_sec")
QDEF(MP_QSTR_tm_wday, (const byte*)"\x08\x07" "tm_wday")
QDEF(MP_QSTR_tm_yday, (const byte*)"\x46\x07" "tm_yday")
QDEF(MP_QSTR_tm_year, (const byte*)"\x8c\x07" "tm_year")
QDEF(MP_QSTR_to_bytes, (const byte*)"\xd8\x08" "to_bytes")
QDEF(MP_QSTR_tobytes, (const byte*)"\xa7\x07" "tobytes")
QDEF(MP_QSTR_tol, (const byte*)"\x32\x03" "tol")
QDEF(MP_QSTR_touchio, (const byte*)"\x66\x07" "touchio")
QDEF(MP_QSTR_trace, (const byte*)"\xa4\x05" "trace")
QDEF(MP_QSTR_transpose, (const byte*)"\xf6\x09" "transpose")
QDEF(MP_QSTR_trapz, (const byte*)"\x88\x05" "trapz")
QDEF(MP_QSTR_trunc, (const byte*)"\x5b\x05" "trunc")
QDEF(MP_QSTR_try_lock, (const byte*)"\x2e\x08" "try_lock")
QDEF(MP_QSTR_tuple, (const byte*)"\xfd\x05" "tuple")
QDEF(MP_QSTR_tx, (const byte*)"\x89\x02" "tx")
QDEF(MP_QSTR_type, (const byte*)"\x9d\x04" "type")
QDEF(MP_QSTR_uid, (const byte*)"\xbd\x03" "uid")
QDEF(MP_QSTR_uint16, (const byte*)"\x84\x06" "uint16")
QDEF(MP_QSTR_uint8, (const byte*)"\x7b\x05" "uint8")
QDEF(MP_QSTR_uio, (const byte*)"\xb6\x03" "uio")
QDEF(MP_QSTR_ulab, (const byte*)"\x9f\x04" "ulab")
QDEF(MP_QSTR_umount, (const byte*)"\xdd\x06" "umount")
QDEF(MP_QSTR_uname, (const byte*)"\xb7\x05" "uname")
QDEF(MP_QSTR_unhexlify, (const byte*)"\xb1\x09" "unhexlify")
QDEF(MP_QSTR_uniform, (const byte*)"\x01\x07" "uniform")
QDEF(MP_QSTR_union, (const byte*)"\xf6\x05" "union")
QDEF(MP_QSTR_unlink, (const byte*)"\xfe\x06" "unlink")
QDEF(MP_QSTR_unlock, (const byte*)"\x15\x06" "unlock")
QDEF(MP_QSTR_unpack, (const byte*)"\x07\x06" "unpack")
QDEF(MP_QSTR_unpack_from, (const byte*)"\x0e\x0b" "unpack_from")
QDEF(MP_QSTR_update, (const byte*)"\xb4\x06" "update")
QDEF(MP_QSTR_upper, (const byte*)"\x27\x05" "upper")
QDEF(MP_QSTR_urandom, (const byte*)"\xab\x07" "urandom")
QDEF(MP_QSTR_use_list, (const byte*)"\x9b\x08" "use_list")
QDEF(MP_QSTR_v, (const byte*)"\xd3\x01" "v")
QDEF(MP_QSTR_value, (const byte*)"\x4e\x05" "value")
QDEF(MP_QSTR_values, (const byte*)"\x7d\x06" "values")
QDEF(MP_QSTR_vector, (const byte*)"\xdc\x06" "vector")
QDEF(MP_QSTR_vectorize, (const byte*)"\xea\x09" "vectorize")
QDEF(MP_QSTR_version, (const byte*)"\xbf\x07" "version")
QDEF(MP_QSTR_version_info, (const byte*)"\x6e\x0c" "version_info")
QDEF(MP_QSTR_voltage, (const byte*)"\x87\x07" "voltage")
QDEF(MP_QSTR_watchdog, (const byte*)"\x01\x08" "watchdog")
QDEF(MP_QSTR_write, (const byte*)"\x98\x05" "write")
QDEF(MP_QSTR_write_bit, (const byte*)"\xf8\x09" "write_bit")
QDEF(MP_QSTR_write_readinto, (const byte*)"\x89\x0e" "write_readinto")
QDEF(MP_QSTR_write_then_readinto, (const byte*)"\x61\x13" "write_then_readinto")
QDEF(MP_QSTR_write_value, (const byte*)"\x4c\x0b" "write_value")
QDEF(MP_QSTR_writeblocks, (const byte*)"\x02\x0b" "writeblocks")
QDEF(MP_QSTR_writeto, (const byte*)"\x03\x07" "writeto")
QDEF(MP_QSTR_writeto_then_readfrom, (const byte*)"\x70\x15" "writeto_then_readfrom")
QDEF(MP_QSTR_x, (const byte*)"\xdd\x01" "x")
QDEF(MP_QSTR_xatol, (const byte*)"\x0b\x05" "xatol")
QDEF(MP_QSTR_xtol, (const byte*)"\x6a\x04" "xtol")
QDEF(MP_QSTR_zeros, (const byte*)"\x94\x05" "zeros")
QDEF(MP_QSTR_zi, (const byte*)"\xd6\x02" "zi")
QDEF(MP_QSTR_zip, (const byte*)"\xe6\x03" "zip")
TRANSLATION("  File \"%q\", line %d", 20, 0, 247, 165, 50, 15, 223, 127, 131, 247, 236, 4, 228, 100, 23, 226) //   File \"%q\", line %d
TRANSLATION(" is of type %q\n", 16, 211, 74, 185, 129, 127, 131, 63, 56) //  is of type %q\r\n
TRANSLATION(" output:\n", 10, 4, 163, 219, 71, 233, 103, 231, 0) //  output:\r\n
TRANSLATION("%%c requires int or char", 24, 191, 126, 30, 187, 105, 63, 38, 21, 138, 128) // %%c requires int or char
TRANSLATION("%q in use", 9, 191, 193, 164, 20, 98) // %q in use
TRANSLATION("%q index out of range", 21, 191, 193, 165, 18, 205, 234, 253, 128) // %q index out of range
TRANSLATION("%q indices must be integers, not %q", 35, 191, 193, 165, 25, 64, 154, 247, 252, 109, 141, 75, 252, 0) // %q indices must be integers, not %q
TRANSLATION("'%q' argument required", 22, 193, 127, 131, 6, 135, 175, 16) // \'%q\' argument required
TRANSLATION("'%q' object cannot assign attribute '%q'", 40, 193, 127, 131, 7, 28, 33, 221, 22, 105, 99, 48, 31, 195, 136) // \'%q\' object cannot assign attribute \'%q\'
TRANSLATION("'%q' object does not support '%q'", 33, 193, 127, 131, 7, 28, 34, 132, 218, 141, 75, 109, 69, 126, 32) // \'%q\' object does not support \'%q\'
TRANSLATION("'%q' object does not support item assignment", 44, 193, 127, 131, 7, 28, 34, 132, 218, 141, 75, 109, 69, 112, 147, 149, 128, 44, 210, 198, 118, 17, 184) // \'%q\' object does not support item assignment
TRANSLATION("'%q' object does not support item deletion", 42, 193, 127, 131, 7, 28, 34, 132, 218, 141, 75, 109, 69, 112, 147, 149, 129, 18, 153, 112, 128) // \'%q\' object does not support item deletion
TRANSLATION("'%q' object has no attribute '%q'", 33, 193, 127, 131, 7, 28, 43, 22, 3, 64, 31, 195, 136) // \'%q\' object has no attribute \'%q\'
TRANSLATION("'%q' object is not an iterator", 30, 193, 127, 131, 7, 31, 79, 198, 38, 18, 127, 152) // \'%q\' object is not an iterator
TRANSLATION("'%q' object is not callable", 27, 193, 127, 131, 7, 31, 79, 199, 1, 156, 251, 128) // \'%q\' object is not callable
TRANSLATION("'%q' object is not iterable", 27, 193, 127, 131, 7, 31, 79, 199, 39, 37, 238, 0) // \'%q\' object is not iterable
TRANSLATION("'%q' object is not subscriptable", 32, 193, 127, 131, 7, 31, 79, 198, 212, 196, 208, 89, 90, 253, 192) // \'%q\' object is not subscriptable
TRANSLATION("'=' alignment not allowed in string format specifier", 52, 193, 252, 240, 0, 206, 88, 206, 194, 55, 212, 25, 205, 50, 148, 116, 131, 238, 226, 251, 36, 160) // \'=\' alignment not allowed in string format specifier
TRANSLATION("'await' outside function", 24, 192, 57, 70, 79, 131, 214, 240, 0) // \'await\' outside function
TRANSLATION("'await', 'async for' or 'async with' outside async function", 59, 192, 57, 70, 79, 131, 96, 48, 11, 92, 112, 10, 145, 112, 114, 112, 11, 92, 112, 230, 224, 245, 133, 174, 56, 7, 128) // \'await\', \'async for\' or \'async with\' outside async function
TRANSLATION("'break' outside loop", 20, 193, 137, 72, 119, 240, 122, 211, 68, 180) // \'break\' outside loop
TRANSLATION("'continue' outside loop", 23, 193, 4, 55, 145, 208, 176, 122, 211, 68, 180) // \'continue\' outside loop
TRANSLATION("'coroutine' object is not an iterator", 37, 193, 4, 84, 163, 200, 203, 7, 31, 79, 198, 38, 18, 127, 152) // \'coroutine\' object is not an iterator
TRANSLATION("'return' outside function", 25, 192, 164, 244, 83, 193, 235, 120, 0) // \'return\' outside function
TRANSLATION("'yield from' inside async function", 34, 193, 116, 138, 113, 10, 149, 44, 193, 164, 210, 137, 0, 181, 199, 0, 240, 0) // \'yield from\' inside async function
TRANSLATION("'yield' outside function", 24, 193, 116, 138, 113, 193, 235, 120, 0) // \'yield\' outside function
TRANSLATION("*x must be assignment target", 28, 246, 179, 94, 22, 105, 99, 59, 8, 220, 28, 87, 25, 56) // *x must be assignment target
TRANSLATION(", in %q\n", 9, 216, 210, 11, 252, 25, 249, 192) // , in %q\r\n
TRANSLATION("0.0 to a complex power", 22, 231, 225, 231, 234, 136, 65, 44, 182, 101, 152, 45, 76, 164, 160) // 0.0 to a complex power
TRANSLATION("64 bit types", 12, 254, 63, 192, 49, 73, 249, 140) // 64 bit types
TRANSLATION("All timers in use", 17, 233, 206, 97, 247, 171, 105, 5, 24, 128) // All timers in use
TRANSLATION("At most %d %q may be specified (not %d)", 39, 233, 184, 88, 140, 225, 126, 33, 127, 128, 44, 27, 131, 17, 123, 37, 16, 214, 241, 223, 142, 184) // At most %d %q may be specified (not %d)
TRANSLATION("Attempted heap allocation when MicroPython VM not running.", 58, 233, 187, 149, 150, 185, 68, 43, 33, 180, 6, 115, 72, 15, 8, 101, 172, 140, 58, 210, 130, 167, 99, 245, 15, 237, 214, 212, 90, 25, 200, 241, 225) // Attempted heap allocation when MicroPython VM not running.
TRANSLATION("Attribute not found", 19, 233, 254, 26, 149, 37, 14, 32) // Attribute not found
TRANSLATION("Attribute not long", 18, 233, 254, 26, 147, 67, 198) // Attribute not long
TRANSLATION("Auto-reload is off.\n", 21, 233, 209, 211, 101, 74, 104, 49, 211, 74, 170, 195, 159, 156) // Auto-reload is off.\r\n
TRANSLATION("Auto-reload is on. Simply save files over USB to run them or enter REPL to disable.\n", 85, 233, 209, 211, 101, 74, 104, 49, 211, 67, 194, 27, 146, 178, 217, 220, 12, 57, 11, 211, 96, 76, 132, 161, 218, 220, 247, 117, 86, 134, 15, 89, 89, 201, 35, 114, 80, 236, 245, 123, 31, 6, 172, 100, 221, 204, 57, 249, 192) // Auto-reload is on. Simply save files over USB to run them or enter REPL to disable.\r\n
TRANSLATION("Brightness must be between 0 and 255", 36, 247, 86, 88, 235, 115, 38, 107, 216, 137, 242, 145, 24, 115, 253, 14, 143, 185, 238, 0) // Brightness must be between 0 and 255
TRANSLATION("Buffer length must be a multiple of 512", 39, 247, 127, 30, 53, 225, 15, 165, 42, 15, 115, 161, 209) // Buffer length must be a multiple of 512
TRANSLATION("Buffer must be at least length 1", 32, 247, 127, 27, 194, 225, 50, 22, 126, 48, 116, 0) // Buffer must be at least length 1
TRANSLATION("Call super().__init__() before accessing native object.", 55, 218, 25, 204, 26, 150, 146, 235, 107, 225, 237, 246, 228, 114, 126, 223, 111, 91, 92, 49, 21, 72, 164, 3, 8, 19, 54, 241, 139, 203, 33, 113, 240, 128) // Call super().__init__() before accessing native object.
TRANSLATION("Cannot read without MISO pin.", 29, 218, 238, 169, 12, 121, 169, 71, 14, 182, 222, 231, 195, 202, 194) // Cannot read without MISO pin.
TRANSLATION("Cannot remount '/' when USB is active.", 38, 218, 238, 169, 88, 148, 55, 12, 28, 236, 1, 150, 178, 48, 237, 110, 123, 186, 99, 7, 150, 66, 194) // Cannot remount \'/\' when USB is active.
TRANSLATION("Cannot set value when direction is input.", 41, 218, 238, 177, 56, 126, 65, 150, 178, 48, 140, 148, 161, 195, 167, 225, 194) // Cannot set value when direction is input.
TRANSLATION("Cannot subclass slice", 21, 218, 238, 181, 49, 124, 128, 211, 148, 8) // Cannot subclass slice
TRANSLATION("Cannot transfer without MOSI and MISO pins.", 43, 218, 238, 186, 137, 181, 68, 188, 212, 163, 135, 91, 225, 220, 219, 244, 58, 219, 123, 159, 15, 41, 176, 128) // Cannot transfer without MOSI and MISO pins.
TRANSLATION("Cannot write without MOSI pin.", 30, 218, 238, 229, 89, 57, 115, 82, 142, 29, 111, 135, 115, 111, 149, 132) // Cannot write without MOSI pin.
TRANSLATION("CircuitPython core code crashed hard. Whoops!\n", 47, 218, 249, 251, 31, 168, 65, 20, 189, 16, 130, 139, 86, 81, 10, 197, 99, 132, 63, 189, 104, 150, 183, 238, 207, 206) // CircuitPython core code crashed hard. Whoops!\r\n
TRANSLATION("CircuitPython is in safe mode because you pressed the reset button during boot. Press again to exit safe mode.\n", 112, 218, 249, 251, 31, 174, 156, 143, 246, 144, 98, 40, 13, 24, 130, 228, 160, 90, 164, 204, 81, 229, 169, 49, 56, 98, 163, 186, 24, 70, 139, 189, 137, 17, 240, 135, 97, 73, 152, 7, 24, 200, 245, 75, 52, 159, 246, 150, 28, 252, 224) // CircuitPython is in safe mode because you pressed the reset button during boot. Press again to exit safe mode.\r\n
TRANSLATION("CircuitPython was unable to allocate the heap.\n", 48, 218, 249, 251, 31, 168, 101, 22, 10, 31, 115, 84, 103, 52, 128, 185, 114, 235, 33, 183, 14, 126, 112) // CircuitPython was unable to allocate the heap.\r\n
TRANSLATION("Clock pin init failed.", 22, 218, 154, 67, 127, 149, 165, 39, 253, 152, 64) // Clock pin init failed.
TRANSLATION("Clock stretch too long", 22, 218, 154, 67, 124, 25, 212, 158, 21, 131, 162, 4, 208, 241, 128) // Clock stretch too long
TRANSLATION("Corrupt .mpy file", 17, 218, 69, 90, 90, 225, 134, 203, 110, 244, 192) // Corrupt .mpy file
TRANSLATION("Corrupt raw code", 16, 218, 69, 90, 90, 224, 163, 151, 209) // Corrupt raw code
TRANSLATION("Could not start interrupt, RX busy", 34, 218, 74, 78, 58, 140, 226, 175, 164, 228, 171, 75, 95, 96, 59, 63, 224, 49, 81, 174) // Could not start interrupt, RX busy
TRANSLATION("Crash into the HardFault_Handler.", 33, 218, 81, 106, 244, 157, 57, 126, 248, 172, 125, 225, 164, 223, 183, 239, 137, 198, 100, 184, 64) // Crash into the HardFault_Handler.
TRANSLATION("DB out of sync", 14, 234, 123, 190, 171, 92, 112) // DB out of sync
TRANSLATION("Drive mode not used when direction is input.", 44, 234, 44, 178, 16, 88, 145, 45, 74, 49, 68, 50, 214, 70, 17, 146, 148, 56, 116, 252, 56, 64) // Drive mode not used when direction is input.
TRANSLATION("Encryption key size", 19, 234, 156, 22, 235, 120, 67, 124, 174, 246, 0) // Encryption key size
TRANSLATION("Error in ATT protocol code", 26, 234, 170, 162, 233, 7, 79, 119, 116, 45, 84, 116, 130, 79, 209) // Error in ATT protocol code
TRANSLATION("Error in regex", 14, 234, 170, 162, 233, 2, 150, 50, 204) // Error in regex
TRANSLATION("Error reading from HCI adapter", 30, 234, 170, 162, 130, 144, 199, 122, 165, 75, 3, 223, 218, 219, 1, 136, 218, 228, 160) // Error reading from HCI adapter
TRANSLATION("Error writing to HCI adapter", 28, 234, 170, 162, 134, 85, 147, 239, 58, 7, 191, 181, 182, 3, 17, 181, 201, 64) // Error writing to HCI adapter
TRANSLATION("Expected a %q", 13, 234, 254, 130, 23, 248, 0) // Expected a %q
TRANSLATION("FFT is defined for ndarrays only", 32, 247, 189, 237, 221, 63, 151, 68, 227, 222, 4, 57, 220) // FFT is defined for ndarrays only
TRANSLATION("FFT is implemented for linear arrays only", 41, 247, 189, 237, 221, 63, 246, 81, 209, 156, 140, 133, 67, 188, 8, 115, 184) // FFT is implemented for linear arrays only
TRANSLATION("Failed to write internal flash.", 31, 247, 134, 83, 40, 234, 229, 89, 57, 105, 57, 41, 140, 194, 169, 139, 87, 132) // Failed to write internal flash.
TRANSLATION("File exists", 11, 247, 165, 50, 2, 205, 38, 118) // File exists
TRANSLATION("Function requires lock", 22, 247, 168, 112, 225, 245, 216, 38, 144, 223) // Function requires lock
TRANSLATION("HCI packet size mismatch", 24, 247, 246, 182, 194, 209, 134, 249, 63, 176, 22, 73, 172, 23, 133, 96) // HCI packet size mismatch
TRANSLATION("HCI status error: %02x", 22, 247, 246, 182, 193, 156, 94, 141, 233, 116, 130, 255, 63, 163, 152) // HCI status error: %02x
TRANSLATION("Hardware in use, try alternative pins", 37, 247, 197, 99, 148, 84, 180, 130, 140, 91, 0, 235, 112, 12, 220, 148, 197, 229, 144, 185, 76) // Hardware in use, try alternative pins
TRANSLATION("I/O operation on closed file", 28, 219, 231, 124, 33, 245, 240, 130, 24, 66, 104, 197, 31, 76) // I/O operation on closed file
TRANSLATION("Incompatible .mpy file. Please update all .mpy files. See http://adafru.it/mpy-update for more info.", 100, 219, 56, 37, 150, 139, 203, 20, 200, 48, 217, 109, 222, 158, 16, 236, 76, 133, 136, 41, 108, 69, 200, 6, 115, 12, 54, 91, 119, 166, 216, 67, 112, 136, 43, 119, 183, 165, 206, 231, 12, 70, 165, 166, 25, 63, 58, 203, 110, 217, 165, 177, 23, 45, 27, 17, 75, 74, 164, 194) // Incompatible .mpy file. Please update all .mpy files. See http://adafru.it/mpy-update for more info.
TRANSLATION("Input/output error", 18, 219, 59, 104, 252, 228, 163, 219, 71, 244, 128) // Input/output error
TRANSLATION("Insufficient authentication", 27, 219, 54, 165, 85, 74, 18, 35, 112, 26, 61, 100, 111, 40, 15, 8) // Insufficient authentication
TRANSLATION("Insufficient encryption", 23, 219, 54, 165, 85, 74, 18, 35, 112, 35, 130, 221, 111, 8) // Insufficient encryption
TRANSLATION("Insufficient resources", 22, 219, 54, 165, 85, 74, 18, 35, 112, 82, 100, 162, 192, 152) // Insufficient resources
TRANSLATION("Internal define error", 21, 219, 55, 37, 49, 152, 68, 170, 145, 151, 164) // Internal define error
TRANSLATION("Invalid %q pin selection", 24, 219, 242, 95, 224, 229, 3, 20, 202, 28, 32) // Invalid %q pin selection
TRANSLATION("Invalid PDU", 11, 219, 242, 118, 58, 157, 160) // Invalid PDU
TRANSLATION("Invalid argument", 16, 219, 242, 124, 64) // Invalid argument
TRANSLATION("Invalid attribute length", 24, 219, 242, 15, 225, 198) // Invalid attribute length
TRANSLATION("Invalid buffer size", 19, 219, 242, 98, 252, 125, 128) // Invalid buffer size
TRANSLATION("Invalid direction.", 18, 219, 242, 70, 74, 80, 225, 194) // Invalid direction.
TRANSLATION("Invalid handle", 14, 219, 242, 86, 39, 25, 144) // Invalid handle
TRANSLATION("Invalid memory access.", 22, 219, 242, 88, 86, 34, 220, 3, 8, 19, 54, 16) // Invalid memory access.
TRANSLATION("Invalid number of bits", 22, 219, 242, 125, 92, 140, 82, 118) // Invalid number of bits
TRANSLATION("Invalid offset", 14, 219, 242, 37, 85, 49, 56) // Invalid offset
TRANSLATION("Invalid phase", 13, 219, 242, 91, 88, 177, 0) // Invalid phase
TRANSLATION("Invalid polarity", 16, 219, 242, 90, 147, 21, 147, 220) // Invalid polarity
TRANSLATION("Invalid run mode.", 17, 219, 242, 45, 12, 44, 72, 150, 16) // Invalid run mode.
TRANSLATION("Invalid word/bit length", 23, 219, 242, 101, 69, 143, 59, 20, 159, 140) // Invalid word/bit length
TRANSLATION("LHS of keyword arg must be an id", 32, 248, 61, 253, 206, 71, 208, 2, 184, 239, 9, 132, 162) // LHS of keyword arg must be an id
TRANSLATION("Length must be an int", 21, 248, 8, 241, 189, 119, 132, 244, 156) // Length must be an int
TRANSLATION("Length must be non-negative", 27, 248, 8, 241, 189, 119, 141, 15, 100, 203, 24, 188, 178, 16) // Length must be non-negative
TRANSLATION("MISO pin init failed.", 21, 235, 109, 238, 124, 60, 173, 41, 63, 236, 194) // MISO pin init failed.
TRANSLATION("MOSI pin init failed.", 21, 235, 124, 59, 155, 124, 173, 41, 63, 236, 194) // MOSI pin init failed.
TRANSLATION("MicroPython NLR jump failed. Likely memory corruption.", 54, 235, 74, 10, 157, 143, 212, 58, 255, 7, 100, 60, 84, 178, 223, 217, 132, 62, 9, 111, 148, 238, 11, 10, 196, 91, 130, 8, 171, 75, 120, 112, 128) // MicroPython NLR jump failed. Likely memory corruption.
TRANSLATION("MicroPython fatal error.", 24, 235, 74, 10, 157, 143, 212, 42, 23, 25, 250, 88, 64) // MicroPython fatal error.
TRANSLATION("Must provide MISO or MOSI pin", 29, 235, 81, 156, 45, 84, 201, 40, 144, 117, 182, 247, 62, 30, 79, 91, 225, 220, 219, 229, 0) // Must provide MISO or MOSI pin
TRANSLATION("Name too long", 13, 235, 141, 132, 14, 136, 19, 67, 198) // Name too long
TRANSLATION("No I2C device at address: %x", 28, 235, 160, 109, 244, 118, 130, 37, 146, 80, 32, 23, 1, 140, 84, 153, 186, 65, 127, 48) // No I2C device at address: %x
TRANSLATION("No RX pin", 9, 235, 160, 118, 127, 199, 40) // No RX pin
TRANSLATION("No TX pin", 9, 235, 160, 110, 255, 142, 80) // No TX pin
TRANSLATION("No hardware random available", 28, 235, 160, 86, 43, 28, 162, 164, 10, 39, 20, 176, 7, 32, 202, 125, 192) // No hardware random available
TRANSLATION("No pulldown on pin; 1Mohm recommended", 37, 235, 160, 91, 73, 206, 41, 148, 193, 15, 149, 255, 65, 208, 235, 37, 118, 2, 148, 18, 203, 8, 226, 81) // No pulldown on pin; 1Mohm recommended
TRANSLATION("No space left on device", 23, 235, 160, 53, 163, 2, 9, 149, 78, 8, 97, 18, 201, 40, 16) // No space left on device
TRANSLATION("No such file/directory", 22, 235, 160, 53, 33, 95, 167, 206, 140, 148, 160, 232, 183, 0) // No such file/directory
TRANSLATION("Not running saved code.\n", 25, 235, 163, 130, 208, 207, 121, 135, 33, 71, 209, 195, 159, 156) // Not running saved code.\r\n
TRANSLATION("Not supported", 13, 235, 163, 135, 152) // Not supported
TRANSLATION("Object has been deinitialized and can no longer be used. Create a new object.", 77, 248, 113, 120, 138, 14, 21, 139, 6, 34, 35, 8, 148, 142, 79, 33, 156, 188, 229, 31, 66, 2, 96, 104, 19, 67, 198, 74, 24, 136, 40, 197, 28, 33, 180, 164, 46, 64, 32, 101, 151, 143, 132) // Object has been deinitialized and can no longer be used. Create a new object.
TRANSLATION("Permission denied", 17, 236, 18, 217, 38, 242, 132, 72, 228, 81) // Permission denied
TRANSLATION("Pin is input only", 17, 236, 72, 244, 252, 32, 135, 59, 128) // Pin is input only
TRANSLATION("Plus any modules on the filesystem\n", 36, 236, 78, 140, 2, 119, 5, 137, 26, 76, 152, 16, 249, 117, 74, 100, 215, 51, 149, 153, 249, 192) // Plus any modules on the filesystem\r\n
TRANSLATION("Prepare queue full", 18, 236, 41, 90, 42, 65, 193, 66, 161, 5, 84, 156, 192) // Prepare queue full
TRANSLATION("Press any key to enter the REPL. Use CTRL-D to reload.\n", 56, 236, 41, 51, 0, 157, 193, 190, 87, 106, 145, 185, 47, 47, 179, 213, 236, 124, 24, 67, 180, 196, 27, 91, 189, 159, 131, 103, 169, 170, 165, 52, 24, 225, 207, 206) // Press any key to enter the REPL. Use CTRL-D to reload.\r\n
TRANSLATION("Pull not used when direction is output.", 39, 236, 82, 115, 212, 163, 20, 67, 45, 100, 97, 25, 41, 67, 135, 77, 40, 246, 209, 240, 128) // Pull not used when direction is output.
TRANSLATION("RNG DeInit Error", 16, 236, 245, 255, 168, 117, 11, 108, 228, 225, 213, 85, 69) // RNG DeInit Error
TRANSLATION("RNG Init Error", 14, 236, 245, 255, 168, 109, 156, 156, 58, 170, 168, 160) // RNG Init Error
TRANSLATION("RTC is not supported on this board", 34, 236, 238, 237, 105, 248, 252, 192, 134, 15, 92, 152, 49, 32, 172, 64) // RTC is not supported on this board
TRANSLATION("RTS/CTS/RS485 Not yet supported on this device", 46, 236, 238, 238, 115, 182, 183, 119, 57, 221, 157, 207, 225, 255, 143, 112, 58, 232, 225, 113, 56, 121, 129, 12, 30, 185, 48, 68, 178, 74, 4) // RTS/CTS/RS485 Not yet supported on this device
TRANSLATION("Random number generation error", 30, 236, 137, 197, 44, 15, 168, 49, 145, 146, 143, 15, 164) // Random number generation error
TRANSLATION("Read not permitted", 18, 236, 144, 199, 82, 210, 91, 36, 238, 81) // Read not permitted
TRANSLATION("Read-only filesystem", 20, 236, 144, 199, 101, 14, 119, 122, 109, 115, 57, 88) // Read-only filesystem
TRANSLATION("Running in safe mode! ", 22, 236, 208, 207, 122, 71, 251, 75, 247, 0) // Running in safe mode! 
TRANSLATION("SD card CSD format not supported", 32, 220, 234, 4, 5, 98, 27, 91, 157, 78, 46, 167, 152) // SD card CSD format not supported
TRANSLATION("Splitting with sub-captures", 27, 220, 182, 114, 119, 222, 203, 39, 172, 26, 152, 182, 96, 54, 189, 20, 152) // Splitting with sub-captures
TRANSLATION("Stack size must be at least 256", 31, 220, 113, 134, 255, 177, 120, 92, 38, 66, 206, 29, 31, 115, 248, 128) // Stack size must be at least 256
TRANSLATION("Supply at least one UART pin", 28, 220, 165, 182, 206, 224, 23, 9, 144, 179, 130, 25, 7, 107, 167, 217, 221, 229, 0) // Supply at least one UART pin
TRANSLATION("Temperature read timed out", 26, 221, 43, 45, 37, 23, 162, 144, 41, 12, 67, 239, 136, 37, 28) // Temperature read timed out
TRANSLATION("The CircuitPython heap was corrupted because the stack was too small.\nPlease increase the stack size if you know how, or if not:", 129, 221, 172, 131, 107, 231, 236, 126, 161, 89, 13, 161, 148, 88, 32, 138, 180, 181, 202, 33, 136, 160, 52, 98, 229, 179, 140, 55, 195, 40, 176, 58, 32, 53, 131, 57, 225, 207, 206, 236, 76, 133, 139, 74, 10, 66, 197, 203, 103, 24, 111, 251, 1, 42, 130, 228, 160, 111, 154, 101, 10, 211, 46, 199, 38, 85, 1, 163, 244, 128) // The CircuitPython heap was corrupted because the stack was too small.\r\nPlease increase the stack size if you know how, or if not:
TRANSLATION("The `microcontroller` module was used to boot into safe mode. Press reset to exit safe mode.\n", 94, 221, 172, 131, 253, 89, 40, 42, 65, 13, 213, 39, 50, 95, 244, 22, 36, 105, 50, 12, 162, 193, 70, 40, 234, 226, 68, 125, 39, 79, 218, 88, 67, 176, 164, 204, 10, 76, 79, 170, 89, 164, 255, 180, 176, 231, 231, 0) // The `microcontroller` module was used to boot into safe mode. Press reset to exit safe mode.\r\n
TRANSLATION("The microcontroller's power dipped. Make sure your power supply provides\nenough power for the whole circuit and press reset (after ejecting CIRCUITPY).\n", 154, 221, 172, 130, 201, 65, 82, 8, 110, 169, 57, 146, 224, 96, 181, 50, 146, 132, 101, 109, 165, 28, 33, 214, 29, 242, 6, 162, 144, 92, 148, 80, 181, 50, 146, 131, 82, 219, 103, 112, 90, 169, 146, 81, 38, 207, 206, 35, 74, 99, 172, 45, 76, 164, 186, 47, 89, 6, 90, 210, 100, 16, 249, 253, 11, 84, 153, 129, 73, 137, 195, 88, 106, 114, 80, 47, 17, 65, 247, 182, 182, 251, 59, 93, 173, 189, 222, 199, 249, 215, 195, 159, 156) // The microcontroller\'s power dipped. Make sure your power supply provides\r\nenough power for the whole circuit and press reset (after ejecting CIRCUITPY).\r\n
TRANSLATION("Timeout waiting for HCI response", 32, 221, 149, 132, 148, 112, 202, 50, 125, 234, 145, 67, 223, 218, 219, 5, 38, 181, 13, 136) // Timeout waiting for HCI response
TRANSLATION("Timeout waiting to write HCI request", 36, 221, 149, 132, 148, 112, 202, 50, 125, 231, 64, 202, 178, 114, 15, 127, 107, 108, 20, 184, 40, 76, 224) // Timeout waiting to write HCI request
TRANSLATION("Traceback (most recent call last):\n", 36, 221, 81, 129, 98, 24, 111, 134, 181, 136, 206, 10, 80, 35, 112, 128, 206, 97, 49, 103, 215, 233, 103, 231, 0) // Traceback (most recent call last):\r\n
TRANSLATION("Tuple or struct_time argument required", 38, 221, 165, 179, 46, 75, 58, 210, 15, 219, 251, 244, 61, 120, 128) // Tuple or struct_time argument required
TRANSLATION("UART Buffer allocation error", 28, 237, 116, 251, 59, 161, 238, 254, 32, 51, 154, 64, 120, 125, 32) // UART Buffer allocation error
TRANSLATION("UART De-init error", 18, 237, 116, 251, 59, 161, 212, 45, 153, 28, 159, 210) // UART De-init error
TRANSLATION("UART Init Error", 15, 237, 116, 251, 59, 161, 182, 114, 112, 234, 170, 162, 128) // UART Init Error
TRANSLATION("UART Re-init error", 18, 237, 116, 251, 59, 161, 217, 45, 153, 28, 159, 210) // UART Re-init error
TRANSLATION("UART write error", 16, 237, 116, 251, 59, 161, 149, 100, 229, 233, 0) // UART write error
TRANSLATION("Unable to init parser", 21, 237, 31, 115, 86, 71, 39, 11, 69, 88, 148) // Unable to init parser
TRANSLATION("Unknown ATT error: 0x%02x", 25, 237, 30, 249, 166, 83, 14, 158, 238, 239, 165, 210, 14, 126, 107, 252, 254, 142, 96) // Unknown ATT error: 0x%02x
TRANSLATION("Unknown hci_result_t: %d", 24, 237, 30, 249, 166, 83, 10, 225, 46, 218, 147, 82, 111, 219, 126, 144, 95, 136) // Unknown hci_result_t: %d
TRANSLATION("Unknown reason.", 15, 237, 30, 249, 166, 83, 5, 33, 100, 60, 32) // Unknown reason.
TRANSLATION("Unlikely", 8, 237, 28, 229, 190, 83, 184) // Unlikely
TRANSLATION("Unsupported group type", 22, 237, 31, 152, 49, 170, 82, 222, 96) // Unsupported group type
TRANSLATION("Unsupported operation", 21, 237, 31, 152, 62, 190, 16) // Unsupported operation
TRANSLATION("Unsupported pull value.", 23, 237, 31, 152, 45, 164, 230, 31, 150, 16) // Unsupported pull value.
TRANSLATION("Value not allowed", 17, 254, 195, 58, 22, 160, 206, 105, 148, 162) // Value not allowed
TRANSLATION("Voltage read timed out", 22, 254, 201, 55, 28, 100, 10, 67, 16, 251, 226, 9, 71) // Voltage read timed out
TRANSLATION("WARNING: Your code filename has two extensions\n", 48, 254, 253, 62, 207, 95, 111, 175, 253, 122, 65, 254, 82, 139, 232, 250, 102, 54, 16, 86, 44, 15, 149, 0, 179, 57, 31, 149, 179, 243, 128) // WARNING: Your code filename has two extensions\r\n
TRANSLATION("Watchdog timer expired.", 23, 254, 226, 240, 174, 41, 140, 62, 245, 2, 205, 108, 148, 163, 132) // Watchdog timer expired.
TRANSLATION("Welcome to Adafruit CircuitPython %s!\n\nPlease visit learn.adafruit.com/category/circuitpython for project guides.\n\nTo list built-in modules please do `help(\"modules\")`.\n", 174, 254, 229, 56, 37, 133, 171, 211, 136, 212, 180, 147, 134, 215, 207, 216, 253, 66, 251, 126, 236, 252, 236, 252, 238, 196, 200, 88, 131, 36, 154, 78, 19, 33, 83, 194, 49, 26, 150, 146, 124, 48, 75, 57, 208, 23, 44, 104, 183, 115, 161, 243, 219, 250, 232, 218, 169, 226, 40, 56, 99, 164, 162, 77, 135, 63, 59, 63, 59, 117, 2, 114, 103, 12, 84, 148, 223, 102, 70, 22, 36, 105, 50, 96, 182, 100, 44, 65, 20, 15, 245, 89, 78, 221, 111, 223, 98, 70, 147, 38, 253, 250, 255, 235, 14, 126, 112) // Welcome to Adafruit CircuitPython %s!\r\n\r\nPlease visit learn.adafruit.com/category/circuitpython for project guides.\r\n\r\nTo list built-in modules please do `help(\"modules\")`.\r\n
TRANSLATION("Write not permitted", 19, 254, 235, 39, 45, 75, 73, 108, 147, 185, 68) // Write not permitted
TRANSLATION("You are in safe mode: something unanticipated happened.\n", 57, 255, 41, 64, 21, 45, 47, 218, 93, 32, 100, 176, 158, 189, 234, 24, 155, 202, 18, 180, 92, 162, 21, 141, 182, 145, 148, 112, 231, 231, 0) // You are in safe mode: something unanticipated happened.\r\n
TRANSLATION("\nCode done running.\n", 22, 207, 206, 218, 72, 144, 69, 12, 129, 104, 103, 35, 199, 135, 63, 56) // \r\nCode done running.\r\n
TRANSLATION("\nCode stopped by auto-reload.\n", 32, 207, 206, 218, 72, 144, 51, 165, 182, 148, 67, 21, 192, 52, 116, 217, 82, 154, 12, 112, 231, 231, 0) // \r\nCode stopped by auto-reload.\r\n
TRANSLATION("\nPlease file an issue with the contents of your CIRCUITPY drive at \nhttps://github.com/adafruit/circuitpython/issues\n", 120, 207, 206, 236, 76, 133, 139, 211, 1, 48, 147, 53, 11, 155, 203, 130, 27, 145, 187, 114, 46, 74, 40, 109, 109, 246, 118, 187, 91, 123, 189, 143, 242, 17, 89, 100, 32, 23, 12, 252, 234, 221, 237, 110, 151, 59, 157, 142, 79, 93, 49, 97, 130, 89, 206, 24, 141, 75, 73, 63, 58, 31, 61, 191, 175, 58, 76, 212, 38, 207, 206) // \r\nPlease file an issue with the contents of your CIRCUITPY drive at \r\nhttps://github.com/adafruit/circuitpython/issues\r\n
TRANSLATION("__init__() should return None, not '%q'", 39, 237, 246, 228, 114, 126, 223, 111, 91, 92, 26, 180, 164, 226, 10, 79, 69, 48, 235, 161, 150, 198, 166, 11, 252, 24, 0) // __init__() should return None, not \'%q\'
TRANSLATION("__new__ arg must be a user-type", 31, 237, 246, 204, 178, 246, 251, 96, 43, 142, 240, 133, 24, 151, 101, 238, 180, 128) // __new__ arg must be a user-type
TRANSLATION("a bytes-like object is required", 31, 16, 248, 246, 103, 45, 242, 227, 233, 169, 112, 82, 74, 81) // a bytes-like object is required
TRANSLATION("abort() called", 14, 28, 72, 175, 173, 174, 16, 25, 204, 162) // abort() called
TRANSLATION("arg is an empty sequence", 24, 21, 199, 166, 38, 5, 101, 175, 112, 125, 160) // arg is an empty sequence
TRANSLATION("argsort argument must be an ndarray", 35, 21, 198, 200, 175, 161, 120, 79, 212) // argsort argument must be an ndarray
TRANSLATION("argsort is not implemented for flattened arrays", 47, 21, 198, 200, 175, 167, 227, 255, 101, 29, 26, 166, 46, 228, 101, 16, 239, 0) // argsort is not implemented for flattened arrays
TRANSLATION("argument has wrong type", 23, 248, 130, 177, 96, 252, 249, 128) // argument has wrong type
TRANSLATION("argument must be ndarray", 24, 248, 175, 28, 69, 84, 110) // argument must be ndarray
TRANSLATION("argument num/types mismatch", 27, 248, 128, 233, 103, 57, 238, 180, 152, 44, 147, 88, 47, 10, 192) // argument num/types mismatch
TRANSLATION("argument should be a '%q' not a '%q'", 36, 248, 129, 171, 74, 78, 33, 136, 128, 120, 154, 131, 196) // argument should be a \'%q\' not a \'%q\'
TRANSLATION("arguments must be ndarrays", 26, 248, 154, 241, 199, 188) // arguments must be ndarrays
TRANSLATION("array and index length must be equal", 36, 21, 81, 187, 208, 145, 196, 179, 113, 175, 23, 5, 6, 96) // array and index length must be equal
TRANSLATION("array/bytes required on right side", 34, 21, 81, 187, 157, 241, 250, 241, 4, 48, 89, 99, 173, 193, 165, 18) // array/bytes required on right side
TRANSLATION("attempt to get (arg)min/(arg)max of empty sequence", 50, 23, 114, 178, 215, 213, 198, 78, 26, 194, 184, 245, 236, 145, 243, 181, 133, 113, 235, 216, 57, 185, 5, 101, 175, 112, 125, 160) // attempt to get (arg)min/(arg)max of empty sequence
TRANSLATION("attempt to get argmin/argmax of an empty sequence", 49, 23, 114, 178, 215, 213, 198, 78, 2, 184, 236, 145, 243, 133, 113, 216, 57, 185, 2, 96, 86, 90, 247, 7, 218) // attempt to get argmin/argmax of an empty sequence
TRANSLATION("attributes not supported yet", 28, 31, 193, 181, 60, 193, 113, 56) // attributes not supported yet
TRANSLATION("axis is out of bounds", 21, 28, 210, 109, 52, 163, 242, 49, 37, 14, 44) // axis is out of bounds
TRANSLATION("axis must be None, or an integer", 32, 28, 210, 107, 221, 116, 50, 216, 228, 137, 233, 57, 99, 37) // axis must be None, or an integer
TRANSLATION("axis too long", 13, 28, 210, 96, 116, 64, 154, 30, 48) // axis too long
TRANSLATION("bad conversion specifier", 24, 196, 49, 8, 33, 228, 37, 242, 251, 36, 160) // bad conversion specifier
TRANSLATION("bad typecode", 12, 196, 49, 230, 65, 34, 64) // bad typecode
TRANSLATION("bits must be in range 5 to 9", 28, 197, 39, 107, 210, 48, 251, 3, 220, 213, 254, 64) // bits must be in range 5 to 9
TRANSLATION("buffer is smaller than requested size", 37, 197, 248, 233, 181, 131, 57, 146, 131, 214, 38, 10, 92, 20, 38, 114, 143, 176) // buffer is smaller than requested size
TRANSLATION("buffer size must be a multiple of element size", 46, 197, 248, 251, 23, 132, 62, 148, 168, 10, 101, 97, 27, 251, 0) // buffer size must be a multiple of element size
TRANSLATION("buffer size must match format", 29, 197, 248, 251, 1, 101, 25, 194, 193, 120, 87, 197) // buffer size must match format
TRANSLATION("buffer slices must be of equal length", 37, 197, 248, 131, 78, 80, 38, 188, 149, 1, 112, 80, 103, 198) // buffer slices must be of equal length
TRANSLATION("buffer too small", 16, 197, 248, 131, 162, 3, 88, 51, 152) // buffer too small
TRANSLATION("byte code not implemented", 25, 197, 115, 151, 163, 169, 254, 202, 32) // byte code not implemented
TRANSLATION("bytes length not a multiple of item size", 40, 248, 248, 218, 130, 31, 74, 84, 18, 114, 179, 216) // bytes length not a multiple of item size
TRANSLATION("bytes value out of range", 24, 248, 195, 242, 245, 126, 192) // bytes value out of range
TRANSLATION("can't add special method to already-subclassed class", 52, 239, 140, 98, 13, 105, 66, 67, 48, 176, 158, 180, 142, 168, 205, 72, 99, 118, 203, 83, 23, 200, 81, 15, 144) // can\'t add special method to already-subclassed class
TRANSLATION("can't assign to expression", 26, 239, 139, 52, 177, 158, 169, 102, 181, 73, 188, 160) // can\'t assign to expression
TRANSLATION("can't convert %q to %q", 22, 239, 193, 15, 33, 43, 133, 254, 13, 91, 252, 0) // can\'t convert %q to %q
TRANSLATION("can't convert '%q' object to %q implicitly", 42, 239, 193, 15, 33, 43, 241, 56, 250, 183, 248, 2, 86, 91, 57, 66, 79, 59, 128) // can\'t convert \'%q\' object to %q implicitly
TRANSLATION("can't declare nonlocal in outer code", 36, 239, 196, 161, 49, 82, 3, 67, 154, 64, 103, 164, 9, 71, 37, 244, 64) // can\'t declare nonlocal in outer code
TRANSLATION("can't delete expression", 23, 239, 196, 166, 78, 64, 89, 173, 82, 111, 40) // can\'t delete expression
TRANSLATION("can't do truncated division of a complex number", 47, 239, 197, 1, 214, 135, 1, 114, 136, 70, 89, 37, 229, 228, 8, 65, 44, 182, 101, 152, 62, 160) // can\'t do truncated division of a complex number
TRANSLATION("can't have multiple **x", 23, 239, 214, 57, 8, 62, 159, 107, 218, 204) // can\'t have multiple **x
TRANSLATION("can't have multiple *x", 22, 239, 214, 57, 8, 62, 159, 107, 48) // can\'t have multiple *x
TRANSLATION("can't pend throw to just-started generator", 42, 239, 218, 71, 16, 122, 213, 50, 234, 248, 168, 207, 178, 206, 42, 229, 16, 198, 71, 243, 0) // can\'t pend throw to just-started generator
TRANSLATION("can't send non-None value to a just-started generator", 53, 239, 177, 28, 64, 208, 246, 122, 232, 100, 31, 150, 168, 135, 138, 140, 251, 44, 226, 174, 81, 12, 100, 127, 48) // can\'t send non-None value to a just-started generator
TRANSLATION("can't set 512 block size", 24, 239, 177, 56, 123, 157, 14, 136, 98, 154, 67, 127, 216) // can\'t set 512 block size
TRANSLATION("can't set attribute", 19, 239, 177, 56, 15, 224) // can\'t set attribute
TRANSLATION("can't switch from automatic field numbering to manual field specification", 73, 239, 182, 89, 60, 43, 10, 149, 44, 1, 163, 165, 130, 242, 128, 85, 34, 156, 67, 234, 222, 116, 11, 4, 232, 51, 10, 164, 83, 143, 179, 1, 225) // can\'t switch from automatic field numbering to manual field specification
TRANSLATION("can't switch from manual field specification to automatic field numbering", 73, 239, 182, 89, 60, 43, 10, 149, 44, 11, 4, 232, 51, 10, 164, 83, 143, 179, 1, 225, 213, 26, 58, 88, 47, 40, 5, 82, 41, 196, 62, 169, 30, 48) // can\'t switch from manual field specification to automatic field numbering
TRANSLATION("cannot cast output with casting rule", 36, 135, 118, 2, 206, 9, 71, 182, 143, 205, 8, 11, 62, 242, 210, 100) // cannot cast output with casting rule
TRANSLATION("cannot create '%q' instances", 28, 135, 118, 10, 66, 229, 196, 210, 103, 19, 129, 48) // cannot create \'%q\' instances
TRANSLATION("cannot import name %q", 21, 135, 118, 86, 90, 138, 224, 99, 97, 5, 254, 0) // cannot import name %q
TRANSLATION("cannot perform relative import", 30, 135, 118, 210, 90, 145, 108, 5, 41, 139, 203, 33, 4, 172, 181, 21, 192) // cannot perform relative import
TRANSLATION("chr() arg not in range(0x110000)", 32, 133, 107, 173, 174, 2, 184, 245, 36, 97, 246, 107, 115, 243, 116, 58, 28, 254, 127, 63, 159, 174) // chr() arg not in range(0x110000)
TRANSLATION("code outside range 0~127", 24, 130, 68, 189, 111, 176, 57, 255, 255, 232, 116, 127, 238) // code outside range 0~127
TRANSLATION("complex division by zero", 24, 130, 89, 108, 203, 48, 70, 89, 37, 229, 12, 87, 7, 156, 149, 0) // complex division by zero
TRANSLATION("constant must be an integer", 27, 130, 27, 56, 155, 222, 19, 210, 114, 198, 74) // constant must be an integer
TRANSLATION("convolve arguments must be linear arrays", 40, 130, 30, 68, 158, 66, 208, 107, 211, 145, 144, 168, 119, 128) // convolve arguments must be linear arrays
TRANSLATION("convolve arguments must be ndarrays", 35, 130, 30, 68, 158, 66, 208, 107, 199, 30, 240) // convolve arguments must be ndarrays
TRANSLATION("convolve arguments must not be empty", 36, 130, 30, 68, 158, 66, 208, 96, 178, 140, 250, 152, 136, 10, 203, 94, 224) // convolve arguments must not be empty
TRANSLATION("could not invert Vandermonde matrix", 35, 130, 82, 113, 212, 145, 228, 37, 112, 254, 194, 113, 37, 177, 14, 36, 22, 11, 172, 179, 0) // could not invert Vandermonde matrix
TRANSLATION("couldn't determine SD card version", 34, 130, 82, 113, 60, 14, 17, 39, 37, 178, 70, 65, 185, 212, 8, 10, 196, 50, 18, 249, 64) // couldn\'t determine SD card version
TRANSLATION("cross is defined for 1D arrays of length 3", 42, 130, 163, 54, 159, 203, 163, 208, 234, 7, 123, 145, 50, 60, 111, 88, 123, 96) // cross is defined for 1D arrays of length 3
TRANSLATION("data type not understood", 24, 136, 184, 243, 53, 40, 113, 37, 103, 68, 136) // data type not understood
TRANSLATION("default 'except' must be last", 29, 137, 84, 52, 155, 134, 2, 205, 2, 181, 240, 94, 152, 179, 128) // default \'except\' must be last
TRANSLATION("default is not a function", 25, 137, 84, 52, 155, 233, 248, 196, 60, 0) // default is not a function
TRANSLATION("dict update sequence has wrong length", 37, 140, 160, 225, 75, 98, 46, 65, 246, 133, 98, 193, 249, 241, 128) // dict update sequence has wrong length
TRANSLATION("diff argument must be an ndarray", 32, 140, 170, 171, 66, 240, 159, 168) // diff argument must be an ndarray
TRANSLATION("differentiation order out of range", 34, 140, 170, 168, 148, 141, 228, 60, 32, 139, 18, 95, 87, 236) // differentiation order out of range
TRANSLATION("division by zero", 16, 140, 178, 75, 202, 24, 174, 15, 57, 42, 0) // division by zero
TRANSLATION("empty separator", 15, 43, 45, 123, 129, 138, 209, 81, 116, 80) // empty separator
TRANSLATION("empty sequence", 14, 43, 45, 123, 131, 237) // empty sequence
TRANSLATION("exceptions must derive from BaseException", 41, 44, 208, 43, 120, 88, 44, 163, 56, 68, 150, 89, 8, 42, 84, 176, 61, 209, 98, 234, 230, 129, 91, 194) // exceptions must derive from BaseException
TRANSLATION("expected ':' after format specifier", 35, 47, 211, 7, 75, 0, 13, 78, 75, 197, 246, 73, 64) // expected \':\' after format specifier
TRANSLATION("expecting just a value for set", 30, 44, 214, 148, 31, 123, 197, 70, 112, 16, 252, 180, 88, 156) // expecting just a value for set
TRANSLATION("expecting key:value for dict", 28, 44, 214, 148, 31, 123, 124, 174, 233, 126, 90, 49, 148, 28) // expecting key:value for dict
TRANSLATION("ext_hook is not a function", 26, 44, 207, 219, 173, 19, 127, 79, 198, 33, 224) // ext_hook is not a function
TRANSLATION("extra keyword arguments given", 29, 44, 206, 162, 31, 70, 131, 6, 57, 100, 35) // extra keyword arguments given
TRANSLATION("extra positional arguments given", 32, 44, 206, 162, 22, 163, 75, 132, 103, 160, 193, 142, 89, 8, 192) // extra positional arguments given
TRANSLATION("filesystem must provide mount method", 36, 170, 83, 38, 185, 156, 172, 11, 40, 206, 22, 170, 100, 148, 72, 44, 74, 27, 133, 132, 245, 164, 64) // filesystem must provide mount method
TRANSLATION("first argument must be a callable", 33, 170, 74, 207, 161, 120, 66, 3, 57, 247, 0) // first argument must be a callable
TRANSLATION("first argument must be a function", 33, 170, 74, 207, 161, 120, 67, 192) // first argument must be a function
TRANSLATION("first argument must be a tuple of ndarrays", 42, 170, 74, 207, 161, 120, 65, 233, 108, 203, 144, 113, 239, 0) // first argument must be a tuple of ndarrays
TRANSLATION("first argument must be an iterable", 34, 170, 74, 207, 161, 120, 76, 36, 228, 189, 192) // first argument must be an iterable
TRANSLATION("first argument must be an ndarray", 33, 170, 74, 207, 161, 120, 79, 212) // first argument must be an ndarray
TRANSLATION("first argument to super() must be type", 38, 170, 74, 207, 161, 170, 212, 180, 151, 91, 94, 243, 221, 105, 0) // first argument to super() must be type
TRANSLATION("flattening order must be either 'C', or 'F'", 43, 170, 98, 238, 71, 188, 139, 18, 91, 197, 39, 172, 148, 48, 109, 96, 216, 228, 224, 247, 176, 0) // flattening order must be either \'C\', or \'F\'
TRANSLATION("flip argument must be an ndarray", 32, 170, 114, 183, 66, 240, 159, 168) // flip argument must be an ndarray
TRANSLATION("format requires a dict", 22, 169, 22, 193, 127, 93, 128, 66, 50, 131, 128) // format requires a dict
TRANSLATION("function does not take keyword arguments", 40, 240, 4, 80, 155, 81, 199, 124, 131, 232, 208, 96) // function does not take keyword arguments
TRANSLATION("function expected at most %d arguments, got %d", 46, 240, 1, 126, 130, 225, 98, 51, 133, 248, 232, 54, 192, 99, 71, 11, 241) // function expected at most %d arguments, got %d
TRANSLATION("function got multiple values for argument '%q'", 46, 240, 6, 52, 112, 250, 127, 38, 209, 248, 184, 128) // function got multiple values for argument \'%q\'
TRANSLATION("function has the same sign at the ends of interval", 50, 240, 5, 98, 220, 182, 27, 8, 26, 88, 204, 5, 249, 100, 113, 110, 68, 141, 201, 114, 12, 192) // function has the same sign at the ends of interval
TRANSLATION("function is defined for ndarrays only", 37, 240, 105, 252, 186, 39, 30, 240, 33, 206, 224) // function is defined for ndarrays only
TRANSLATION("function missing %d required positional arguments", 49, 240, 5, 146, 102, 222, 191, 31, 94, 33, 106, 52, 184, 70, 122, 12) // function missing %d required positional arguments
TRANSLATION("function missing keyword-only argument", 38, 240, 5, 146, 102, 222, 250, 54, 80, 231, 118, 128) // function missing keyword-only argument
TRANSLATION("function missing required keyword argument '%q'", 47, 240, 5, 146, 102, 222, 82, 224, 164, 148, 162, 31, 70, 135, 16) // function missing required keyword argument \'%q\'
TRANSLATION("function missing required positional argument #%d", 49, 240, 5, 146, 102, 222, 82, 224, 164, 148, 162, 22, 163, 75, 132, 103, 160, 31, 246, 191, 16) // function missing required positional argument #%d
TRANSLATION("function takes %d positional arguments but %d were given", 56, 240, 3, 142, 249, 48, 95, 136, 90, 141, 46, 17, 158, 131, 6, 42, 56, 95, 136, 101, 37, 32, 199, 44, 132, 96) // function takes %d positional arguments but %d were given
TRANSLATION("function takes exactly 9 arguments", 34, 240, 3, 142, 249, 48, 22, 97, 131, 206, 224, 254, 90, 12) // function takes exactly 9 arguments
TRANSLATION("generator already executing", 27, 198, 71, 243, 0, 205, 72, 99, 112, 22, 98, 133, 30, 71, 140) // generator already executing
TRANSLATION("generator ignored GeneratorExit", 31, 198, 71, 243, 4, 177, 154, 41, 68, 63, 169, 31, 205, 213, 205, 39) // generator ignored GeneratorExit
TRANSLATION("identifier redefined as global", 30, 148, 72, 222, 85, 72, 148, 20, 190, 80, 22, 12, 115, 76, 67, 48) // identifier redefined as global
TRANSLATION("identifier redefined as nonlocal", 32, 148, 72, 222, 85, 72, 148, 20, 190, 80, 22, 3, 67, 154, 64, 102) // identifier redefined as nonlocal
TRANSLATION("incomplete format", 17, 145, 193, 44, 182, 100, 229, 197) // incomplete format
TRANSLATION("incomplete format key", 21, 145, 193, 44, 182, 100, 229, 197, 13, 242, 184) // incomplete format key
TRANSLATION("incorrect padding", 17, 145, 193, 21, 74, 14, 22, 140, 99, 35, 198) // incorrect padding
TRANSLATION("index is out of bounds", 22, 145, 196, 179, 105, 165, 31, 145, 137, 40, 113, 96) // index is out of bounds
TRANSLATION("index out of range", 18, 145, 196, 179, 122, 191, 96) // index out of range
TRANSLATION("indices must be integers, slices, or Boolean lists", 50, 145, 198, 80, 38, 189, 255, 27, 96, 26, 114, 129, 54, 199, 39, 221, 68, 153, 9, 132, 228, 206, 192) // indices must be integers, slices, or Boolean lists
TRANSLATION("input and output shapes are not compatible", 42, 240, 250, 9, 71, 182, 142, 13, 88, 218, 76, 2, 165, 169, 4, 178, 209, 121, 98, 153, 0) // input and output shapes are not compatible
TRANSLATION("input argument must be an integer, a tuple, or a list", 53, 240, 232, 94, 19, 210, 114, 198, 75, 176, 2, 15, 75, 102, 91, 28, 145, 9, 201, 156) // input argument must be an integer, a tuple, or a list
TRANSLATION("input array length must be power of 2", 37, 240, 128, 170, 141, 220, 107, 214, 166, 82, 94, 71, 68) // input array length must be power of 2
TRANSLATION("input arrays are not compatible", 31, 240, 135, 120, 5, 75, 82, 9, 101, 162, 242, 197, 50) // input arrays are not compatible
TRANSLATION("input data must be an iterable", 30, 240, 132, 69, 198, 240, 152, 73, 201, 123, 128) // input data must be an iterable
TRANSLATION("input matrix is asymmetric", 26, 240, 133, 130, 235, 44, 218, 98, 215, 89, 97, 58, 202, 0) // input matrix is asymmetric
TRANSLATION("input matrix is singular", 24, 240, 133, 130, 235, 44, 218, 109, 35, 199, 73, 138, 128) // input matrix is singular
TRANSLATION("input must be a tensor of rank 2", 32, 240, 222, 16, 114, 54, 69, 228, 40, 158, 248, 116, 64) // input must be a tensor of rank 2
TRANSLATION("input must be an ndarray", 24, 240, 222, 19, 245, 0) // input must be an ndarray
TRANSLATION("input must be one-dimensional", 29, 240, 222, 67, 45, 152, 202, 194, 63, 40, 204) // input must be one-dimensional
TRANSLATION("input must be square matrix", 27, 240, 222, 110, 10, 10, 144, 88, 46, 178, 204) // input must be square matrix
TRANSLATION("input must be tuple, list, range, or ndarray", 44, 240, 222, 122, 91, 50, 216, 9, 201, 159, 96, 62, 205, 142, 73, 196, 85, 70, 224) // input must be tuple, list, range, or ndarray
TRANSLATION("input vectors must be of equal length", 37, 240, 134, 66, 131, 162, 181, 228, 168, 11, 130, 131, 62, 48) // input vectors must be of equal length
TRANSLATION("inputs are not iterable", 23, 240, 176, 10, 150, 164, 156, 151, 184) // inputs are not iterable
TRANSLATION("int() arg 2 must be >= 2 and <= 36", 34, 145, 190, 182, 184, 10, 227, 14, 141, 239, 233, 252, 195, 163, 232, 127, 231, 249, 135, 183, 252, 64) // int() arg 2 must be >= 2 and <= 36
TRANSLATION("integer required", 16, 255, 158, 188, 64) // integer required
TRANSLATION("interp is defined for 1D arrays of equal length", 47, 145, 185, 45, 186, 127, 46, 143, 67, 168, 29, 238, 65, 112, 80, 103, 198) // interp is defined for 1D arrays of equal length
TRANSLATION("invalid format specifier", 24, 151, 146, 164, 91, 5, 253, 146, 80) // invalid format specifier
TRANSLATION("invalid micropython decorator", 29, 151, 146, 201, 65, 82, 223, 212, 34, 80, 69, 23, 69) // invalid micropython decorator
TRANSLATION("invalid step", 12, 151, 145, 156, 173) // invalid step
TRANSLATION("invalid syntax", 14, 151, 145, 174, 55, 28, 192) // invalid syntax
TRANSLATION("invalid syntax for integer with base %d", 39, 151, 145, 174, 55, 28, 218, 63, 243, 154, 24, 133, 136, 47, 196) // invalid syntax for integer with base %d
TRANSLATION("invalid syntax for number", 25, 151, 145, 174, 55, 28, 218, 63, 80) // invalid syntax for number
TRANSLATION("issubclass() arg 1 must be a class", 34, 147, 53, 49, 124, 154, 218, 224, 43, 140, 58, 23, 132, 62, 64) // issubclass() arg 1 must be a class
TRANSLATION("issubclass() arg 2 must be a class or a tuple of classes", 56, 147, 53, 49, 124, 154, 218, 224, 43, 140, 58, 55, 132, 62, 78, 72, 131, 210, 217, 151, 35, 228, 38) // issubclass() arg 2 must be a class or a tuple of classes
TRANSLATION("iterables are not of the same length", 36, 147, 146, 247, 24, 5, 75, 81, 42, 229, 176, 216, 92, 96) // iterables are not of the same length
TRANSLATION("iterations did not converge", 27, 147, 146, 143, 11, 4, 101, 29, 72, 33, 228, 37, 198, 64) // iterations did not converge
TRANSLATION("join expects a list of str/bytes objects consistent with self object", 68, 241, 36, 140, 11, 53, 165, 7, 96, 16, 156, 153, 249, 12, 235, 206, 248, 248, 236, 16, 67, 105, 51, 145, 191, 52, 24, 167, 87, 28) // join expects a list of str/bytes objects consistent with self object
TRANSLATION("keyword argument(s) not yet implemented - use normal args instead", 65, 250, 52, 53, 155, 95, 82, 226, 112, 255, 101, 16, 217, 10, 49, 1, 162, 216, 51, 1, 92, 109, 164, 206, 67, 16) // keyword argument(s) not yet implemented - use normal args instead
TRANSLATION("keywords must be strings", 24, 250, 26, 247, 220, 192) // keywords must be strings
TRANSLATION("length argument not allowed for this type", 41, 153, 30, 55, 175, 67, 80, 103, 52, 202, 81, 209, 122, 228, 220, 192) // length argument not allowed for this type
TRANSLATION("lhs and rhs should be compatible", 32, 157, 109, 232, 45, 108, 13, 90, 82, 113, 12, 68, 16, 75, 45, 23, 150, 41, 144) // lhs and rhs should be compatible
TRANSLATION("local variable referenced before assignment", 43, 154, 64, 102, 25, 5, 101, 220, 5, 42, 137, 72, 224, 81, 12, 69, 82, 41, 0, 179, 75, 25, 216, 70, 224) // local variable referenced before assignment
TRANSLATION("malformed f-string", 18, 176, 103, 82, 45, 133, 16, 171, 103, 238) // malformed f-string
TRANSLATION("math domain error", 17, 176, 94, 176, 138, 88, 50, 63, 72) // math domain error
TRANSLATION("matrix dimensions do not match", 30, 176, 93, 101, 152, 35, 43, 8, 252, 172, 17, 77, 75, 5, 225, 88) // matrix dimensions do not match
TRANSLATION("matrix is not positive definite", 31, 176, 93, 101, 155, 79, 199, 106, 52, 158, 89, 8, 34, 85, 72, 228, 228) // matrix is not positive definite
TRANSLATION("maximum number of dimensions is 4", 33, 176, 115, 74, 202, 88, 31, 87, 34, 50, 176, 143, 202, 218, 127, 192) // maximum number of dimensions is 4
TRANSLATION("maximum recursion depth exceeded", 32, 176, 115, 74, 202, 88, 10, 80, 162, 249, 66, 37, 107, 214, 5, 154, 4, 81, 40, 128) // maximum recursion depth exceeded
TRANSLATION("maxiter must be > 0", 19, 176, 115, 73, 201, 111, 127, 64, 231, 128) // maxiter must be > 0
TRANSLATION("maxiter should be > 0", 21, 176, 115, 73, 201, 65, 171, 74, 78, 33, 136, 131, 250, 7, 60) // maxiter should be > 0
TRANSLATION("median argument must be an ndarray", 34, 176, 163, 33, 61, 11, 194, 126, 160) // median argument must be an ndarray
TRANSLATION("memory allocation failed, allocating %u bytes", 45, 176, 172, 69, 184, 6, 115, 72, 15, 15, 236, 216, 1, 156, 210, 2, 251, 215, 232, 31, 24) // memory allocation failed, allocating %u bytes
TRANSLATION("memory allocation failed, heap is locked", 40, 176, 172, 69, 184, 6, 115, 72, 15, 15, 236, 216, 10, 200, 109, 211, 154, 67, 124, 162) // memory allocation failed, heap is locked
TRANSLATION("memoryview: length is not a multiple of itemsize", 48, 176, 172, 69, 187, 36, 139, 47, 75, 141, 167, 227, 16, 250, 82, 160, 147, 149, 141, 47, 57, 0) // memoryview: length is not a multiple of itemsize
TRANSLATION("more degrees of freedom than data points", 40, 177, 20, 130, 37, 141, 72, 155, 145, 82, 145, 69, 44, 7, 172, 76, 34, 46, 33, 106, 72, 221, 128) // more degrees of freedom than data points
TRANSLATION("multiple *x in assignment", 25, 250, 125, 172, 218, 64, 44, 210, 198, 118, 17, 184) // multiple *x in assignment
TRANSLATION("multiple bases have instance lay-out conflict", 45, 250, 113, 11, 19, 5, 99, 144, 180, 153, 196, 224, 65, 49, 187, 101, 40, 225, 4, 58, 167, 40, 56) // multiple bases have instance lay-out conflict
TRANSLATION("must use keyword argument for key function", 42, 178, 140, 225, 70, 32, 250, 52, 52, 119, 202, 224, 240, 0) // must use keyword argument for key function
TRANSLATION("name '%q' is not defined", 24, 49, 176, 184, 154, 126, 63, 148) // name \'%q\' is not defined
TRANSLATION("name reused for argument", 24, 49, 176, 129, 74, 140, 81, 209, 248, 128) // name reused for argument
TRANSLATION("need more than %d values to unpack", 34, 50, 40, 133, 136, 164, 15, 88, 152, 95, 136, 126, 77, 171, 67, 180, 97, 190) // need more than %d values to unpack
TRANSLATION("negative shift count", 20, 50, 198, 47, 44, 132, 13, 92, 170, 112, 130, 80, 220) // negative shift count
TRANSLATION("no SD card", 10, 52, 13, 206, 160, 64, 86, 32) // no SD card
TRANSLATION("no active exception to reraise", 30, 52, 1, 131, 203, 33, 1, 102, 129, 91, 195, 170, 164, 163, 38, 32) // no active exception to reraise
TRANSLATION("no binding for nonlocal found", 29, 52, 12, 82, 56, 239, 84, 138, 6, 135, 52, 128, 204, 42, 74, 28, 64) // no binding for nonlocal found
TRANSLATION("no default packer", 17, 52, 8, 149, 67, 73, 184, 90, 48, 223, 37) // no default packer
TRANSLATION("no module named '%q'", 20, 52, 11, 18, 52, 153, 1, 141, 133, 30, 32) // no module named \'%q\'
TRANSLATION("no response from SD card", 24, 52, 5, 38, 181, 13, 136, 42, 84, 176, 55, 58, 129, 1, 88, 128) // no response from SD card
TRANSLATION("non-default argument follows default argument", 45, 52, 61, 152, 149, 67, 73, 190, 128, 84, 147, 154, 101, 96, 137, 84, 52, 155, 232, 0) // non-default argument follows default argument
TRANSLATION("non-hex digit found", 19, 52, 61, 154, 203, 48, 70, 88, 228, 225, 82, 80, 226) // non-hex digit found
TRANSLATION("non-keyword arg after */**", 26, 52, 61, 159, 160, 5, 113, 128, 212, 228, 161, 237, 115, 189, 175, 104) // non-keyword arg after */**
TRANSLATION("non-keyword arg after keyword arg", 33, 52, 61, 159, 160, 5, 113, 128, 212, 228, 161, 244, 0, 174, 48) // non-keyword arg after keyword arg
TRANSLATION("norm is defined for 1D and 2D arrays", 36, 52, 91, 52, 254, 93, 30, 135, 83, 208, 232, 245, 3, 188) // norm is defined for 1D and 2D arrays
TRANSLATION("not all arguments converted during string formatting", 52, 241, 140, 231, 160, 193, 4, 60, 132, 174, 81, 8, 209, 119, 190, 238, 43, 200, 241, 128) // not all arguments converted during string formatting
TRANSLATION("not enough arguments for format string", 38, 241, 145, 165, 49, 215, 160, 218, 53, 34, 216, 46, 31, 112) // not enough arguments for format string
TRANSLATION("number of points must be at least 2", 35, 250, 185, 22, 164, 141, 218, 240, 184, 76, 133, 156, 58, 32) // number of points must be at least 2
TRANSLATION("object ", 7, 76, 94, 34, 131, 128) // object 
TRANSLATION("object '%q' is not a tuple or list", 34, 76, 94, 34, 131, 241, 52, 252, 98, 15, 75, 102, 92, 153, 201, 156) // object \'%q\' is not a tuple or list
TRANSLATION("object not in sequence", 22, 76, 94, 34, 131, 234, 72, 195, 237) // object not in sequence
TRANSLATION("object of type '%q' has no len()", 32, 76, 94, 34, 131, 242, 30, 235, 75, 136, 21, 139, 1, 160, 76, 143, 91, 92) // object of type \'%q\' has no len()
TRANSLATION("object with buffer protocol required", 36, 76, 94, 34, 131, 243, 67, 23, 226, 22, 170, 58, 65, 39, 235, 196) // object with buffer protocol required
TRANSLATION("odd-length string", 17, 72, 199, 102, 100, 120, 222, 176, 251, 128) // odd-length string
TRANSLATION("offset is too large", 19, 74, 170, 98, 125, 55, 68, 9, 138, 227, 32) // offset is too large
TRANSLATION("offset must be non-negative and no greater than buffer length", 61, 74, 170, 98, 123, 198, 135, 178, 101, 140, 94, 89, 11, 208, 52, 12, 106, 66, 228, 160, 245, 137, 134, 47, 199, 140) // offset must be non-negative and no greater than buffer length
TRANSLATION("offset out of bounds", 20, 74, 170, 98, 127, 87, 18, 80, 226, 192) // offset out of bounds
TRANSLATION("only slices with step=1 (aka None) are supported", 48, 67, 157, 192, 211, 148, 9, 185, 160, 206, 86, 255, 62, 128, 107, 14, 248, 135, 93, 12, 181, 192, 84, 131, 204) // only slices with step=1 (aka None) are supported
TRANSLATION("operands could not be broadcast together", 40, 250, 206, 44, 16, 74, 78, 58, 152, 136, 49, 42, 12, 96, 44, 224, 233, 140, 158, 178, 80) // operands could not be broadcast together
TRANSLATION("operation is implemented for 1D Boolean arrays only", 51, 250, 248, 116, 255, 217, 71, 71, 161, 212, 15, 117, 18, 100, 38, 29, 224, 67, 157, 192) // operation is implemented for 1D Boolean arrays only
TRANSLATION("operation is not implemented on ndarrays", 40, 250, 248, 116, 252, 127, 236, 162, 8, 126, 163, 0) // operation is not implemented on ndarrays
TRANSLATION("operation is not supported for given type", 41, 250, 248, 116, 252, 126, 109, 28, 114, 200, 71, 204) // operation is not supported for given type
TRANSLATION("ord() expected a character, but string of length %d found", 57, 69, 142, 182, 184, 23, 232, 33, 10, 197, 70, 14, 75, 176, 24, 168, 225, 247, 114, 38, 71, 141, 235, 11, 241, 10, 146, 135, 16) // ord() expected a character, but string of length %d found
TRANSLATION("overflow converting long int to machine word", 44, 76, 132, 181, 77, 50, 132, 16, 242, 18, 190, 244, 208, 241, 233, 62, 173, 131, 10, 228, 100, 25, 81, 98) // overflow converting long int to machine word
TRANSLATION("pop from empty %q", 17, 181, 45, 10, 149, 44, 2, 178, 215, 184, 47, 240, 0) // pop from empty %q
TRANSLATION("pow() 3rd argument cannot be 0", 30, 181, 50, 235, 107, 135, 182, 177, 208, 8, 119, 113, 16, 115, 192) // pow() 3rd argument cannot be 0
TRANSLATION("pow() with 3 arguments requires integers", 40, 181, 50, 235, 107, 243, 67, 219, 208, 111, 93, 180, 156, 177, 146, 176) // pow() with 3 arguments requires integers
TRANSLATION("real and imaginary parts must be of equal length", 48, 82, 25, 250, 18, 176, 113, 200, 197, 110, 11, 69, 93, 175, 37, 64, 92, 20, 25, 241, 128) // real and imaginary parts must be of equal length
TRANSLATION("requested length %d but object has length %d", 44, 82, 224, 161, 51, 148, 120, 193, 126, 33, 138, 143, 199, 10, 197, 184, 193, 126, 32) // requested length %d but object has length %d
TRANSLATION("results cannot be cast to specified type", 40, 82, 106, 77, 216, 33, 221, 196, 65, 1, 103, 213, 107, 74, 18, 170, 69, 30, 96) // results cannot be cast to specified type
TRANSLATION("roll argument must be an ndarray", 32, 84, 156, 244, 47, 9, 250, 128) // roll argument must be an ndarray
TRANSLATION("rsplit(None,n)", 14, 86, 182, 114, 125, 110, 186, 25, 108, 30, 184) // rsplit(None,n)
TRANSLATION("shape must be a tuple", 21, 106, 198, 210, 188, 32, 244, 182, 100) // shape must be a tuple
TRANSLATION("short read", 10, 106, 209, 92, 20, 134, 32) // short read
TRANSLATION("sign not allowed in string format specifier", 43, 105, 99, 61, 65, 156, 211, 41, 71, 72, 62, 238, 47, 178, 74) // sign not allowed in string format specifier
TRANSLATION("sign not allowed with integer format specifier 'c'", 50, 105, 99, 61, 65, 156, 211, 41, 71, 155, 164, 229, 140, 151, 139, 236, 146, 134, 8, 96) // sign not allowed with integer format specifier \'c\'
TRANSLATION("single '}' encountered in format string", 39, 105, 30, 57, 144, 96, 255, 246, 0, 35, 130, 80, 220, 148, 163, 165, 197, 15, 184) // single \'}\' encountered in format string
TRANSLATION("size is defined for ndarrays only", 33, 105, 121, 203, 79, 229, 209, 56, 247, 129, 14, 119, 0) // size is defined for ndarrays only
TRANSLATION("sleep length must be non-negative", 33, 105, 145, 91, 198, 188, 104, 123, 38, 88, 197, 229, 144, 128) // sleep length must be non-negative
TRANSLATION("slice step cannot be zero", 25, 105, 202, 4, 12, 229, 104, 67, 187, 136, 131, 206, 74, 128) // slice step cannot be zero
TRANSLATION("small int overflow", 18, 107, 6, 115, 210, 112, 76, 132, 181, 77, 50, 128) // small int overflow
TRANSLATION("soft reboot\n", 13, 100, 169, 193, 75, 18, 35, 231, 231, 0) // soft reboot\r\n
TRANSLATION("sort argument must be an ndarray", 32, 100, 87, 208, 188, 39, 234, 0) // sort argument must be an ndarray
TRANSLATION("sos array must be of shape (n_section, 6)", 41, 100, 96, 21, 81, 186, 242, 84, 13, 88, 218, 65, 172, 125, 182, 40, 112, 236, 7, 241, 215) // sos array must be of shape (n_section, 6)
TRANSLATION("sos[:, 3] should be all ones", 28, 100, 111, 253, 244, 182, 3, 219, 255, 224, 53, 105, 73, 196, 49, 16, 12, 230, 8, 100, 192) // sos[:, 3] should be all ones
TRANSLATION("sosfilt requires iterable arguments", 35, 100, 106, 165, 55, 245, 216, 36, 228, 189, 205, 6) // sosfilt requires iterable arguments
TRANSLATION("start/end indices", 17, 103, 21, 126, 113, 28, 116, 163, 40, 19, 0) // start/end indices
TRANSLATION("step must be non-zero", 21, 103, 43, 111, 26, 30, 207, 156, 149, 0) // step must be non-zero
TRANSLATION("stop must be 1 or 2", 19, 103, 75, 111, 116, 57, 61, 16) // stop must be 1 or 2
TRANSLATION("stop not reachable from start", 29, 103, 75, 117, 20, 134, 21, 247, 2, 165, 75, 1, 156, 85, 192) // stop not reachable from start
TRANSLATION("stream operation not supported", 30, 103, 82, 27, 3, 235, 225, 212, 243, 0) // stream operation not supported
TRANSLATION("string indices must be integers, not %q", 39, 251, 180, 163, 40, 19, 94, 255, 141, 177, 169, 127, 128) // string indices must be integers, not %q
TRANSLATION("string not supported; use bytes or bytearray", 44, 251, 181, 60, 223, 244, 20, 98, 15, 143, 147, 138, 231, 33, 85, 27, 128) // string not supported; use bytes or bytearray
TRANSLATION("substring not found", 19, 106, 98, 251, 181, 42, 74, 28, 64) // substring not found
TRANSLATION("super() can't find self", 23, 106, 90, 75, 173, 174, 29, 250, 164, 113, 6, 41, 212) // super() can\'t find self
TRANSLATION("syntax error in JSON", 20, 107, 141, 199, 55, 165, 164, 31, 250, 220, 248, 122, 224) // syntax error in JSON
TRANSLATION("threshold must be in the range 0-65536", 38, 122, 212, 154, 180, 156, 111, 72, 249, 127, 96, 115, 246, 127, 143, 185, 238, 123, 127, 196) // threshold must be in the range 0-65536
TRANSLATION("time.struct_time() takes a 9-sequence", 37, 251, 240, 179, 173, 32, 253, 191, 191, 91, 92, 28, 119, 201, 128, 67, 249, 108, 253, 160) // time.struct_time() takes a 9-sequence
TRANSLATION("timeout must be 0.0-100.0 seconds", 33, 251, 210, 143, 123, 159, 135, 159, 179, 208, 231, 243, 240, 243, 193, 138, 8, 113, 96) // timeout must be 0.0-100.0 seconds
TRANSLATION("timeout waiting for v1 card", 27, 251, 210, 142, 25, 70, 79, 189, 82, 40, 100, 232, 4, 5, 98) // timeout waiting for v1 card
TRANSLATION("timeout waiting for v2 card", 27, 251, 210, 142, 25, 70, 79, 189, 82, 40, 100, 232, 132, 5, 98) // timeout waiting for v2 card
TRANSLATION("timestamp out of range for platform time_t", 42, 251, 217, 198, 203, 125, 95, 179, 70, 217, 139, 212, 139, 96, 125, 253, 183) // timestamp out of range for platform time_t
TRANSLATION("tobytes can be invoked for dense arrays only", 44, 116, 248, 194, 2, 97, 136, 180, 178, 38, 249, 71, 70, 36, 108, 65, 222, 4, 57, 220) // tobytes can be invoked for dense arrays only
TRANSLATION("too many arguments provided with the given format", 49, 116, 64, 176, 78, 237, 6, 11, 85, 50, 74, 37, 30, 111, 47, 28, 178, 17, 241, 64) // too many arguments provided with the given format
TRANSLATION("too many dimensions", 19, 116, 64, 176, 78, 224, 140, 172, 35, 242, 176) // too many dimensions
TRANSLATION("too many indices", 16, 116, 64, 176, 78, 237, 40, 202, 4, 192) // too many indices
TRANSLATION("too many values to unpack (expected %d)", 39, 116, 64, 176, 78, 224, 252, 155, 86, 135, 104, 195, 124, 53, 139, 244, 191, 29, 112) // too many values to unpack (expected %d)
TRANSLATION("trapz is defined for 1D arrays", 30, 117, 27, 124, 250, 127, 46, 143, 67, 168, 29, 224) // trapz is defined for 1D arrays
TRANSLATION("trapz is defined for 1D arrays of equal length", 46, 117, 27, 124, 250, 127, 46, 143, 67, 168, 29, 238, 65, 112, 80, 103, 198) // trapz is defined for 1D arrays of equal length
TRANSLATION("tx and rx cannot both be None", 29, 124, 222, 130, 230, 8, 119, 113, 35, 214, 24, 136, 58, 232, 100) // tx and rx cannot both be None
TRANSLATION("type '%q' is not an acceptable base type", 40, 123, 173, 46, 38, 159, 140, 76, 6, 16, 43, 95, 184, 24, 133, 139, 152) // type \'%q\' is not an acceptable base type
TRANSLATION("type is not an acceptable base type", 35, 123, 173, 45, 63, 24, 152, 12, 32, 86, 191, 112, 49, 11, 23, 48) // type is not an acceptable base type
TRANSLATION("type object 'generator' has no attribute '__await__'", 52, 123, 173, 46, 56, 96, 198, 71, 243, 96, 10, 197, 128, 208, 7, 240, 12, 29, 190, 216, 229, 25, 63, 111, 183, 128) // type object \'generator\' has no attribute \'__await__\'
TRANSLATION("type takes 1 or 3 arguments", 27, 123, 173, 32, 113, 223, 38, 14, 135, 39, 219, 208, 96) // type takes 1 or 3 arguments
TRANSLATION("unexpected indent", 17, 161, 151, 233, 35, 137, 27, 128) // unexpected indent
TRANSLATION("unexpected keyword argument '%q'", 32, 161, 151, 233, 244, 104, 113, 0) // unexpected keyword argument \'%q\'
TRANSLATION("unicode name escapes", 20, 161, 202, 9, 18, 3, 27, 8, 9, 160, 54, 147, 0) // unicode name escapes
TRANSLATION("unindent does not match any outer indentation level", 51, 161, 200, 226, 70, 225, 20, 38, 212, 176, 94, 21, 128, 157, 192, 148, 114, 93, 40, 145, 184, 240, 132, 203, 33, 76) // unindent does not match any outer indentation level
TRANSLATION("unknown format code '%c' for object of type '%q'", 48, 161, 239, 154, 101, 62, 47, 162, 24, 47, 195, 6, 138, 98, 241, 20, 31, 144, 247, 90, 92, 64) // unknown format code \'%c\' for object of type \'%q\'
TRANSLATION("unmatched '{' in format", 23, 161, 216, 47, 10, 202, 33, 131, 255, 184, 52, 184, 160) // unmatched \'{\' in format
TRANSLATION("unreadable attribute", 20, 161, 169, 12, 123, 128, 63, 128) // unreadable attribute
TRANSLATION("unsupported format character '%c' (0x%x) at index %d", 52, 161, 249, 184, 161, 10, 197, 70, 14, 74, 24, 47, 195, 0, 107, 115, 243, 95, 205, 174, 2, 250, 81, 44, 193, 126, 32) // unsupported format character \'%c\' (0x%x) at index %d
TRANSLATION("unsupported type for %q: '%q'", 29, 161, 249, 185, 154, 55, 248, 58, 92, 64) // unsupported type for %q: \'%q\'
TRANSLATION("unsupported types for %q: '%q', '%q'", 36, 161, 249, 185, 141, 163, 127, 131, 165, 196, 216, 226, 0) // unsupported types for %q: \'%q\', \'%q\'
TRANSLATION("value must fit in %d byte(s)", 28, 252, 130, 202, 51, 133, 82, 125, 32, 191, 16, 197, 115, 150, 179, 107, 128) // value must fit in %d byte(s)
TRANSLATION("vectors must have same lengths", 30, 200, 80, 116, 86, 11, 40, 206, 21, 142, 66, 6, 27, 11, 140, 192) // vectors must have same lengths
TRANSLATION("wrong axis index", 16, 252, 192, 115, 73, 180, 162, 89, 128) // wrong axis index
TRANSLATION("wrong axis specified", 20, 252, 192, 115, 73, 189, 146, 136) // wrong axis specified
TRANSLATION("wrong input type", 16, 252, 244, 173, 163, 243, 0) // wrong input type
TRANSLATION("wrong number of arguments", 25, 252, 195, 234, 228, 124, 76) // wrong number of arguments
TRANSLATION("wrong operand type", 18, 252, 195, 235, 56, 243, 0) // wrong operand type
TRANSLATION("wrong output type", 17, 252, 193, 40, 246, 209, 249, 128) // wrong output type
TRANSLATION("zero step", 9, 243, 146, 160, 51, 149, 160) // zero step
TRANSLATION("zi must be an ndarray", 21, 243, 202, 240, 159, 168) // zi must be an ndarray
TRANSLATION("zi must be of float type", 24, 243, 202, 242, 84, 21, 77, 5, 249, 128) // zi must be of float type
TRANSLATION("zi must be of shape (n_section, 2)", 34, 243, 202, 242, 84, 13, 88, 218, 65, 172, 125, 182, 40, 112, 236, 7, 71, 92) // zi must be of shape (n_section, 2)

// 5425 bytes worth of qstr
// 13455 bytes worth of translations
// 6575 bytes worth of translations compressed
// 6880 bytes saved
